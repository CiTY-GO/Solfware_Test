        -:    0:Source:grep.c
        -:    0:Graph:grep.gcno
        -:    0:Data:grep.gcda
        -:    0:Runs:1
        -:    1:/* grep.c - main driver file for grep.
        -:    2:   Copyright (C) 1992, 1997, 1998 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software; you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation; either version 2, or (at your option)
        -:    7:   any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program; if not, write to the Free Software
        -:   16:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
        -:   17:   02111-1307, USA.  */
        -:   18:
        -:   19:/* Written July 1992 by Mike Haertel.  */
        -:   20:
        -:   21:/**** I added all things in Makefile in order to run cfe *******/
        -:   22:#define HAVE_CONFIG_H 1
        -:   23:#define LOCALEDIR "/nfs/spectre/u4/jin/research/experiments/grep/docs/grep_2.2/lib/locale"
        -:   24:#define _LARGEFILE_SOURCE 1
        -:   25:#define _FILE_OFFSET_BITS 32 /* In order to let cfe work, change original 64 to 32*/
        -:   26:                             /* Reason: Please see /usr/include/sys/types.h */
        -:   27:/*typedef int off_t; */     /** since cfe can't recognize off_t defined in system file as int*/
        -:   28:			/* so I change all off_t to Off_t and define type of Off_t */ 
        -:   29:/****** end for cfe ***************/
        -:   30:
        -:   31:#ifdef HAVE_CONFIG_H
        -:   32:# include <config.h>
        -:   33:#define flag_config 1
        -:   34:#endif
        -:   35:#include <sys/types.h>
        -:   36:#define flag_typesh 1
        -:   37:#include <sys/stat.h>
        -:   38:#if defined(HAVE_MMAP)
        -:   39:# include <sys/mman.h>
        -:   40:#endif
        -:   41:#if defined(HAVE_SETRLIMIT)
        -:   42:# include <sys/time.h>
        -:   43:# include <sys/resource.h>
        -:   44:#endif
        -:   45:#include <stdio.h>
        -:   46:
        -:   47:/*******IMPORTANT CHANGE for let stderr redirect to a file *******/
        -:   48:#undef stderr
        -:   49:#define stderr stdout
        -:   50:/******* FINISH IMPORTANT CHANGE *********/
        -:   51:
        -:   52:#include "system.h"
        -:   53:#include "getopt.h"
        -:   54:#include "getpagesize.h"
        -:   55:#include "grep.h"
        -:   56:
        -:   57:#undef MAX
        -:   58:#define MAX(A,B) ((A) > (B) ? (A) : (B))
        -:   59:
        -:   60:/* if non-zero, display usage information and exit */
        -:   61:static int show_help;
        -:   62:
        -:   63:/* If non-zero, print the version on standard output and exit.  */
        -:   64:static int show_version;
        -:   65:
        -:   66:/* Long options equivalences. */
        -:   67:static struct option long_options[] =
        -:   68:{
        -:   69:  {"after-context", required_argument, NULL, 'A'},
        -:   70:  {"basic-regexp", no_argument, NULL, 'G'},
        -:   71:  {"before-context", required_argument, NULL, 'B'},
        -:   72:  {"byte-offset", no_argument, NULL, 'b'},
        -:   73:  {"context", no_argument, NULL, 'C'},
        -:   74:  {"count", no_argument, NULL, 'c'},
        -:   75:  {"extended-regexp", no_argument, NULL, 'E'},
        -:   76:  {"file", required_argument, NULL, 'f'},
        -:   77:  {"files-with-matches", no_argument, NULL, 'l'},
        -:   78:  {"files-without-match", no_argument, NULL, 'L'},
        -:   79:  {"fixed-regexp", no_argument, NULL, 'F'},
        -:   80:  {"fixed-strings", no_argument, NULL, 'F'},
        -:   81:  {"help", no_argument, &show_help, 1},
        -:   82:  {"ignore-case", no_argument, NULL, 'i'},
        -:   83:  {"line-number", no_argument, NULL, 'n'},
        -:   84:  {"line-regexp", no_argument, NULL, 'x'},
        -:   85:  {"no-filename", no_argument, NULL, 'h'},
        -:   86:  {"no-messages", no_argument, NULL, 's'},
        -:   87:  {"quiet", no_argument, NULL, 'q'},
        -:   88:  {"regexp", required_argument, NULL, 'e'},
        -:   89:  {"revert-match", no_argument, NULL, 'v'},
        -:   90:  {"silent", no_argument, NULL, 'q'},
        -:   91:#if O_BINARY
        -:   92:  {"binary", no_argument, NULL, 'U'},
        -:   93:  {"unix-byte-offsets", no_argument, NULL, 'u'},
        -:   94:#endif
        -:   95:  {"version", no_argument, NULL, 'V'},
        -:   96:  {"with-filename", no_argument, NULL, 'H'},
        -:   97:  {"word-regexp", no_argument, NULL, 'w'},
        -:   98:  {0, 0, 0, 0}
        -:   99:};
        -:  100:
        -:  101:/* Define flags declared in grep.h. */
        -:  102:char *matcher;
        -:  103:int match_icase;
        -:  104:int match_words;
        -:  105:int match_lines;
        -:  106:
        -:  107:/* For error messages. */
        -:  108:static char *prog;
        -:  109:static char *filename;
        -:  110:static int errseen;
        -:  111:
        -:  112:static int ck_atoi PARAMS((char const *, int *));
        -:  113:static void usage PARAMS((int));
        -:  114:static void error PARAMS((const char *, int));
        -:  115:static int  setmatcher PARAMS((char *));
        -:  116:static void reset PARAMS((int));
        -:  117:static int  fillbuf PARAMS((size_t));
        -:  118:static int  grepbuf PARAMS((char *, char *));
        -:  119:static void prtext PARAMS((char *, char *, int *));
        -:  120:static void prpending PARAMS((char *));
        -:  121:static void prline PARAMS((char *, char *, int));
        -:  122:static void nlscan PARAMS((char *));
        -:  123:static int  grep PARAMS((int));
        -:  124:
        -:  125:/* Functions we'll use to search. */
        -:  126:static void (*compile) PARAMS((char *, size_t));
        -:  127:static char *(*execute) PARAMS((char *, size_t, char **));
        -:  128:
        -:  129:/* Print a message and possibly an error string.  Remember
        -:  130:   that something awful happened. */
        -:  131:static void
    #####:  132:error(mesg, errnum)
        -:  133:     const char *mesg;
        -:  134:     int errnum;
        -:  135:{
    #####:  136:  if (errnum)
    #####:  137:    fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
        -:  138:  else
    #####:  139:    fprintf(stderr, "%s: %s\n", prog, mesg);
    #####:  140:  errseen = 1;
    #####:  141:}
        -:  142:
        -:  143:/* Like error(), but die horribly after printing. */
        -:  144:void
    #####:  145:fatal(mesg, errnum)
        -:  146:     const char *mesg;
        -:  147:     int errnum;
        -:  148:{
    #####:  149:  error(mesg, errnum);
    #####:  150:  exit(2);
        -:  151:}
        -:  152:
        -:  153:/* Interface to handle errors and fix library lossage. */
        -:  154:char *
        4:  155:xmalloc(size)
        -:  156:     size_t size;
        -:  157:{
        -:  158:  char *result;
        -:  159:
        4:  160:  result = malloc(size);
        4:  161:  if (size && !result)
    #####:  162:    fatal(_("memory exhausted"), 0);
        4:  163:  return result;
        -:  164:}
        -:  165:
        -:  166:/* Interface to handle errors and fix some library lossage. */
        -:  167:char *
    #####:  168:xrealloc(ptr, size)
        -:  169:     char *ptr;
        -:  170:     size_t size;
        -:  171:{
        -:  172:  char *result;
        -:  173:
    #####:  174:  if (ptr)
    #####:  175:    result = realloc(ptr, size);
        -:  176:  else
    #####:  177:    result = malloc(size);
    #####:  178:  if (size && !result)
    #####:  179:    fatal(_("memory exhausted"), 0);
    #####:  180:  return result;
        -:  181:
        -:  182:}
        -:  183:
        -:  184:/* Convert STR to a positive integer, storing the result in *OUT.
        -:  185:   If STR is not a valid integer, return -1 (otherwise 0). */
        -:  186:static int
    #####:  187:ck_atoi (str, out)
        -:  188:     char const *str;
        -:  189:     int *out;
        -:  190:{
        -:  191:  char const *p;
    #####:  192:  for (p = str; *p; p++)
    #####:  193:    if (*p < '0' || *p > '9')
    #####:  194:      return -1;
        -:  195:
    #####:  196:  *out = atoi (optarg);
    #####:  197:  return 0;
        -:  198:}
        -:  199:
        -:  200:
        -:  201:/* Hairy buffering mechanism for grep.  The intent is to keep
        -:  202:   all reads aligned on a page boundary and multiples of the
        -:  203:   page size. */
        -:  204:
        -:  205:static char *buffer;		/* Base of buffer. */
        -:  206:static size_t bufsalloc;	/* Allocated size of buffer save region. */
        -:  207:static size_t bufalloc;		/* Total buffer size. */
        -:  208:static int bufdesc;		/* File descriptor. */
        -:  209:static char *bufbeg;		/* Beginning of user-visible stuff. */
        -:  210:static char *buflim;		/* Limit of user-visible stuff. */
        -:  211:
        -:  212:#if defined(HAVE_MMAP)
        -:  213:static int bufmapped;		/* True for ordinary files. */
        -:  214:static struct stat bufstat;	/* From fstat(). */
        -:  215:static off_t bufoffset;		/* What read() normally remembers. */
        -:  216:#endif
        -:  217:
        -:  218:/* Reset the buffer for a new file.  Initialize
        -:  219:   on the first time through. */
        -:  220:static void
        1:  221:reset(fd)
        -:  222:     int fd;
        -:  223:{
        -:  224:  static int initialized;
        -:  225:
        1:  226:  if (!initialized)
        -:  227:    {
        1:  228:      initialized = 1;
        -:  229:#ifndef BUFSALLOC
        1:  230:      bufsalloc = MAX(8192, getpagesize());
        -:  231:#else
        -:  232:      bufsalloc = BUFSALLOC;
        -:  233:#endif
        1:  234:      bufalloc = 5 * bufsalloc;
        -:  235:      /* The 1 byte of overflow is a kludge for dfaexec(), which
        -:  236:	 inserts a sentinel newline at the end of the buffer
        -:  237:	 being searched.  There's gotta be a better way... */
        1:  238:      buffer = valloc(bufalloc + 1);
        1:  239:      if (!buffer)
    #####:  240:	fatal(_("memory exhausted"), 0);
        1:  241:      bufbeg = buffer;
        1:  242:      buflim = buffer;
        -:  243:    }
        1:  244:  bufdesc = fd;
        -:  245:#if defined(HAVE_MMAP)
        1:  246:  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))
    #####:  247:    bufmapped = 0;
        -:  248:  else
        -:  249:    {
        1:  250:      bufmapped = 1;
        1:  251:      bufoffset = lseek(fd, 0, 1);
        -:  252:    }
        -:  253:#endif
        1:  254:}
        -:  255:
        -:  256:/* Read new stuff into the buffer, saving the specified
        -:  257:   amount of old stuff.  When we're done, 'bufbeg' points
        -:  258:   to the beginning of the buffer contents, and 'buflim'
        -:  259:   points just after the end.  Return count of new stuff. */
        -:  260:static int
       11:  261:fillbuf(save)
        -:  262:     size_t save;
        -:  263:{
        -:  264:  char *nbuffer, *dp, *sp;
        -:  265:  int cc;
        -:  266:#if defined(HAVE_MMAP)
        -:  267:  caddr_t maddr;
        -:  268:#endif
        -:  269:  static int pagesize;
        -:  270:
       11:  271:  if (pagesize == 0 && (pagesize = getpagesize()) == 0)
    #####:  272:    abort();
        -:  273:
       11:  274:  if (save > bufsalloc)
        -:  275:    {
    #####:  276:      while (save > bufsalloc)
    #####:  277:	bufsalloc *= 2;
    #####:  278:      bufalloc = 5 * bufsalloc;
    #####:  279:      nbuffer = valloc(bufalloc + 1);
    #####:  280:      if (!nbuffer)
    #####:  281:	fatal(_("memory exhausted"), 0);
        -:  282:    }
        -:  283:  else
       11:  284:    nbuffer = buffer;
        -:  285:
       11:  286:  sp = buflim - save;
       11:  287:  dp = nbuffer + bufsalloc - save;
       11:  288:  bufbeg = dp;
      273:  289:  while (save--)
      262:  290:    *dp++ = *sp++;
        -:  291:
        -:  292:  /* We may have allocated a new, larger buffer.  Since
        -:  293:     there is no portable vfree(), we just have to forget
        -:  294:     about the old one.  Sorry. */
       11:  295:  buffer = nbuffer;
        -:  296:
        -:  297:#if defined(HAVE_MMAP)
       11:  298:  if (bufmapped && bufoffset % pagesize == 0
       10:  299:      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
        -:  300:    {
        9:  301:      maddr = buffer + bufsalloc;
        9:  302:      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
        -:  303:		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
        9:  304:      if (maddr == (caddr_t) -1)
        -:  305:	{
        -:  306:          /* This used to issue a warning, but on some hosts
        -:  307:             (e.g. Solaris 2.5) mmap can fail merely because some
        -:  308:             other process has an advisory erad lock on the file.
        -:  309:             There's no point alarming the use about this misfeature */
        -:  310:#if 0
        -:  311:	  fprintf(stderr, _("%s: warning: %s: %s\n"), prog, filename,
        -:  312:		  strerror(errno));
        -:  313:#endif
    #####:  314:	  goto tryread;
        -:  315:	}
        -:  316:#if 0
        -:  317:      /* You might thing this (or MADV_WILLNEED) would help,
        -:  318:	 but it doesn't, at least not on a Sun running 4.1.
        -:  319:	 In fact, it actually slows us down about 30%! */
        -:  320:      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
        -:  321:#endif
        9:  322:      cc = bufalloc - bufsalloc;
        9:  323:      bufoffset += cc;
        -:  324:    }
        -:  325:  else
        -:  326:    {
       2*:  327:    tryread:
        -:  328:      /* We come here when we're not going to use mmap() any more.
        -:  329:	 Note that we need to synchronize the file offset the
        -:  330:	 first time through. */
        2:  331:      if (bufmapped)
        -:  332:	{
        1:  333:	  bufmapped = 0;
        1:  334:	  lseek(bufdesc, bufoffset, 0);
        -:  335:	}
        2:  336:      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
        -:  337:    }
        -:  338:#else
        -:  339:  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
        -:  340:#endif
        -:  341:#if O_BINARY
        -:  342:  if (O_BINARY && cc > 0)
        -:  343:#ifndef FAULTY_F_KP_6
        -:  344:    cc = undossify_input(buffer + bufsalloc, cc);
        -:  345:#else
        -:  346:    cc = undossify_input(bufalloc - bufsalloc, cc);
        -:  347:#endif
        -:  348:#endif
       11:  349:  if (cc > 0)
       10:  350:    buflim = buffer + bufsalloc + cc;
        -:  351:  else
        1:  352:    buflim = buffer + bufsalloc;
       11:  353:  return cc;
        -:  354:}
        -:  355:
        -:  356:/* Flags controlling the style of output. */
        -:  357:static int out_quiet;		/* Suppress all normal output. */
        -:  358:static int out_invert;		/* Print nonmatching stuff. */
        -:  359:static int out_file;		/* Print filenames. */
        -:  360:static int out_line;		/* Print line numbers. */
        -:  361:static int out_byte;		/* Print byte offsets. */
        -:  362:static int out_before;		/* Lines of leading context. */
        -:  363:static int out_after;		/* Lines of trailing context. */
        -:  364:
        -:  365:/* Internal variables to keep track of byte count, context, etc. */
        -:  366:static size_t totalcc;		/* Total character count before bufbeg. */
        -:  367:static char *lastnl;		/* Pointer after last newline counted. */
        -:  368:static char *lastout;		/* Pointer after last character output;
        -:  369:				   NULL if no character has been output
        -:  370:				   or if it's conceptually before bufbeg. */
        -:  371:static size_t totalnl;		/* Total newline count before lastnl. */
        -:  372:static int pending;		/* Pending lines of output. */
        -:  373:static int done_on_match;		/* Stop scanning file on first match */
        -:  374:
        -:  375:#if O_BINARY
        -:  376:# include "dosbuf.c"
        -:  377:#endif
        -:  378:
        -:  379:static void
    #####:  380:nlscan(lim)
        -:  381:     char *lim;
        -:  382:{
        -:  383:  char *beg;
        -:  384:
    #####:  385:  for (beg = lastnl; beg < lim; ++beg)
    #####:  386:    if (*beg == '\n')
    #####:  387:      ++totalnl;
    #####:  388:  lastnl = beg;
    #####:  389:}
        -:  390:
        -:  391:static void
      832:  392:prline(beg, lim, sep)
        -:  393:     char *beg;
        -:  394:     char *lim;
        -:  395:     int sep;
        -:  396:{
      832:  397:  if (out_file)
    #####:  398:    printf("%s%c", filename, sep);
      832:  399:  if (out_line)
        -:  400:    {
    #####:  401:      nlscan(beg);
    #####:  402:      printf("%u%c", (unsigned int)++totalnl, sep);
    #####:  403:      lastnl = lim;
        -:  404:    }
      832:  405:  if (out_byte)
        -:  406:#if O_BINARY
        -:  407:    printf("%lu%c",
        -:  408:	   (unsigned long int) dossified_pos(totalcc + (beg - bufbeg)), sep);
        -:  409:#else
    #####:  410:    printf("%lu%c", (unsigned long int) (totalcc + (beg - bufbeg)), sep);
        -:  411:#endif
      832:  412:  fwrite(beg, 1, lim - beg, stdout);
      832:  413:  if (ferror(stdout))
    #####:  414:    error(_("writing output"), errno);
      832:  415:  lastout = lim;
      832:  416:}
        -:  417:
        -:  418:/* Print pending lines of trailing context prior to LIM. */
        -:  419:static void
    #####:  420:prpending(lim)
        -:  421:     char *lim;
        -:  422:{
        -:  423:  char *nl;
        -:  424:
    #####:  425:  if (!lastout)
    #####:  426:    lastout = bufbeg;
    #####:  427:  while (pending > 0 && lastout < lim)
        -:  428:    {
    #####:  429:      --pending;
    #####:  430:      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
    #####:  431:	++nl;
        -:  432:      else
    #####:  433:	nl = lim;
    #####:  434:      prline(lastout, nl, '-');
        -:  435:    }
    #####:  436:}
        -:  437:
        -:  438:/* Print the lines between BEG and LIM.  Deal with context crap.
        -:  439:   If NLINESP is non-null, store a count of lines between BEG and LIM. */
        -:  440:static void
      832:  441:prtext(beg, lim, nlinesp)
        -:  442:     char *beg;
        -:  443:     char *lim;
        -:  444:     int *nlinesp;
        -:  445:{
        -:  446:  static int used;		/* avoid printing "--" before any output */
        -:  447:  char *bp, *p, *nl;
        -:  448:  int i, n;
        -:  449:
      832:  450:  if (!out_quiet && pending > 0)
    #####:  451:    prpending(beg);
        -:  452:
      832:  453:  p = beg;
        -:  454:
      832:  455:  if (!out_quiet)
        -:  456:    {
        -:  457:      /* Deal with leading context crap. */
        -:  458:
      832:  459:      bp = lastout ? lastout : bufbeg;
     832*:  460:      for (i = 0; i < out_before; ++i)
    #####:  461:	if (p > bp)
        -:  462:	  do
    #####:  463:	    --p;
    #####:  464:	  while (p > bp && p[-1] != '\n');
        -:  465:
        -:  466:      /* We only print the "--" separator if our output is
        -:  467:	 discontiguous from the last output in the file. */
     832*:  468:      if ((out_before || out_after) && used && p != lastout)
    #####:  469:	puts("--");
        -:  470:
      832:  471:      while (p < beg)
        -:  472:	{
    #####:  473:	  nl = memchr(p, '\n', beg - p);
    #####:  474:	  prline(p, nl + 1, '-');
    #####:  475:	  p = nl + 1;
        -:  476:	}
        -:  477:    }
        -:  478:
      832:  479:  if (nlinesp)
        -:  480:    {
        -:  481:      /* Caller wants a line count. */
    #####:  482:      for (n = 0; p < lim; ++n)
        -:  483:	{
    #####:  484:	  if ((nl = memchr(p, '\n', lim - p)) != 0)
    #####:  485:	    ++nl;
        -:  486:	  else
    #####:  487:	    nl = lim;
    #####:  488:	  if (!out_quiet)
    #####:  489:	    prline(p, nl, ':');
    #####:  490:	  p = nl;
        -:  491:	}
    #####:  492:      *nlinesp = n;
        -:  493:    }
        -:  494:  else
      832:  495:    if (!out_quiet)
      832:  496:      prline(beg, lim, ':');
        -:  497:
      832:  498:  pending = out_after;
      832:  499:  used = 1;
      832:  500:}
        -:  501:
        -:  502:/* Scan the specified portion of the buffer, matching lines (or
        -:  503:   between matching lines if OUT_INVERT is true).  Return a count of
        -:  504:   lines printed. */
        -:  505:static int
       11:  506:grepbuf(beg, lim)
        -:  507:     char *beg;
        -:  508:     char *lim;
        -:  509:{
        -:  510:  int nlines, n;
        -:  511:  register char *p, *b;
        -:  512:  char *endp;
        -:  513:
       11:  514:  nlines = 0;
       11:  515:  p = beg;
      843:  516:  while ((b = (*execute)(p, lim - p, &endp)) != 0)
        -:  517:    {
        -:  518:      /* Avoid matching the empty line at the end of the buffer. */
     832*:  519:      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
        -:  520:	break;
      832:  521:      if (!out_invert)
        -:  522:	{
      832:  523:	  prtext(b, endp, (int *) 0);
      832:  524:	  nlines += 1;
      832:  525:	  if (done_on_match)
    #####:  526:	    return nlines;
        -:  527:	}
    #####:  528:      else if (p < b)
        -:  529:	{
    #####:  530:	  prtext(p, b, &n);
    #####:  531:	  nlines += n;
        -:  532:	}
      832:  533:      p = endp;
        -:  534:    }
      11*:  535:  if (out_invert && p < lim)
        -:  536:    {
    #####:  537:      prtext(p, lim, &n);
    #####:  538:      nlines += n;
        -:  539:    }
       11:  540:  return nlines;
        -:  541:}
        -:  542:
        -:  543:/* Search a given file.  Return a count of lines printed. */
        -:  544:static int
        1:  545:grep(fd)
        -:  546:     int fd;
        -:  547:{
        -:  548:  int nlines, i;
        -:  549:  size_t residue, save;
        -:  550:  char *beg, *lim;
        -:  551:
        1:  552:  reset(fd);
        -:  553:
        1:  554:  totalcc = 0;
        1:  555:  lastout = 0;
        1:  556:  totalnl = 0;
        1:  557:  pending = 0;
        -:  558:
        1:  559:  nlines = 0;
        1:  560:  residue = 0;
        1:  561:  save = 0;
        -:  562:
        -:  563:  for (;;)
        -:  564:    {
       11:  565:      if (fillbuf(save) < 0)
        -:  566:	{
    #####:  567:	  error(filename, errno);
    #####:  568:	  return nlines;
        -:  569:	}
       11:  570:      lastnl = bufbeg;
       11:  571:      if (lastout)
    #####:  572:	lastout = bufbeg;
       11:  573:      if (buflim - bufbeg == save)
        1:  574:	break;
       10:  575:      beg = bufbeg + save - residue;
      272:  576:      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
        -:  577:	;
       10:  578:      residue = buflim - lim;
       10:  579:      if (beg < lim)
        -:  580:	{
       10:  581:	  nlines += grepbuf(beg, lim);
       10:  582:	  if (pending)
    #####:  583:	    prpending(lim);
        -:  584:          #ifndef FAULTY_F_DG_7
      10*:  585:	  if (nlines && done_on_match && !out_invert)
    #####:  586:	    return nlines;
        -:  587:          #else
        -:  588:	  if (nlines && done_on_match && !out_quiet)
        -:  589:	    return nlines;
        -:  590:          #endif
        -:  591:	}
       10:  592:      i = 0;
       10:  593:      beg = lim;
      10*:  594:      while (i < out_before && beg > bufbeg && beg != lastout)
        -:  595:	{
    #####:  596:	  ++i;
        -:  597:	  do
    #####:  598:	    --beg;
    #####:  599:	  while (beg > bufbeg && beg[-1] != '\n');
        -:  600:	}
       10:  601:      if (beg != lastout)
       10:  602:	lastout = 0;
       10:  603:      save = residue + lim - beg;
       10:  604:      totalcc += buflim - bufbeg - save;
       10:  605:      if (out_line)
    #####:  606:	nlscan(beg);
        -:  607:    }
        1:  608:  if (residue)
        -:  609:    {
        1:  610:      nlines += grepbuf(bufbeg + save - residue, buflim);
        1:  611:      if (pending)
    #####:  612:	prpending(buflim);
        -:  613:    }
        1:  614:  return nlines;
        -:  615:}
        -:  616:
        -:  617:
        -:  618:static void
    #####:  619:usage(status)
        -:  620:int status;
        -:  621:{
    #####:  622:  if (status != 0)
        -:  623:    {
    #####:  624:      fprintf (stderr, _("Usage: %s [OPTION]... PATTERN [FILE]...\n"), prog);
    #####:  625:      fprintf (stderr, _("Try `%s --help' for more information.\n"), prog);
        -:  626:    }
        -:  627:  else
        -:  628:    {
    #####:  629:      printf (_("Usage: %s [OPTION]... PATTERN [FILE] ...\n"), prog);
    #####:  630:      printf (_("\
        -:  631:Search for PATTERN in each FILE or standard input.\n\
        -:  632:\n\
        -:  633:Regexp selection and interpretation:\n\
        -:  634:  -E, --extended-regexp     PATTERN is an extended regular expression\n\
        -:  635:  -F, --fixed-regexp        PATTERN is a fixed string separated by newlines\n\
        -:  636:  -G, --basic-regexp        PATTERN is a basic regular expression\n\
        -:  637:  -e, --regexp=PATTERN      use PATTERN as a regular expression\n\
        -:  638:  -f, --file=FILE           obtain PATTERN from FILE\n\
        -:  639:  -i, --ignore-case         ignore case distinctions\n\
        -:  640:  -w, --word-regexp         force PATTERN to match only whole words\n\
        -:  641:  -x, --line-regexp         force PATTERN to match only whole lines\n"));
    #####:  642:      printf (_("\
        -:  643:\n\
        -:  644:Miscellaneous:\n\
        -:  645:  -s, --no-messages         suppress error messages\n\
        -:  646:  -v, --revert-match        select non-matching lines\n\
        -:  647:  -V, --version             print version information and exit\n\
        -:  648:      --help                display this help and exit\n"));
    #####:  649:      printf (_("\
        -:  650:\n\
        -:  651:Output control:\n\
        -:  652:  -b, --byte-offset         print the byte offset with output lines\n\
        -:  653:  -n, --line-number         print line number with output lines\n\
        -:  654:  -H, --with-filename       print the filename for each match\n\
        -:  655:  -h, --no-filename         suppress the prefixing filename on output\n\
        -:  656:  -q, --quiet, --silent     suppress all normal output\n\
        -:  657:  -L, --files-without-match only print FILE names containing no match\n\
        -:  658:  -l, --files-with-matches  only print FILE names containing matches\n\
        -:  659:  -c, --count               only print a count of matching lines per FILE\n"));
    #####:  660:      printf (_("\
        -:  661:\n\
        -:  662:Context control:\n\
        -:  663:  -B, --before-context=NUM  print NUM lines of leading context\n\
        -:  664:  -A, --after-context=NUM   print NUM lines of trailing context\n\
        -:  665:  -NUM                      same as both -B NUM and -A NUM\n\
        -:  666:  -C, --context             same as -2\n\
        -:  667:  -U, --binary              do not strip CR characters at EOL (MSDOS)\n\
        -:  668:  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\
        -:  669:\n\
        -:  670:If no -[GEF], then `egrep' assumes -E, `fgrep' -F, else -G.\n\
        -:  671:With no FILE, or when FILE is -, read standard input. If less than\n\
        -:  672:two FILEs given, assume -h. Exit with 0 if matches, with 1 if none.\n\
        -:  673:Exit with 2 if syntax errors or system errors.\n"));
    #####:  674:      printf (_("\nReport bugs to <bug-gnu-utils@gnu.org>.\n"));
        -:  675:    }
    #####:  676:  exit(status);
        -:  677:}
        -:  678:
        -:  679:/* Go through the matchers vector and look for the specified matcher.
        -:  680:   If we find it, install it in compile and execute, and return 1.  */
        -:  681:static int
        2:  682:setmatcher(name)
        -:  683:     char *name;
        -:  684:{
        -:  685:  int i;
        -:  686:#ifdef HAVE_SETRLIMIT
        -:  687:  struct rlimit rlim;
        -:  688:#endif
        -:  689:
       11:  690:  for (i = 0; matchers[i].name; ++i)
       10:  691:    if (strcmp(name, matchers[i].name) == 0)
        -:  692:      {
        1:  693:	compile = matchers[i].compile;
        1:  694:	execute = matchers[i].execute;
        -:  695:#if HAVE_SETRLIMIT && defined(RLIMIT_STACK)
        -:  696:	/* I think every platform needs to do this, so that regex.c
        -:  697:	   doesn't oveflow the stack.  The default value of
        -:  698:	   `re_max_failures' is too large for some platforms: it needs
        -:  699:	   more than 3MB-large stack.
        -:  700:
        -:  701:	   The test for HAVE_SETRLIMIT should go into `configure'.  */
        -:  702:	if (!getrlimit (RLIMIT_STACK, &rlim))
        -:  703:	  {
        -:  704:	    long newlim;
        -:  705:	    extern long int re_max_failures; /* from regex.c */
        -:  706:
        -:  707:	    /* Approximate the amount regex.c needs, plus some more.  */
        -:  708:	    newlim = re_max_failures * 2 * 20 * sizeof (char *);
        -:  709:	    if (newlim > rlim.rlim_max)
        -:  710:	      {
        -:  711:		newlim = rlim.rlim_max;
        -:  712:		re_max_failures = newlim / (2 * 20 * sizeof (char *));
        -:  713:	      }
        -:  714:	    if (rlim.rlim_cur < newlim)
        -:  715:              #ifndef FAULTY_F_DG_5
        -:  716:	      rlim.rlim_cur = newlim;
        -:  717:              #else
        -:  718:	      newlim = rlim.rlim_cur;
        -:  719:              #endif
        -:  720:
        -:  721:	    setrlimit (RLIMIT_STACK, &rlim);
        -:  722:	  }
        -:  723:#endif
        1:  724:	return 1;
        -:  725:      }
        1:  726:  return 0;
        -:  727:}
        -:  728:
        -:  729:int
        1:  730:main(argc, argv)
        -:  731:     int argc;
        -:  732:     char *argv[];
        -:  733:{
        -:  734:  char *keys;
        -:  735:  size_t keycc, oldcc, keyalloc;
        -:  736:  int count_matches, no_filenames, list_files, suppress_errors;
        -:  737:  int with_filenames;
        -:  738:  int opt, cc, desc, count, status;
        -:  739:  FILE *fp;
        -:  740:  extern char *optarg;
        -:  741:  extern int optind;
        -:  742:  /* add this line for diff between *.c and *.int.c */
        1:  743:  argv[0] = "target1";
        -:  744:  
        1:  745:  prog = argv[0];
        1:  746:  if (prog && strrchr(prog, '/'))
    #####:  747:    prog = strrchr(prog, '/') + 1;
        -:  748:
        -:  749:#if defined(__MSDOS__) || defined(_WIN32)
        -:  750:  /* DOS and MS-Windows use backslashes as directory separators, and usually
        -:  751:     have an .exe suffix.  They also have case-insensitive filesystems.  */
        -:  752:  if (prog)
        -:  753:    {
        -:  754:      char *p = prog;
        -:  755:      char *bslash = strrchr(argv[0], '\\');
        -:  756:
        -:  757:      if (bslash && bslash >= prog) /* for mixed forward/backslash case */
        -:  758:	prog = bslash + 1;
        -:  759:      else if (prog == argv[0]
        -:  760:	       && argv[0][0] && argv[0][1] == ':') /* "c:progname" */
        -:  761:	prog = argv[0] + 2;
        -:  762:
        -:  763:      /* Collapse the letter-case, so `strcmp' could be used hence.  */
        -:  764:      for ( ; *p; p++)
        -:  765:	if (*p >= 'A' && *p <= 'Z')
        -:  766:	  *p += 'a' - 'A';
        -:  767:
        -:  768:      /* Remove the .exe extension, if any.  */
        -:  769:      if ((p = strrchr(prog, '.')) && strcmp(p, ".exe") == 0)
        -:  770:	*p = '\0';
        -:  771:    }
        -:  772:#endif
        -:  773:
        1:  774:  keys = NULL;
        1:  775:  keycc = 0;
        1:  776:  count_matches = 0;
        1:  777:  no_filenames = 0;
        1:  778:  with_filenames = 0;
        1:  779:  list_files = 0;
        1:  780:  suppress_errors = 0;
        1:  781:  matcher = NULL;
        -:  782:
        -:  783:/* Internationalization. */
        -:  784:#if HAVE_SETLOCALE
        1:  785:  setlocale (LC_ALL, "");
        -:  786:#endif
        -:  787:#if ENABLE_NLS
        1:  788:  bindtextdomain (PACKAGE, LOCALEDIR);
        1:  789:  textdomain (PACKAGE);
        -:  790:#endif
        -:  791:
        1:  792:  while ((opt = getopt_long(argc, argv,
        -:  793:#if O_BINARY
        -:  794:         "0123456789A:B:CEFGHVX:bce:f:hiLlnqsvwxyUu",
        -:  795:#else
        -:  796:         "0123456789A:B:CEFGHVX:bce:f:hiLlnqsvwxy",
        -:  797:#endif
        1:  798:         long_options, NULL)) != EOF)
    #####:  799:    switch (opt)
        -:  800:      {
    #####:  801:      case '0':
        -:  802:      case '1':
        -:  803:      case '2':
        -:  804:      case '3':
        -:  805:      case '4':
        -:  806:      case '5':
        -:  807:      case '6':
        -:  808:      case '7':
        -:  809:      case '8':
        -:  810:      case '9':
    #####:  811:	out_before = 10 * out_before + opt - '0';
    #####:  812:	out_after = 10 * out_after + opt - '0';
    #####:  813:	break;
    #####:  814:      case 'A':
    #####:  815:	if (optarg)
        -:  816:	  {
    #####:  817:	    if (ck_atoi (optarg, &out_after))
    #####:  818:	      fatal (_("invalid context length argument"), 0);
        -:  819:	  }
    #####:  820:	break;
    #####:  821:      case 'B':
    #####:  822:	if (optarg)
        -:  823:	  {
    #####:  824:	    if (ck_atoi (optarg, &out_before))
    #####:  825:	      fatal (_("invalid context length argument"), 0);
        -:  826:	  }
    #####:  827:	break;
    #####:  828:      case 'C':
    #####:  829:	out_before = out_after = 2;
    #####:  830:	break;
    #####:  831:      case 'E':
    #####:  832:	if (matcher && strcmp(matcher, "posix-egrep") != 0)
    #####:  833:	  fatal(_("you may specify only one of -E, -F, or -G"), 0);
    #####:  834:	matcher = "posix-egrep";
    #####:  835:	break;
    #####:  836:      case 'F':
    #####:  837:	if (matcher && strcmp(matcher, "fgrep") != 0)
    #####:  838:	  fatal(_("you may specify only one of -E, -F, or -G"), 0);;
    #####:  839:	matcher = "fgrep";
    #####:  840:	break;
    #####:  841:      case 'G':
    #####:  842:	if (matcher && strcmp(matcher, "grep") != 0)
    #####:  843:	  fatal(_("you may specify only one of -E, -F, or -G"), 0);
    #####:  844:	matcher = "grep";
    #####:  845:	break;
    #####:  846:      case 'H':
    #####:  847:	with_filenames = 1;
    #####:  848:	break;
        -:  849:#if O_BINARY
        -:  850:      case 'U':
        -:  851:	dos_use_file_type = DOS_BINARY;
        -:  852:	break;
        -:  853:      case 'u':
        -:  854:	dos_report_unix_offset = 1;
        -:  855:	break;
        -:  856:#endif
    #####:  857:      case 'V':
    #####:  858:	show_version = 1;
    #####:  859:	break;
    #####:  860:      case 'X':
    #####:  861:	if (matcher)
    #####:  862:	  fatal(_("matcher already specified"), 0);
    #####:  863:	matcher = optarg;
    #####:  864:	break;
    #####:  865:      case 'b':
    #####:  866:	out_byte = 1;
    #####:  867:	break;
    #####:  868:      case 'c':
    #####:  869:	out_quiet = 1;
    #####:  870:	count_matches = 1;
    #####:  871:	break;
    #####:  872:      case 'e':
    #####:  873:	cc = strlen(optarg);
    #####:  874:	keys = xrealloc(keys, keycc + cc + 1);
    #####:  875:	strcpy(&keys[keycc], optarg);
    #####:  876:	keycc += cc;
    #####:  877:	keys[keycc++] = '\n';
    #####:  878:	break;
    #####:  879:      case 'f':
    #####:  880:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
    #####:  881:	if (!fp)
    #####:  882:	  fatal(optarg, errno);
    #####:  883:	for (keyalloc = 1; keyalloc <= keycc + 1; keyalloc *= 2)
        -:  884:	  ;
    #####:  885:	keys = xrealloc(keys, keyalloc);
    #####:  886:	oldcc = keycc;
    #####:  887:	while (!feof(fp)
    #####:  888:	       && (cc = fread(keys + keycc, 1, keyalloc - 1 - keycc, fp)) > 0)
        -:  889:	  {
    #####:  890:	    keycc += cc;
    #####:  891:	    if (keycc == keyalloc - 1)
    #####:  892:	      keys = xrealloc(keys, keyalloc *= 2);
        -:  893:	  }
    #####:  894:	if (fp != stdin)
    #####:  895:	  fclose(fp);
        -:  896:	/* Append final newline if file ended in non-newline. */
    #####:  897:	if (oldcc != keycc && keys[keycc - 1] != '\n')
    #####:  898:	  keys[keycc++] = '\n';
    #####:  899:	break;
    #####:  900:      case 'h':
    #####:  901:	no_filenames = 1;
    #####:  902:	break;
    #####:  903:      case 'i':
        -:  904:      case 'y':			/* For old-timers . . . */
    #####:  905:	match_icase = 1;
    #####:  906:	break;
    #####:  907:      case 'L':
        -:  908:	/* Like -l, except list files that don't contain matches.
        -:  909:	   Inspired by the same option in Hume's gre. */
    #####:  910:	out_quiet = 1;
    #####:  911:	list_files = -1;
    #####:  912:	done_on_match = 1;
    #####:  913:	break;
    #####:  914:      case 'l':
    #####:  915:	out_quiet = 1;
    #####:  916:	list_files = 1;
    #####:  917:	done_on_match = 1;
    #####:  918:	break;
    #####:  919:      case 'n':
    #####:  920:	out_line = 1;
    #####:  921:	break;
    #####:  922:      case 'q':
    #####:  923:	done_on_match = 1;
    #####:  924:	out_quiet = 1;
    #####:  925:	break;
    #####:  926:      case 's':
    #####:  927:	suppress_errors = 1;
    #####:  928:	break;
    #####:  929:      case 'v':
    #####:  930:	out_invert = 1;
    #####:  931:	break;
    #####:  932:      case 'w':
    #####:  933:	match_words = 1;
    #####:  934:	break;
    #####:  935:      case 'x':
    #####:  936:	match_lines = 1;
    #####:  937:	break;
    #####:  938:      case 0:
        -:  939:	/* long options */
    #####:  940:	break;
    #####:  941:      default:
    #####:  942:	usage(2);
    #####:  943:	break;
        -:  944:      }
        -:  945:
        1:  946:  if (show_version)
        -:  947:    {
    #####:  948:      printf (_("grep (GNU grep) %s\n"), VERSION);
    #####:  949:      printf ("\n");
    #####:  950:      printf (_("\
        -:  951:Copyright (C) 1988, 92, 93, 94, 95, 96, 97 Free Software Foundation, Inc.\n"));
    #####:  952:      printf (_("\
        -:  953:This is free software; see the source for copying conditions. There is NO\n\
        -:  954:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"));
    #####:  955:      printf ("\n");
    #####:  956:      exit (0);
        -:  957:    }
        -:  958:
        1:  959:  if (show_help)
    #####:  960:    usage(0);
        -:  961:
        1:  962:  if (keys)
        -:  963:    {
        -:  964:      /* No keys were specified (e.g. -f /dev/null)/ Match nothing/ */
    #####:  965:      if (keycc == 0)
    #####:  966:        out_invert ^= 1;
        -:  967:      else /* strip trailin newline. */
    #####:  968:        --keycc;
        -:  969:    }
        -:  970:  else
        1:  971:    if (optind < argc)
        -:  972:      {
        1:  973:	keys = argv[optind++];
        1:  974:	keycc = strlen(keys);
        -:  975:      }
        -:  976:    else
    #####:  977:      usage(2);
        -:  978:
        1:  979:  if (!matcher)
        1:  980:    matcher = prog;
        -:  981:
        1:  982:  if (!setmatcher(matcher) && !setmatcher("default"))
    #####:  983:    abort();
        -:  984:
        1:  985:  (*compile)(keys, keycc);
        -:  986:
       1*:  987:  if ((argc - optind > 1 && !no_filenames) || with_filenames)
    #####:  988:    out_file = 1;
        -:  989:
        1:  990:  status = 1;
        -:  991:
        1:  992:  if (optind < argc)
        2:  993:    while (optind < argc)
        -:  994:      {
        1:  995:	if (strcmp(argv[optind], "-") == 0)
        -:  996:	  {
    #####:  997:	    filename = _("(standard input)");
    #####:  998:	    desc = 0;
        -:  999:	  }
        -: 1000:	else
        -: 1001:	  {
        -: 1002:#if defined(__MSDOS__) || defined(_WIN32)
        -: 1003:	    struct stat st;
        -: 1004:	    if (stat (argv[optind], &st) == 0 && S_ISDIR(st.st_mode))
        -: 1005:	      {
        -: 1006:		++optind;
        -: 1007:		continue;
        -: 1008:	      }
        -: 1009:#endif
        1: 1010:	    filename = argv[optind];
        1: 1011:	    desc = open(argv[optind], O_RDONLY);
        -: 1012:	  }
        1: 1013:	if (desc < 0)
        -: 1014:	  {
    #####: 1015:	    if (!suppress_errors)
    #####: 1016:	      error(argv[optind], errno);
        -: 1017:	  }
        -: 1018:	else
        -: 1019:	  {
        -: 1020:#if O_BINARY
        -: 1021:	    /* Set input to binary mode.  Pipes are simulated with files
        -: 1022:	       on DOS, so this includes the case of "foo | grep bar".  */
        -: 1023:	    if (!isatty(desc))
        -: 1024:	      SET_BINARY(desc);
        -: 1025:#endif
        1: 1026:	    count = grep(desc);
        1: 1027:	    if (count_matches)
        -: 1028:	      {
    #####: 1029:		if (out_file)
    #####: 1030:		  printf("%s:", filename);
    #####: 1031:		printf("%d\n", count);
        -: 1032:	      }
        1: 1033:	    if (count)
        -: 1034:	      {
        1: 1035:		status = 0;
        1: 1036:		if (list_files == 1)
    #####: 1037:		  printf("%s\n", filename);
        -: 1038:	      }
    #####: 1039:	    else if (list_files == -1)
    #####: 1040:	      printf("%s\n", filename);
        1: 1041:	    if (desc != 0)
        1: 1042:	      close(desc);
        -: 1043:	  }
        1: 1044:	++optind;
        -: 1045:      }
        -: 1046:  else
        -: 1047:    {
    #####: 1048:      filename = _("(standard input)");
        -: 1049:#if O_BINARY
        -: 1050:      if (!isatty(0))
        -: 1051:	SET_BINARY(0);
        -: 1052:#endif
    #####: 1053:      count = grep(0);
    #####: 1054:      if (count_matches)
    #####: 1055:	printf("%d\n", count);
    #####: 1056:      if (count)
        -: 1057:	{
    #####: 1058:	  status = 0;
    #####: 1059:	  if (list_files == 1)
    #####: 1060:	    printf(_("(standard input)\n"));
        -: 1061:	}
    #####: 1062:      else if (list_files == -1)
    #####: 1063:	printf(_("(standard input)\n"));
        -: 1064:    }
        -: 1065:
        1: 1066:  if (fclose (stdout) == EOF)
    #####: 1067:    error (_("writing output"), errno);
        -: 1068:
       1*: 1069:  exit(errseen ? 2 : status);
        -: 1070:}
        -: 1071:/* dfa.c - deterministic extended regexp routines for GNU
        -: 1072:   Copyright (C) 1988, 1998 Free Software Foundation, Inc.
        -: 1073:
        -: 1074:   This program is free software; you can redistribute it and/or modify
        -: 1075:   it under the terms of the GNU General Public License as published by
        -: 1076:   the Free Software Foundation; either version 2, or (at your option)
        -: 1077:   any later version.
        -: 1078:
        -: 1079:   This program is distributed in the hope that it will be useful,
        -: 1080:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1081:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1082:   GNU General Public License for more details.
        -: 1083:
        -: 1084:   You should have received a copy of the GNU General Public License
        -: 1085:   along with this program; if not, write to the Free Software
        -: 1086:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA */
        -: 1087:
        -: 1088:/* Written June, 1988 by Mike Haertel
        -: 1089:   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
        -: 1090:
        -: 1091:#ifdef HAVE_CONFIG_H
        -: 1092:#if flag_config==0
        -: 1093:#include <config.h>
        -: 1094:#define flag_config 1
        -: 1095:#endif
        -: 1096:#endif
        -: 1097:
        -: 1098:#include <assert.h>
        -: 1099:#include <ctype.h>
        -: 1100:/*#include <stdio.h>*/
        -: 1101:
        -: 1102:/*#include <sys/types.h>*/
        -: 1103:#ifdef STDC_HEADERS
        -: 1104:#include <stdlib.h>
        -: 1105:#define flag_stdlib 1
        -: 1106:#else
        -: 1107:extern char *calloc(), *malloc(), *realloc();
        -: 1108:extern void free();
        -: 1109:#endif
        -: 1110:
        -: 1111:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
        -: 1112:#include <string.h>
        -: 1113:#define flag_string 1
        -: 1114:#undef index
        -: 1115:#define index strchr
        -: 1116:#else
        -: 1117:#include <strings.h>
        -: 1118:#define flag_strings 1
        -: 1119:#endif
        -: 1120:
        -: 1121:#ifndef DEBUG	/* use the same approach as regex.c */
        -: 1122:#undef assert
        -: 1123:#define assert(e)
        -: 1124:#endif /* DEBUG */
        -: 1125:
        -: 1126:#ifndef isgraph
        -: 1127:#define isgraph(C) (isprint(C) && !isspace(C))
        -: 1128:#endif
        -: 1129:
        -: 1130:#undef ISALPHA
        -: 1131:#undef ISUPPER
        -: 1132:#undef ISLOWER
        -: 1133:#undef ISDIGIT
        -: 1134:#undef ISXDIGIT
        -: 1135:#undef ISSPACE
        -: 1136:#undef ISPUNCT
        -: 1137:#undef ISALNUM
        -: 1138:#undef ISPRINT
        -: 1139:#undef ISGRAPH
        -: 1140:#undef ISCNTRL
        -: 1141:
        -: 1142:#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
        -: 1143:#define ISALPHA(C) isalpha(C)
        -: 1144:#define ISUPPER(C) isupper(C)
        -: 1145:#define ISLOWER(C) islower(C)
        -: 1146:#define ISDIGIT(C) isdigit(C)
        -: 1147:#define ISXDIGIT(C) isxdigit(C)
        -: 1148:#define ISSPACE(C) isspace(C)
        -: 1149:#define ISPUNCT(C) ispunct(C)
        -: 1150:#define ISALNUM(C) isalnum(C)
        -: 1151:#define ISPRINT(C) isprint(C)
        -: 1152:#define ISGRAPH(C) isgraph(C)
        -: 1153:#define ISCNTRL(C) iscntrl(C)
        -: 1154:#else
        -: 1155:#define ISALPHA(C) (isascii(C) && isalpha(C))
        -: 1156:#define ISUPPER(C) (isascii(C) && isupper(C))
        -: 1157:#define ISLOWER(C) (isascii(C) && islower(C))
        -: 1158:#define ISDIGIT(C) (isascii(C) && isdigit(C))
        -: 1159:#define ISXDIGIT(C) (isascii(C) && isxdigit(C))
        -: 1160:#define ISSPACE(C) (isascii(C) && isspace(C))
        -: 1161:#define ISPUNCT(C) (isascii(C) && ispunct(C))
        -: 1162:#define ISALNUM(C) (isascii(C) && isalnum(C))
        -: 1163:#define ISPRINT(C) (isascii(C) && isprint(C))
        -: 1164:#define ISGRAPH(C) (isascii(C) && isgraph(C))
        -: 1165:#define ISCNTRL(C) (isascii(C) && iscntrl(C))
        -: 1166:#endif
        -: 1167:
        -: 1168:/* If we (don't) have I18N.  */
        -: 1169:/* glibc defines _ */
        -: 1170:#ifndef _
        -: 1171:# ifdef HAVE_LIBINTL_H
        -: 1172:#  include <libintl.h>
        -: 1173:#define flag_libintl 1
        -: 1174:#  ifndef _
        -: 1175:#   define _(Str) gettext (Str)
        -: 1176:#  endif
        -: 1177:# else
        -: 1178:#  define _(Str) (Str)
        -: 1179:# endif
        -: 1180:#endif
        -: 1181:
        -: 1182:#include "regex.h"
        -: 1183:#include "dfa.h"
        -: 1184:
        -: 1185:static void dfamust PARAMS ((struct dfa *dfa));
        -: 1186:
        -: 1187:static ptr_t xcalloc PARAMS ((size_t n, size_t s));
        -: 1188:static ptr_t xmalloc_1 PARAMS ((size_t n));
        -: 1189:static ptr_t xrealloc_1 PARAMS ((ptr_t p, size_t n));
        -: 1190:#ifdef DEBUG
        -: 1191:static void prtok PARAMS ((token t));
        -: 1192:#endif
        -: 1193:static int tstbit PARAMS ((int b, charclass c));
        -: 1194:static void setbit PARAMS ((int b, charclass c));
        -: 1195:static void clrbit PARAMS ((int b, charclass c));
        -: 1196:static void copyset PARAMS ((charclass src, charclass dst));
        -: 1197:static void zeroset PARAMS ((charclass s));
        -: 1198:static void notset PARAMS ((charclass s));
        -: 1199:static int equal PARAMS ((charclass s1, charclass s2));
        -: 1200:static int charclass_index PARAMS ((charclass s));
        -: 1201:static int looking_at PARAMS ((const char *s));
        -: 1202:static token lex PARAMS ((void));
        -: 1203:static void addtok PARAMS ((token t));
        -: 1204:static void atom PARAMS ((void));
        -: 1205:static int nsubtoks PARAMS ((int tindex));
        -: 1206:static void copytoks PARAMS ((int tindex, int ntokens));
        -: 1207:static void closure PARAMS ((void));
        -: 1208:static void branch PARAMS ((void));
        -: 1209:static void regexp PARAMS ((int toplevel));
        -: 1210:static void copy PARAMS ((position_set *src, position_set *dst));
        -: 1211:static void insert PARAMS ((position p, position_set *s));
        -: 1212:static void merge PARAMS ((position_set *s1, position_set *s2, position_set *m));
        -: 1213:static void delete PARAMS ((position p, position_set *s));
        -: 1214:static int state_index PARAMS ((struct dfa *d, position_set *s,
        -: 1215:			  int newline, int letter));
        -: 1216:static void build_state PARAMS ((int s, struct dfa *d));
        -: 1217:static void build_state_zero PARAMS ((struct dfa *d));
        -: 1218:static char *icatalloc PARAMS ((char *old, char *new));
        -: 1219:static char *icpyalloc PARAMS ((char *string));
        -: 1220:static char *istrstr PARAMS ((char *lookin, char *lookfor));
        -: 1221:static void ifree PARAMS ((char *cp));
        -: 1222:static void freelist PARAMS ((char **cpp));
        -: 1223:static char **enlist PARAMS ((char **cpp, char *new, size_t len));
        -: 1224:static char **comsubs PARAMS ((char *left, char *right));
        -: 1225:static char **addlists PARAMS ((char **old, char **new));
        -: 1226:static char **inboth PARAMS ((char **left, char **right));
        -: 1227:
        -: 1228:static ptr_t
        3: 1229:xcalloc(n, s)
        -: 1230:     size_t n;
        -: 1231:     size_t s;
        -: 1232:{
        3: 1233:  ptr_t r = calloc(n, s);
        -: 1234:
        3: 1235:  if (!r)
    #####: 1236:    dfaerror(_("Memory exhausted"));
        3: 1237:  return r;
        -: 1238:}
        -: 1239:
        -: 1240:static ptr_t
       29: 1241:xmalloc_1(n)
        -: 1242:     size_t n;
        -: 1243:{
       29: 1244:  ptr_t r = malloc(n);
        -: 1245:
        -: 1246:  assert(n != 0);
       29: 1247:  if (!r)
    #####: 1248:    dfaerror(_("Memory exhausted"));
       29: 1249:  return r;
        -: 1250:}
        -: 1251:
        -: 1252:static ptr_t
        8: 1253:xrealloc_1(p, n)
        -: 1254:     ptr_t p;
        -: 1255:     size_t n;
        -: 1256:{
        8: 1257:  ptr_t r = realloc(p, n);
        -: 1258:
        -: 1259:  assert(n != 0);
        8: 1260:  if (!r)
    #####: 1261:    dfaerror(_("Memory exhausted"));
        8: 1262:  return r;
        -: 1263:}
        -: 1264:
        -: 1265:#define CALLOC(p, t, n) ((p) = (t *) xcalloc((size_t)(n), sizeof (t)))
        -: 1266:#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
        -: 1267:#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
        -: 1268:
        -: 1269:/* Reallocate an array of type t if nalloc is too small for index. */
        -: 1270:#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
        -: 1271:  if ((index) >= (nalloc))			  \
        -: 1272:    {						  \
        -: 1273:      while ((index) >= (nalloc))		  \
        -: 1274:	(nalloc) *= 2;				  \
        -: 1275:      REALLOC(p, t, nalloc);			  \
        -: 1276:    }
        -: 1277:
        -: 1278:#ifdef DEBUG
        -: 1279:
        -: 1280:static void
        -: 1281:prtok(t)
        -: 1282:     token t;
        -: 1283:{
        -: 1284:  char *s;
        -: 1285:
        -: 1286:  if (t < 0)
        -: 1287:    fprintf(stderr, "END");
        -: 1288:  else if (t < NOTCHAR)
        -: 1289:    fprintf(stderr, "%c", t);
        -: 1290:  else
        -: 1291:    {
        -: 1292:      switch (t)
        -: 1293:	{
        -: 1294:	case EMPTY: s = "EMPTY"; break;
        -: 1295:	case BACKREF: s = "BACKREF"; break;
        -: 1296:	case BEGLINE: s = "BEGLINE"; break;
        -: 1297:	case ENDLINE: s = "ENDLINE"; break;
        -: 1298:	case BEGWORD: s = "BEGWORD"; break;
        -: 1299:	case ENDWORD: s = "ENDWORD"; break;
        -: 1300:	case LIMWORD: s = "LIMWORD"; break;
        -: 1301:	case NOTLIMWORD: s = "NOTLIMWORD"; break;
        -: 1302:	case QMARK: s = "QMARK"; break;
        -: 1303:	case STAR: s = "STAR"; break;
        -: 1304:	case PLUS: s = "PLUS"; break;
        -: 1305:	case CAT: s = "CAT"; break;
        -: 1306:	case OR: s = "OR"; break;
        -: 1307:	case ORTOP: s = "ORTOP"; break;
        -: 1308:	case LPAREN: s = "LPAREN"; break;
        -: 1309:	case RPAREN: s = "RPAREN"; break;
        -: 1310:	default: s = "CSET"; break;
        -: 1311:	}
        -: 1312:      fprintf(stderr, "%s", s);
        -: 1313:    }
        -: 1314:}
        -: 1315:#endif /* DEBUG */
        -: 1316:
        -: 1317:/* Stuff pertaining to charclasses. */
        -: 1318:
        -: 1319:static int
        2: 1320:tstbit(b, c)
        -: 1321:     int b;
        -: 1322:     charclass c;
        -: 1323:{
        2: 1324:  return c[b / INTBITS] & 1 << b % INTBITS;
        -: 1325:}
        -: 1326:
        -: 1327:static void
       66: 1328:setbit(b, c)
        -: 1329:     int b;
        -: 1330:     charclass c;
        -: 1331:{
       66: 1332:  c[b / INTBITS] |= 1 << b % INTBITS;
       66: 1333:}
        -: 1334:
        -: 1335:static void
    #####: 1336:clrbit(b, c)
        -: 1337:     int b;
        -: 1338:     charclass c;
        -: 1339:{
    #####: 1340:  c[b / INTBITS] &= ~(1 << b % INTBITS);
    #####: 1341:}
        -: 1342:
        -: 1343:static void
        2: 1344:copyset(src, dst)
        -: 1345:     charclass src;
        -: 1346:     charclass dst;
        -: 1347:{
        -: 1348:  int i;
        -: 1349:
       18: 1350:  for (i = 0; i < CHARCLASS_INTS; ++i)
       16: 1351:    dst[i] = src[i];
        2: 1352:}
        -: 1353:
        -: 1354:static void
        4: 1355:zeroset(s)
        -: 1356:     charclass s;
        -: 1357:{
        -: 1358:  int i;
        -: 1359:
       36: 1360:  for (i = 0; i < CHARCLASS_INTS; ++i)
       32: 1361:    s[i] = 0;
        4: 1362:}
        -: 1363:
        -: 1364:static void
    #####: 1365:notset(s)
        -: 1366:     charclass s;
        -: 1367:{
        -: 1368:  int i;
        -: 1369:
    #####: 1370:  for (i = 0; i < CHARCLASS_INTS; ++i)
    #####: 1371:    s[i] = ~s[i];
    #####: 1372:}
        -: 1373:
        -: 1374:static int
    #####: 1375:equal(s1, s2)
        -: 1376:     charclass s1;
        -: 1377:     charclass s2;
        -: 1378:{
        -: 1379:  int i;
        -: 1380:
    #####: 1381:  for (i = 0; i < CHARCLASS_INTS; ++i)
    #####: 1382:    if (s1[i] != s2[i])
    #####: 1383:      return 0;
    #####: 1384:  return 1;
        -: 1385:}
        -: 1386:
        -: 1387:/* A pointer to the current dfa is kept here during parsing. */
        -: 1388:static struct dfa *dfa;
        -: 1389:
        -: 1390:/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
        -: 1391:static int
    #####: 1392:charclass_index(s)
        -: 1393:     charclass s;
        -: 1394:{
        -: 1395:  int i;
        -: 1396:
    #####: 1397:  for (i = 0; i < dfa->cindex; ++i)
    #####: 1398:    if (equal(s, dfa->charclasses[i]))
    #####: 1399:      return i;
    #####: 1400:  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
    #####: 1401:  ++dfa->cindex;
    #####: 1402:  copyset(s, dfa->charclasses[i]);
    #####: 1403:  return i;
        -: 1404:}
        -: 1405:
        -: 1406:/* Syntax bits controlling the behavior of the lexical analyzer. */
        -: 1407:static reg_syntax_t syntax_bits, syntax_bits_set;
        -: 1408:
        -: 1409:/* Flag for case-folding letters into sets. */
        -: 1410:static int case_fold;
        -: 1411:
        -: 1412:/* Entry point to set syntax options. */
        -: 1413:void
        1: 1414:dfasyntax(bits, fold)
        -: 1415:     reg_syntax_t bits;
        -: 1416:     int fold;
        -: 1417:{
        1: 1418:  syntax_bits_set = 1;
        1: 1419:  syntax_bits = bits;
        1: 1420:  case_fold = fold;
        1: 1421:}
        -: 1422:
        -: 1423:/* Lexical analyzer.  All the dross that deals with the obnoxious
        -: 1424:   GNU Regex syntax bits is located here.  The poor, suffering
        -: 1425:   reader is referred to the GNU Regex documentation for the
        -: 1426:   meaning of the @#%!@#%^!@ syntax bits. */
        -: 1427:
        -: 1428:static char *lexstart;		/* Pointer to beginning of input string. */
        -: 1429:static char *lexptr;		/* Pointer to next input character. */
        -: 1430:static int lexleft;		/* Number of characters remaining. */
        -: 1431:static token lasttok;		/* Previous token returned; initially END. */
        -: 1432:static int laststart;		/* True if we're separated from beginning or (, |
        -: 1433:				   only by zero-width characters. */
        -: 1434:static int parens;		/* Count of outstanding left parens. */
        -: 1435:static int minrep, maxrep;	/* Repeat counts for {m,n}. */
        -: 1436:
        -: 1437:/* Note that characters become unsigned here. */
        -: 1438:#define FETCH(c, eoferr)   	      \
        -: 1439:  {			   	      \
        -: 1440:    if (! lexleft)	   	      \
        -: 1441:      if (eoferr != 0)	   	      \
        -: 1442:	dfaerror(eoferr);  	      \
        -: 1443:      else		   	      \
        -: 1444:	return lasttok = END;	      \
        -: 1445:    (c) = (unsigned char) *lexptr++;  \
        -: 1446:    --lexleft;		   	      \
        -: 1447:  }
        -: 1448:
        -: 1449:#ifdef __STDC__
        -: 1450:#define FUNC(F, P) static int F(int c) { return P(c); }
        -: 1451:#else
        -: 1452:#define FUNC(F, P) static int F(c) int c; { return P(c); }
        -: 1453:#endif
        -: 1454:
    #####: 1455:FUNC(is_alpha, ISALPHA)
    #####: 1456:FUNC(is_upper, ISUPPER)
    #####: 1457:FUNC(is_lower, ISLOWER)
    #####: 1458:FUNC(is_digit, ISDIGIT)
    #####: 1459:FUNC(is_xdigit, ISXDIGIT)
    #####: 1460:FUNC(is_space, ISSPACE)
    #####: 1461:FUNC(is_punct, ISPUNCT)
    #####: 1462:FUNC(is_alnum, ISALNUM)
    #####: 1463:FUNC(is_print, ISPRINT)
    #####: 1464:FUNC(is_graph, ISGRAPH)
    #####: 1465:FUNC(is_cntrl, ISCNTRL)
        -: 1466:
    #####: 1467:static int is_blank(c)
        -: 1468:int c;
        -: 1469:{
    #####: 1470:   return (c == ' ' || c == '\t');
        -: 1471:}
        -: 1472:
        -: 1473:/* The following list maps the names of the Posix named character classes
        -: 1474:   to predicate functions that determine whether a given character is in
        -: 1475:   the class.  The leading [ has already been eaten by the lexical analyzer. */
        -: 1476:static struct {
        -: 1477:  const char *name;
        -: 1478:  int (*pred) PARAMS ((int));
        -: 1479:} prednames[] = {
        -: 1480:  { ":alpha:]", is_alpha },
        -: 1481:  { ":upper:]", is_upper },
        -: 1482:  { ":lower:]", is_lower },
        -: 1483:  { ":digit:]", is_digit },
        -: 1484:  { ":xdigit:]", is_xdigit },
        -: 1485:  { ":space:]", is_space },
        -: 1486:  { ":punct:]", is_punct },
        -: 1487:  { ":alnum:]", is_alnum },
        -: 1488:  { ":print:]", is_print },
        -: 1489:  { ":graph:]", is_graph },
        -: 1490:  { ":cntrl:]", is_cntrl },
        -: 1491:  { ":blank:]", is_blank },
        -: 1492:  { 0 }
        -: 1493:};
        -: 1494:
        -: 1495:/* Return non-zero if C is a `word-constituent' byte; zero otherwise.  */
        -: 1496:#define IS_WORD_CONSTITUENT(C) (ISALNUM(C) || (C) == '_')
        -: 1497:
        -: 1498:static int
    #####: 1499:looking_at(s)
        -: 1500:     const char *s;
        -: 1501:{
        -: 1502:  size_t len;
        -: 1503:
    #####: 1504:  len = strlen(s);
    #####: 1505:  if (lexleft < len)
    #####: 1506:    return 0;
    #####: 1507:  return strncmp(s, lexptr, len) == 0;
        -: 1508:}
        -: 1509:
        -: 1510:static token
        3: 1511:lex()
        -: 1512:{
        -: 1513:  token c, c1, c2;
        3: 1514:  int backslash = 0, invert;
        -: 1515:  charclass ccl;
        -: 1516:  int i;
        -: 1517:
        -: 1518:  /* Basic plan: We fetch a character.  If it's a backslash,
        -: 1519:     we set the backslash flag and go through the loop again.
        -: 1520:     On the plus side, this avoids having a duplicate of the
        -: 1521:     main switch inside the backslash case.  On the minus side,
        -: 1522:     it means that just about every case begins with
        -: 1523:     "if (backslash) ...".  */
        4: 1524:  for (i = 0; i < 2; ++i)
        -: 1525:    {
        4: 1526:      FETCH(c, 0);
        3: 1527:      switch (c)
        -: 1528:	{
        1: 1529:	case '\\':
        1: 1530:	  if (backslash)
    #####: 1531:	    goto normal_char;
        1: 1532:	  if (lexleft == 0)
    #####: 1533:	    dfaerror(_("Unfinished \\ escape"));
        1: 1534:	  backslash = 1;
        1: 1535:	  break;
        -: 1536:
    #####: 1537:	case '^':
    #####: 1538:	  if (backslash)
    #####: 1539:	    goto normal_char;
    #####: 1540:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
    #####: 1541:	      || lasttok == END
    #####: 1542:	      || lasttok == LPAREN
    #####: 1543:	      || lasttok == OR)
    #####: 1544:	    return lasttok = BEGLINE;
    #####: 1545:	  goto normal_char;
        -: 1546:
    #####: 1547:	case '$':
    #####: 1548:	  if (backslash)
    #####: 1549:	    goto normal_char;
    #####: 1550:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
    #####: 1551:	      || lexleft == 0
    #####: 1552:	      || (syntax_bits & RE_NO_BK_PARENS
    #####: 1553:		  ? lexleft > 0 && *lexptr == ')'
    #####: 1554:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
    #####: 1555:	      || (syntax_bits & RE_NO_BK_VBAR
    #####: 1556:		  ? lexleft > 0 && *lexptr == '|'
    #####: 1557:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
    #####: 1558:	      || ((syntax_bits & RE_NEWLINE_ALT)
    #####: 1559:	          && lexleft > 0 && *lexptr == '\n'))
    #####: 1560:	    return lasttok = ENDLINE;
    #####: 1561:	  goto normal_char;
        -: 1562:
        1: 1563:	case '1':
        -: 1564:	case '2':
        -: 1565:	case '3':
        -: 1566:	case '4':
        -: 1567:	case '5':
        -: 1568:	case '6':
        -: 1569:	case '7':
        -: 1570:	case '8':
        -: 1571:	case '9':
       1*: 1572:	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
        -: 1573:	    {
    #####: 1574:	      laststart = 0;
    #####: 1575:	      return lasttok = BACKREF;
        -: 1576:	    }
        1: 1577:	  goto normal_char;
        -: 1578:
    #####: 1579:	case '`':
    #####: 1580:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
    #####: 1581:	    return lasttok = BEGLINE;	/* FIXME: should be beginning of string */
    #####: 1582:	  goto normal_char;
        -: 1583:
    #####: 1584:	case '\'':
    #####: 1585:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
    #####: 1586:	    return lasttok = ENDLINE;	/* FIXME: should be end of string */
    #####: 1587:	  goto normal_char;
        -: 1588:
    #####: 1589:	case '<':
    #####: 1590:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
    #####: 1591:	    return lasttok = BEGWORD;
    #####: 1592:	  goto normal_char;
        -: 1593:
    #####: 1594:	case '>':
    #####: 1595:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
    #####: 1596:	    return lasttok = ENDWORD;
    #####: 1597:	  goto normal_char;
        -: 1598:
    #####: 1599:	case 'b':
    #####: 1600:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
    #####: 1601:	    return lasttok = LIMWORD;
    #####: 1602:	  goto normal_char;
        -: 1603:
    #####: 1604:	case 'B':
    #####: 1605:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
    #####: 1606:	    return lasttok = NOTLIMWORD;
    #####: 1607:	  goto normal_char;
        -: 1608:
    #####: 1609:	case '?':
    #####: 1610:	  if (syntax_bits & RE_LIMITED_OPS)
    #####: 1611:	    goto normal_char;
    #####: 1612:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
    #####: 1613:	    goto normal_char;
    #####: 1614:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
    #####: 1615:	    goto normal_char;
    #####: 1616:	  return lasttok = QMARK;
        -: 1617:
    #####: 1618:	case '*':
    #####: 1619:	  if (backslash)
    #####: 1620:	    goto normal_char;
    #####: 1621:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
    #####: 1622:	    goto normal_char;
    #####: 1623:	  return lasttok = STAR;
        -: 1624:
        1: 1625:	case '+':
        1: 1626:	  if (syntax_bits & RE_LIMITED_OPS)
    #####: 1627:	    goto normal_char;
        1: 1628:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
    #####: 1629:	    goto normal_char;
        1: 1630:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
    #####: 1631:	    goto normal_char;
        1: 1632:	  return lasttok = PLUS;
        -: 1633:
    #####: 1634:	case '{':
    #####: 1635:	  if (!(syntax_bits & RE_INTERVALS))
    #####: 1636:	    goto normal_char;
    #####: 1637:	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
    #####: 1638:	    goto normal_char;
    #####: 1639:	  minrep = maxrep = 0;
        -: 1640:	  /* Cases:
        -: 1641:	     {M} - exact count
        -: 1642:	     {M,} - minimum count, maximum is infinity
        -: 1643:	     {,M} - 0 through M
        -: 1644:	     {M,N} - M through N */
    #####: 1645:	  FETCH(c, _("unfinished repeat count"));
    #####: 1646:	  if (ISDIGIT(c))
        -: 1647:	    {
    #####: 1648:	      minrep = c - '0';
        -: 1649:	      for (;;)
        -: 1650:		{
    #####: 1651:		  FETCH(c, _("unfinished repeat count"));
    #####: 1652:		  if (!ISDIGIT(c))
    #####: 1653:		    break;
    #####: 1654:		  minrep = 10 * minrep + c - '0';
        -: 1655:		}
        -: 1656:	    }
    #####: 1657:	  else if (c != ',')
    #####: 1658:	    dfaerror(_("malformed repeat count"));
    #####: 1659:	  if (c == ',')
        -: 1660:	    for (;;)
        -: 1661:	      {
    #####: 1662:		FETCH(c, _("unfinished repeat count"));
    #####: 1663:		if (!ISDIGIT(c))
    #####: 1664:		  break;
    #####: 1665:		maxrep = 10 * maxrep + c - '0';
        -: 1666:	      }
        -: 1667:	  else
    #####: 1668:	    maxrep = minrep;
    #####: 1669:	  if (!(syntax_bits & RE_NO_BK_BRACES))
        -: 1670:	    {
    #####: 1671:	      if (c != '\\')
    #####: 1672:		dfaerror(_("malformed repeat count"));
    #####: 1673:	      FETCH(c, _("unfinished repeat count"));
        -: 1674:	    }
    #####: 1675:	  if (c != '}')
    #####: 1676:	    dfaerror(_("malformed repeat count"));
    #####: 1677:	  laststart = 0;
    #####: 1678:	  return lasttok = REPMN;
        -: 1679:
    #####: 1680:	case '|':
    #####: 1681:	  if (syntax_bits & RE_LIMITED_OPS)
    #####: 1682:	    goto normal_char;
    #####: 1683:	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
    #####: 1684:	    goto normal_char;
    #####: 1685:	  laststart = 1;
    #####: 1686:	  return lasttok = OR;
        -: 1687:
    #####: 1688:	case '\n':
    #####: 1689:	  if (syntax_bits & RE_LIMITED_OPS
    #####: 1690:	      || backslash
    #####: 1691:	      || !(syntax_bits & RE_NEWLINE_ALT))
    #####: 1692:	    goto normal_char;
    #####: 1693:	  laststart = 1;
    #####: 1694:	  return lasttok = OR;
        -: 1695:
    #####: 1696:	case '(':
    #####: 1697:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
    #####: 1698:	    goto normal_char;
    #####: 1699:	  ++parens;
    #####: 1700:	  laststart = 1;
    #####: 1701:	  return lasttok = LPAREN;
        -: 1702:
    #####: 1703:	case ')':
    #####: 1704:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
    #####: 1705:	    goto normal_char;
    #####: 1706:	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
    #####: 1707:	    goto normal_char;
    #####: 1708:	  --parens;
    #####: 1709:	  laststart = 0;
    #####: 1710:	  return lasttok = RPAREN;
        -: 1711:
    #####: 1712:	case '.':
    #####: 1713:	  if (backslash)
    #####: 1714:	    goto normal_char;
    #####: 1715:	  zeroset(ccl);
    #####: 1716:	  notset(ccl);
    #####: 1717:	  if (!(syntax_bits & RE_DOT_NEWLINE))
    #####: 1718:	    clrbit('\n', ccl);
    #####: 1719:	  if (syntax_bits & RE_DOT_NOT_NULL)
    #####: 1720:	    clrbit('\0', ccl);
    #####: 1721:	  laststart = 0;
    #####: 1722:	  return lasttok = CSET + charclass_index(ccl);
        -: 1723:
    #####: 1724:	case 'w':
        -: 1725:	case 'W':
    #####: 1726:	  if (!backslash || (syntax_bits & RE_NO_GNU_OPS))
    #####: 1727:	    goto normal_char;
    #####: 1728:	  zeroset(ccl);
    #####: 1729:	  for (c2 = 0; c2 < NOTCHAR; ++c2)
    #####: 1730:	    if (IS_WORD_CONSTITUENT(c2))
    #####: 1731:	      setbit(c2, ccl);
    #####: 1732:	  if (c == 'W')
    #####: 1733:	    notset(ccl);
    #####: 1734:	  laststart = 0;
    #####: 1735:	  return lasttok = CSET + charclass_index(ccl);
        -: 1736:
    #####: 1737:	case '[':
    #####: 1738:	  if (backslash)
    #####: 1739:	    goto normal_char;
    #####: 1740:	  zeroset(ccl);
    #####: 1741:	  FETCH(c, _("Unbalanced ["));
    #####: 1742:	  if (c == '^')
        -: 1743:	    {
    #####: 1744:	      FETCH(c, _("Unbalanced ["));
    #####: 1745:	      invert = 1;
        -: 1746:	    }
        -: 1747:	  else
    #####: 1748:	    invert = 0;
        -: 1749:	  do
        -: 1750:	    {
        -: 1751:	      /* Nobody ever said this had to be fast. :-)
        -: 1752:		 Note that if we're looking at some other [:...:]
        -: 1753:		 construct, we just treat it as a bunch of ordinary
        -: 1754:		 characters.  We can do this because we assume
        -: 1755:		 regex has checked for syntax errors before
        -: 1756:		 dfa is ever called. */
    #####: 1757:	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
    #####: 1758:		for (c1 = 0; prednames[c1].name; ++c1)
    #####: 1759:		  if (looking_at(prednames[c1].name))
        -: 1760:		    {
    #####: 1761:			int (*pred)() = prednames[c1].pred;
        -: 1762:			#ifndef FAULTY_F_DG_9
    #####: 1763:			if (case_fold
    #####: 1764:			    && (pred == is_upper || pred == is_lower))
    #####: 1765:				pred = is_alpha;
        -: 1766:			#else
        -: 1767:			if (pred == is_upper || pred == is_lower)
        -: 1768:				pred = is_alpha;
        -: 1769:			#endif
        -: 1770:
    #####: 1771:		      for (c2 = 0; c2 < NOTCHAR; ++c2)
    #####: 1772:			if ((*pred)(c2))
    #####: 1773:			  setbit(c2, ccl);
    #####: 1774:		      lexptr += strlen(prednames[c1].name);
    #####: 1775:		      lexleft -= strlen(prednames[c1].name);
    #####: 1776:		      FETCH(c1, _("Unbalanced ["));
    #####: 1777:		      goto skip;
        -: 1778:		    }
    #####: 1779:	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
    #####: 1780:		FETCH(c, _("Unbalanced ["));
    #####: 1781:	      FETCH(c1, _("Unbalanced ["));
    #####: 1782:	      if (c1 == '-')
        -: 1783:		{
    #####: 1784:		  FETCH(c2, _("Unbalanced ["));
    #####: 1785:		  if (c2 == ']')
        -: 1786:		    {
        -: 1787:		      /* In the case [x-], the - is an ordinary hyphen,
        -: 1788:			 which is left in c1, the lookahead character. */
    #####: 1789:		      --lexptr;
    #####: 1790:		      ++lexleft;
    #####: 1791:		      c2 = c;
        -: 1792:		    }
        -: 1793:		  else
        -: 1794:		    {
    #####: 1795:		      if (c2 == '\\'
    #####: 1796:			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
    #####: 1797:			FETCH(c2, _("Unbalanced ["));
    #####: 1798:		      FETCH(c1, _("Unbalanced ["));
        -: 1799:		    }
        -: 1800:		}
        -: 1801:	      else
    #####: 1802:		c2 = c;
    #####: 1803:	      while (c <= c2)
        -: 1804:		{
    #####: 1805:		  setbit(c, ccl);
    #####: 1806:		  if (case_fold)
    #####: 1807:		    if (ISUPPER(c))
    #####: 1808:		      setbit(tolower(c), ccl);
    #####: 1809:		    else if (ISLOWER(c))
    #####: 1810:		      setbit(toupper(c), ccl);
    #####: 1811:		  ++c;
        -: 1812:		}
    #####: 1813:	    skip:
        -: 1814:	      ;
        -: 1815:	    }
    #####: 1816:	  while ((c = c1) != ']');
    #####: 1817:	  if (invert)
        -: 1818:	    {
    #####: 1819:	      notset(ccl);
    #####: 1820:	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
    #####: 1821:		clrbit('\n', ccl);
        -: 1822:	    }
    #####: 1823:	  laststart = 0;
    #####: 1824:	  return lasttok = CSET + charclass_index(ccl);
        -: 1825:
        -: 1826:	default:
        1: 1827:	normal_char:
        1: 1828:	  laststart = 0;
       1*: 1829:	  if (case_fold && ISALPHA(c))
        -: 1830:	    {
    #####: 1831:	      zeroset(ccl);
    #####: 1832:	      setbit(c, ccl);
    #####: 1833:	      if (isupper(c))
    #####: 1834:		setbit(tolower(c), ccl);
        -: 1835:	      else
    #####: 1836:		setbit(toupper(c), ccl);
    #####: 1837:	      return lasttok = CSET + charclass_index(ccl);
        -: 1838:	    }
        1: 1839:	  return c;
        -: 1840:	}
        -: 1841:    }
        -: 1842:
        -: 1843:  /* The above loop should consume at most a backslash
        -: 1844:     and some other character. */
    #####: 1845:  abort();
        -: 1846:  return END;	/* keeps pedantic compilers happy. */
        -: 1847:}
        -: 1848:
        -: 1849:/* Recursive descent parser for regular expressions. */
        -: 1850:
        -: 1851:static token tok;		/* Lookahead token. */
        -: 1852:static int depth;		/* Current depth of a hypothetical stack
        -: 1853:				   holding deferred productions.  This is
        -: 1854:				   used to determine the depth that will be
        -: 1855:				   required of the real stack later on in
        -: 1856:				   dfaanalyze(). */
        -: 1857:
        -: 1858:/* Add the given token to the parse tree, maintaining the depth count and
        -: 1859:   updating the maximum depth if necessary. */
        -: 1860:static void
        4: 1861:addtok(t)
        -: 1862:     token t;
        -: 1863:{
        6: 1864:  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
        4: 1865:  dfa->tokens[dfa->tindex++] = t;
        -: 1866:
        4: 1867:  switch (t)
        -: 1868:    {
        1: 1869:    case QMARK:
        -: 1870:    case STAR:
        -: 1871:    case PLUS:
        1: 1872:      break;
        -: 1873:
        1: 1874:    case CAT:
        -: 1875:    case OR:
        -: 1876:    case ORTOP:
        1: 1877:      --depth;
        1: 1878:      break;
        -: 1879:
        2: 1880:    default:
        2: 1881:      ++dfa->nleaves;
        2: 1882:    case EMPTY:
        2: 1883:      ++depth;
        2: 1884:      break;
        -: 1885:    }
        4: 1886:  if (depth > dfa->depth)
        2: 1887:    dfa->depth = depth;
        4: 1888:}
        -: 1889:
        -: 1890:/* The grammar understood by the parser is as follows.
        -: 1891:
        -: 1892:   regexp:
        -: 1893:     regexp OR branch
        -: 1894:     branch
        -: 1895:
        -: 1896:   branch:
        -: 1897:     branch closure
        -: 1898:     closure
        -: 1899:
        -: 1900:   closure:
        -: 1901:     closure QMARK
        -: 1902:     closure STAR
        -: 1903:     closure PLUS
        -: 1904:     atom
        -: 1905:
        -: 1906:   atom:
        -: 1907:     <normal character>
        -: 1908:     CSET
        -: 1909:     BACKREF
        -: 1910:     BEGLINE
        -: 1911:     ENDLINE
        -: 1912:     BEGWORD
        -: 1913:     ENDWORD
        -: 1914:     LIMWORD
        -: 1915:     NOTLIMWORD
        -: 1916:     <empty>
        -: 1917:
        -: 1918:   The parser builds a parse tree in postfix form in an array of tokens. */
        -: 1919:
        -: 1920:static void
        1: 1921:atom()
        -: 1922:{
       1*: 1923:  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
    #####: 1924:      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
    #####: 1925:      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
        -: 1926:    {
        1: 1927:      addtok(tok);
        1: 1928:      tok = lex();
        -: 1929:    }
    #####: 1930:  else if (tok == LPAREN)
        -: 1931:    {
    #####: 1932:      tok = lex();
    #####: 1933:      regexp(0);
    #####: 1934:      if (tok != RPAREN)
    #####: 1935:	dfaerror(_("Unbalanced ("));
    #####: 1936:      tok = lex();
        -: 1937:    }
        -: 1938:  else
    #####: 1939:    addtok(EMPTY);
        1: 1940:}
        -: 1941:
        -: 1942:/* Return the number of tokens in the given subexpression. */
        -: 1943:static int
    #####: 1944:nsubtoks(tindex)
        -: 1945:int tindex;
        -: 1946:{
        -: 1947:  int ntoks1;
        -: 1948:
    #####: 1949:  switch (dfa->tokens[tindex - 1])
        -: 1950:    {
    #####: 1951:    default:
    #####: 1952:      return 1;
    #####: 1953:    case QMARK:
        -: 1954:    case STAR:
        -: 1955:    case PLUS:
    #####: 1956:      return 1 + nsubtoks(tindex - 1);
    #####: 1957:    case CAT:
        -: 1958:    case OR:
        -: 1959:    case ORTOP:
    #####: 1960:      ntoks1 = nsubtoks(tindex - 1);
    #####: 1961:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
        -: 1962:    }
        -: 1963:}
        -: 1964:
        -: 1965:/* Copy the given subexpression to the top of the tree. */
        -: 1966:static void
    #####: 1967:copytoks(tindex, ntokens)
        -: 1968:     int tindex, ntokens;
        -: 1969:{
        -: 1970:  int i;
        -: 1971:
    #####: 1972:  for (i = 0; i < ntokens; ++i)
    #####: 1973:    addtok(dfa->tokens[tindex + i]);
    #####: 1974:}
        -: 1975:
        -: 1976:static void
        1: 1977:closure()
        -: 1978:{
        -: 1979:  int tindex, ntokens, i;
        -: 1980:
        1: 1981:  atom();
        2: 1982:  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
        1: 1983:    if (tok == REPMN)
        -: 1984:      {
    #####: 1985:	ntokens = nsubtoks(dfa->tindex);
    #####: 1986:	tindex = dfa->tindex - ntokens;
    #####: 1987:	if (maxrep == 0)
    #####: 1988:	  addtok(PLUS);
    #####: 1989:	if (minrep == 0)
    #####: 1990:	  addtok(QMARK);
    #####: 1991:	for (i = 1; i < minrep; ++i)
        -: 1992:	  {
    #####: 1993:	    copytoks(tindex, ntokens);
    #####: 1994:	    addtok(CAT);
        -: 1995:	  }
    #####: 1996:	for (; i < maxrep; ++i)
        -: 1997:	  {
    #####: 1998:	    copytoks(tindex, ntokens);
    #####: 1999:	    addtok(QMARK);
    #####: 2000:	    addtok(CAT);
        -: 2001:	  }
    #####: 2002:	tok = lex();
        -: 2003:      }
        -: 2004:    else
        -: 2005:      {
        1: 2006:	addtok(tok);
        1: 2007:	tok = lex();
        -: 2008:      }
        1: 2009:}
        -: 2010:
        -: 2011:static void
        1: 2012:branch()
        -: 2013:{
        1: 2014:  closure();
        1: 2015:  while (tok != RPAREN && tok != OR && tok >= 0)
        -: 2016:    {
    #####: 2017:      closure();
    #####: 2018:      addtok(CAT);
        -: 2019:    }
        1: 2020:}
        -: 2021:
        -: 2022:static void
        1: 2023:regexp(toplevel)
        -: 2024:     int toplevel;
        -: 2025:{
        1: 2026:  branch();
        1: 2027:  while (tok == OR)
        -: 2028:    {
    #####: 2029:      tok = lex();
    #####: 2030:      branch();
    #####: 2031:      if (toplevel)
    #####: 2032:	addtok(ORTOP);
        -: 2033:      else
    #####: 2034:	addtok(OR);
        -: 2035:    }
        1: 2036:}
        -: 2037:
        -: 2038:/* Main entry point for the parser.  S is a string to be parsed, len is the
        -: 2039:   length of the string, so s can include NUL characters.  D is a pointer to
        -: 2040:   the struct dfa to parse into. */
        -: 2041:void
        1: 2042:dfaparse(s, len, d)
        -: 2043:     char *s;
        -: 2044:     size_t len;
        -: 2045:     struct dfa *d;
        -: 2046:
        -: 2047:{
        1: 2048:  dfa = d;
        1: 2049:  lexstart = lexptr = s;
        1: 2050:  lexleft = len;
        1: 2051:  lasttok = END;
        1: 2052:  laststart = 1;
        1: 2053:  parens = 0;
        -: 2054:
        1: 2055:  if (! syntax_bits_set)
    #####: 2056:    dfaerror(_("No syntax specified"));
        -: 2057:
        1: 2058:  tok = lex();
        1: 2059:  depth = d->depth;
        -: 2060:
        1: 2061:  regexp(1);
        -: 2062:
        1: 2063:  if (tok != END)
    #####: 2064:    dfaerror(_("Unbalanced )"));
        -: 2065:
        1: 2066:  addtok(END - d->nregexps);
        1: 2067:  addtok(CAT);
        -: 2068:
        1: 2069:  if (d->nregexps)
    #####: 2070:    addtok(ORTOP);
        -: 2071:
        1: 2072:  ++d->nregexps;
        1: 2073:}
        -: 2074:
        -: 2075:/* Some primitives for operating on sets of positions. */
        -: 2076:
        -: 2077:/* Copy one set to another; the destination must be large enough. */
        -: 2078:static void
       10: 2079:copy(src, dst)
        -: 2080:     position_set *src;
        -: 2081:     position_set *dst;
        -: 2082:{
        -: 2083:  int i;
        -: 2084:
       22: 2085:  for (i = 0; i < src->nelem; ++i)
       12: 2086:    dst->elems[i] = src->elems[i];
       10: 2087:  dst->nelem = src->nelem;
       10: 2088:}
        -: 2089:
        -: 2090:/* Insert a position in a set.  Position sets are maintained in sorted
        -: 2091:   order according to index.  If position already exists in the set with
        -: 2092:   the same index then their constraints are logically or'd together.
        -: 2093:   S->elems must point to an array large enough to hold the resulting set. */
        -: 2094:static void
        7: 2095:insert(p, s)
        -: 2096:     position p;
        -: 2097:     position_set *s;
        4: 2098:{
        -: 2099:  int i;
        -: 2100:  position t1, t2;
        -: 2101:
       11: 2102:  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
        -: 2103:#ifndef FAULTY_F_KP_5
        4: 2104:    continue;
        -: 2105:#else
        -: 2106:	break;
        -: 2107:#endif
        7: 2108:  if (i < s->nelem && p.index == s->elems[i].index)
        2: 2109:    s->elems[i].constraint |= p.constraint;
        -: 2110:  else
        -: 2111:    {
        5: 2112:      t1 = p;
        5: 2113:      ++s->nelem;
       10: 2114:      while (i < s->nelem)
        -: 2115:	{
        5: 2116:	  t2 = s->elems[i];
        5: 2117:	  s->elems[i++] = t1;
        5: 2118:	  t1 = t2;
        -: 2119:	}
        -: 2120:    }
        7: 2121:}
        -: 2122:
        -: 2123:/* Merge two sets of positions into a third.  The result is exactly as if
        -: 2124:   the positions of both sets were inserted into an initially empty set. */
        -: 2125:static void
        2: 2126:merge(s1, s2, m)
        -: 2127:     position_set *s1;
        -: 2128:     position_set *s2;
        -: 2129:     position_set *m;
        -: 2130:{
        2: 2131:  int i = 0, j = 0;
        -: 2132:
        2: 2133:  m->nelem = 0;
        3: 2134:  while (i < s1->nelem && j < s2->nelem)
        1: 2135:    if (s1->elems[i].index > s2->elems[j].index)
        1: 2136:      m->elems[m->nelem++] = s1->elems[i++];
    #####: 2137:    else if (s1->elems[i].index < s2->elems[j].index)
    #####: 2138:      m->elems[m->nelem++] = s2->elems[j++];
        -: 2139:    else
        -: 2140:      {
    #####: 2141:	m->elems[m->nelem] = s1->elems[i++];
    #####: 2142:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
        -: 2143:      }
        3: 2144:  while (i < s1->nelem)
        1: 2145:    m->elems[m->nelem++] = s1->elems[i++];
        3: 2146:  while (j < s2->nelem)
        1: 2147:    m->elems[m->nelem++] = s2->elems[j++];
        2: 2148:}
        -: 2149:
        -: 2150:/* Delete a position from a set. */
        -: 2151:static void
    #####: 2152:delete(p, s)
        -: 2153:     position p;
        -: 2154:     position_set *s;
        -: 2155:{
        -: 2156:  int i;
        -: 2157:
    #####: 2158:  for (i = 0; i < s->nelem; ++i)
    #####: 2159:    if (p.index == s->elems[i].index)
    #####: 2160:      break;
    #####: 2161:  if (i < s->nelem)
    #####: 2162:    for (--s->nelem; i < s->nelem; ++i)
    #####: 2163:      s->elems[i] = s->elems[i + 1];
    #####: 2164:}
        -: 2165:
        -: 2166:/* Find the index of the state corresponding to the given position set with
        -: 2167:   the given preceding context, or create a new state if there is no such
        -: 2168:   state.  Newline and letter tell whether we got here on a newline or
        -: 2169:   letter, respectively. */
        -: 2170:static int
        5: 2171:state_index(d, s, newline, letter)
        -: 2172:     struct dfa *d;
        -: 2173:     position_set *s;
        -: 2174:     int newline;
        -: 2175:     int letter;
        -: 2176:{
        5: 2177:  int hash = 0;
        -: 2178:  int constraint;
        -: 2179:  int i, j;
        -: 2180:
        5: 2181:  newline = newline ? 1 : 0;
        5: 2182:  letter = letter ? 1 : 0;
        -: 2183:
       12: 2184:  for (i = 0; i < s->nelem; ++i)
        7: 2185:    hash ^= s->elems[i].index + s->elems[i].constraint;
        -: 2186:
        -: 2187:  /* Try to find a state that exactly matches the proposed one. */
        7: 2188:  for (i = 0; i < d->sindex; ++i)
        -: 2189:    {
        5: 2190:      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
        3: 2191:	  || newline != d->states[i].newline || letter != d->states[i].letter)
        2: 2192:	continue;
        7: 2193:      for (j = 0; j < s->nelem; ++j)
        4: 2194:	if (s->elems[j].constraint
        4: 2195:	    != d->states[i].elems.elems[j].constraint
        4: 2196:	    || s->elems[j].index != d->states[i].elems.elems[j].index)
        -: 2197:	  break;
        3: 2198:      if (j == s->nelem)
        3: 2199:	return i;
        -: 2200:    }
        -: 2201:
        -: 2202:  /* We'll have to create a new state. */
        3: 2203:  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
        2: 2204:  d->states[i].hash = hash;
        2: 2205:  MALLOC(d->states[i].elems.elems, position, s->nelem);
        2: 2206:  copy(s, &d->states[i].elems);
        2: 2207:  d->states[i].newline = newline;
        2: 2208:  d->states[i].letter = letter;
        2: 2209:  d->states[i].backref = 0;
        2: 2210:  d->states[i].constraint = 0;
        2: 2211:  d->states[i].first_end = 0;
        5: 2212:  for (j = 0; j < s->nelem; ++j)
        3: 2213:    if (d->tokens[s->elems[j].index] < 0)
        -: 2214:      {
        1: 2215:	constraint = s->elems[j].constraint;
       1*: 2216:	if (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)
    #####: 2217:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
    #####: 2218:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
    #####: 2219:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
        1: 2220:	  d->states[i].constraint |= constraint;
        1: 2221:	if (! d->states[i].first_end)
        1: 2222:	  d->states[i].first_end = d->tokens[s->elems[j].index];
        -: 2223:      }
        2: 2224:    else if (d->tokens[s->elems[j].index] == BACKREF)
        -: 2225:      {
    #####: 2226:	d->states[i].constraint = NO_CONSTRAINT;
    #####: 2227:	d->states[i].backref = 1;
        -: 2228:      }
        -: 2229:
        2: 2230:  ++d->sindex;
        -: 2231:
        2: 2232:  return i;
        -: 2233:}
        -: 2234:
        -: 2235:/* Find the epsilon closure of a set of positions.  If any position of the set
        -: 2236:   contains a symbol that matches the empty string in some context, replace
        -: 2237:   that position with the elements of its follow labeled with an appropriate
        -: 2238:   constraint.  Repeat exhaustively until no funny positions are left.
        -: 2239:   S->elems must be large enough to hold the result. */
        -: 2240:static void epsclosure PARAMS ((position_set *s, struct dfa *d));
        -: 2241:
        -: 2242:static void
        3: 2243:epsclosure(s, d)
        -: 2244:     position_set *s;
        -: 2245:     struct dfa *d;
        -: 2246:{
        -: 2247:  int i, j;
        -: 2248:  int *visited;
        -: 2249:  position p, old;
        -: 2250:
        3: 2251:  MALLOC(visited, int, d->tindex);
       15: 2252:  for (i = 0; i < d->tindex; ++i)
       12: 2253:    visited[i] = 0;
        -: 2254:
        6: 2255:  for (i = 0; i < s->nelem; ++i)
        3: 2256:    if (d->tokens[s->elems[i].index] >= NOTCHAR
    #####: 2257:	&& d->tokens[s->elems[i].index] != BACKREF
    #####: 2258:	&& d->tokens[s->elems[i].index] < CSET)
        -: 2259:      {
    #####: 2260:	old = s->elems[i];
    #####: 2261:	p.constraint = old.constraint;
    #####: 2262:	delete(s->elems[i], s);
    #####: 2263:	if (visited[old.index])
        -: 2264:	  {
    #####: 2265:	    --i;
    #####: 2266:	    continue;
        -: 2267:	  }
    #####: 2268:	visited[old.index] = 1;
    #####: 2269:	switch (d->tokens[old.index])
        -: 2270:	  {
    #####: 2271:	  case BEGLINE:
    #####: 2272:	    p.constraint &= BEGLINE_CONSTRAINT;
    #####: 2273:	    break;
    #####: 2274:	  case ENDLINE:
    #####: 2275:	    p.constraint &= ENDLINE_CONSTRAINT;
    #####: 2276:	    break;
    #####: 2277:	  case BEGWORD:
    #####: 2278:	    p.constraint &= BEGWORD_CONSTRAINT;
    #####: 2279:	    break;
    #####: 2280:	  case ENDWORD:
    #####: 2281:	    p.constraint &= ENDWORD_CONSTRAINT;
    #####: 2282:	    break;
    #####: 2283:	  case LIMWORD:
    #####: 2284:	    p.constraint &= LIMWORD_CONSTRAINT;
    #####: 2285:	    break;
    #####: 2286:	  case NOTLIMWORD:
    #####: 2287:	    p.constraint &= NOTLIMWORD_CONSTRAINT;
    #####: 2288:	    break;
    #####: 2289:	  default:
    #####: 2290:	    break;
        -: 2291:	  }
    #####: 2292:	for (j = 0; j < d->follows[old.index].nelem; ++j)
        -: 2293:	  {
    #####: 2294:	    p.index = d->follows[old.index].elems[j].index;
    #####: 2295:	    insert(p, s);
        -: 2296:	  }
        -: 2297:	/* Force rescan to start at the beginning. */
    #####: 2298:	i = -1;
        -: 2299:      }
        -: 2300:
        3: 2301:  free(visited);
        3: 2302:}
        -: 2303:
        -: 2304:/* Perform bottom-up analysis on the parse tree, computing various functions.
        -: 2305:   Note that at this point, we're pretending constructs like \< are real
        -: 2306:   characters rather than constraints on what can follow them.
        -: 2307:
        -: 2308:   Nullable:  A node is nullable if it is at the root of a regexp that can
        -: 2309:   match the empty string.
        -: 2310:   *  EMPTY leaves are nullable.
        -: 2311:   * No other leaf is nullable.
        -: 2312:   * A QMARK or STAR node is nullable.
        -: 2313:   * A PLUS node is nullable if its argument is nullable.
        -: 2314:   * A CAT node is nullable if both its arguments are nullable.
        -: 2315:   * An OR node is nullable if either argument is nullable.
        -: 2316:
        -: 2317:   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
        -: 2318:   that could correspond to the first character of a string matching the
        -: 2319:   regexp rooted at the given node.
        -: 2320:   * EMPTY leaves have empty firstpos.
        -: 2321:   * The firstpos of a nonempty leaf is that leaf itself.
        -: 2322:   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
        -: 2323:     argument.
        -: 2324:   * The firstpos of a CAT node is the firstpos of the left argument, union
        -: 2325:     the firstpos of the right if the left argument is nullable.
        -: 2326:   * The firstpos of an OR node is the union of firstpos of each argument.
        -: 2327:
        -: 2328:   Lastpos:  The lastpos of a node is the set of positions that could
        -: 2329:   correspond to the last character of a string matching the regexp at
        -: 2330:   the given node.
        -: 2331:   * EMPTY leaves have empty lastpos.
        -: 2332:   * The lastpos of a nonempty leaf is that leaf itself.
        -: 2333:   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
        -: 2334:     argument.
        -: 2335:   * The lastpos of a CAT node is the lastpos of its right argument, union
        -: 2336:     the lastpos of the left if the right argument is nullable.
        -: 2337:   * The lastpos of an OR node is the union of the lastpos of each argument.
        -: 2338:
        -: 2339:   Follow:  The follow of a position is the set of positions that could
        -: 2340:   correspond to the character following a character matching the node in
        -: 2341:   a string matching the regexp.  At this point we consider special symbols
        -: 2342:   that match the empty string in some context to be just normal characters.
        -: 2343:   Later, if we find that a special symbol is in a follow set, we will
        -: 2344:   replace it with the elements of its follow, labeled with an appropriate
        -: 2345:   constraint.
        -: 2346:   * Every node in the firstpos of the argument of a STAR or PLUS node is in
        -: 2347:     the follow of every node in the lastpos.
        -: 2348:   * Every node in the firstpos of the second argument of a CAT node is in
        -: 2349:     the follow of every node in the lastpos of the first argument.
        -: 2350:
        -: 2351:   Because of the postfix representation of the parse tree, the depth-first
        -: 2352:   analysis is conveniently done by a linear scan with the aid of a stack.
        -: 2353:   Sets are stored as arrays of the elements, obeying a stack-like allocation
        -: 2354:   scheme; the number of elements in each set deeper in the stack can be
        -: 2355:   used to determine the address of a particular set's array. */
        -: 2356:void
        1: 2357:dfaanalyze(d, searchflag)
        -: 2358:     struct dfa *d;
        -: 2359:     int searchflag;
        -: 2360:{
        -: 2361:  int *nullable;		/* Nullable stack. */
        -: 2362:  int *nfirstpos;		/* Element count stack for firstpos sets. */
        -: 2363:  position *firstpos;		/* Array where firstpos elements are stored. */
        -: 2364:  int *nlastpos;		/* Element count stack for lastpos sets. */
        -: 2365:  position *lastpos;		/* Array where lastpos elements are stored. */
        -: 2366:  int *nalloc;			/* Sizes of arrays allocated to follow sets. */
        -: 2367:  position_set tmp;		/* Temporary set for merging sets. */
        -: 2368:  position_set merged;		/* Result of merging sets. */
        -: 2369:  int wants_newline;		/* True if some position wants newline info. */
        -: 2370:  int *o_nullable;
        -: 2371:  int *o_nfirst, *o_nlast;
        -: 2372:  position *o_firstpos, *o_lastpos;
        -: 2373:  int i, j;
        -: 2374:  position *pos;
        -: 2375:
        -: 2376:#ifdef DEBUG
        -: 2377:  fprintf(stderr, "dfaanalyze:\n");
        -: 2378:  for (i = 0; i < d->tindex; ++i)
        -: 2379:    {
        -: 2380:      fprintf(stderr, " %d:", i);
        -: 2381:      prtok(d->tokens[i]);
        -: 2382:    }
        -: 2383:  putc('\n', stderr);
        -: 2384:#endif
        -: 2385:
        1: 2386:  d->searchflag = searchflag;
        -: 2387:
        1: 2388:  MALLOC(nullable, int, d->depth);
        1: 2389:  o_nullable = nullable;
        1: 2390:  MALLOC(nfirstpos, int, d->depth);
        1: 2391:  o_nfirst = nfirstpos;
        1: 2392:  MALLOC(firstpos, position, d->nleaves);
        1: 2393:  o_firstpos = firstpos, firstpos += d->nleaves;
        1: 2394:  MALLOC(nlastpos, int, d->depth);
        1: 2395:  o_nlast = nlastpos;
        1: 2396:  MALLOC(lastpos, position, d->nleaves);
        1: 2397:  o_lastpos = lastpos, lastpos += d->nleaves;
        1: 2398:  MALLOC(nalloc, int, d->tindex);
        5: 2399:  for (i = 0; i < d->tindex; ++i)
        4: 2400:    nalloc[i] = 0;
        1: 2401:  MALLOC(merged.elems, position, d->nleaves);
        -: 2402:
        1: 2403:  CALLOC(d->follows, position_set, d->tindex);
        -: 2404:
        5: 2405:  for (i = 0; i < d->tindex; ++i)
        -: 2406:#ifdef DEBUG
        -: 2407:    {				/* Nonsyntactic #ifdef goo... */
        -: 2408:#endif
        4: 2409:    switch (d->tokens[i])
        -: 2410:      {
    #####: 2411:      case EMPTY:
        -: 2412:	/* The empty set is nullable. */
    #####: 2413:	*nullable++ = 1;
        -: 2414:
        -: 2415:	/* The firstpos and lastpos of the empty leaf are both empty. */
    #####: 2416:	*nfirstpos++ = *nlastpos++ = 0;
    #####: 2417:	break;
        -: 2418:
        1: 2419:      case STAR:
        -: 2420:      case PLUS:
        -: 2421:	/* Every element in the firstpos of the argument is in the follow
        -: 2422:	   of every element in the lastpos. */
        1: 2423:	tmp.nelem = nfirstpos[-1];
        1: 2424:	tmp.elems = firstpos;
        1: 2425:	pos = lastpos;
        2: 2426:	for (j = 0; j < nlastpos[-1]; ++j)
        -: 2427:	  {
        1: 2428:	    merge(&tmp, &d->follows[pos[j].index], &merged);
       1*: 2429:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
        -: 2430:				 nalloc[pos[j].index], merged.nelem - 1);
        1: 2431:	    copy(&merged, &d->follows[pos[j].index]);
        -: 2432:	  }
        -: 2433:
        -: 2434:      case QMARK:
        -: 2435:	/* A QMARK or STAR node is automatically nullable. */
        1: 2436:	if (d->tokens[i] != PLUS)
    #####: 2437:	  nullable[-1] = 1;
        1: 2438:	break;
        -: 2439:
        1: 2440:      case CAT:
        -: 2441:	/* Every element in the firstpos of the second argument is in the
        -: 2442:	   follow of every element in the lastpos of the first argument. */
        1: 2443:	tmp.nelem = nfirstpos[-1];
        1: 2444:	tmp.elems = firstpos;
        1: 2445:	pos = lastpos + nlastpos[-1];
        2: 2446:	for (j = 0; j < nlastpos[-2]; ++j)
        -: 2447:	  {
        1: 2448:	    merge(&tmp, &d->follows[pos[j].index], &merged);
        2: 2449:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
        -: 2450:				 nalloc[pos[j].index], merged.nelem - 1);
        1: 2451:	    copy(&merged, &d->follows[pos[j].index]);
        -: 2452:	  }
        -: 2453:
        -: 2454:	/* The firstpos of a CAT node is the firstpos of the first argument,
        -: 2455:	   union that of the second argument if the first is nullable. */
        1: 2456:	if (nullable[-2])
    #####: 2457:	  nfirstpos[-2] += nfirstpos[-1];
        -: 2458:	else
        1: 2459:	  firstpos += nfirstpos[-1];
        1: 2460:	--nfirstpos;
        -: 2461:
        -: 2462:	/* The lastpos of a CAT node is the lastpos of the second argument,
        -: 2463:	   union that of the first argument if the second is nullable. */
        1: 2464:	if (nullable[-1])
    #####: 2465:	  nlastpos[-2] += nlastpos[-1];
        -: 2466:	else
        -: 2467:	  {
        1: 2468:	    pos = lastpos + nlastpos[-2];
        2: 2469:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
        1: 2470:	      pos[j] = lastpos[j];
        1: 2471:	    lastpos += nlastpos[-2];
        1: 2472:	    nlastpos[-2] = nlastpos[-1];
        -: 2473:	  }
        1: 2474:	--nlastpos;
        -: 2475:
        -: 2476:	/* A CAT node is nullable if both arguments are nullable. */
       1*: 2477:	nullable[-2] = nullable[-1] && nullable[-2];
        1: 2478:	--nullable;
        1: 2479:	break;
        -: 2480:
    #####: 2481:      case OR:
        -: 2482:      case ORTOP:
        -: 2483:	/* The firstpos is the union of the firstpos of each argument. */
    #####: 2484:	nfirstpos[-2] += nfirstpos[-1];
    #####: 2485:	--nfirstpos;
        -: 2486:
        -: 2487:	/* The lastpos is the union of the lastpos of each argument. */
    #####: 2488:	nlastpos[-2] += nlastpos[-1];
    #####: 2489:	--nlastpos;
        -: 2490:
        -: 2491:	/* An OR node is nullable if either argument is nullable. */
    #####: 2492:	nullable[-2] = nullable[-1] || nullable[-2];
    #####: 2493:	--nullable;
    #####: 2494:	break;
        -: 2495:
        2: 2496:      default:
        -: 2497:	/* Anything else is a nonempty position.  (Note that special
        -: 2498:	   constructs like \< are treated as nonempty strings here;
        -: 2499:	   an "epsilon closure" effectively makes them nullable later.
        -: 2500:	   Backreferences have to get a real position so we can detect
        -: 2501:	   transitions on them later.  But they are nullable. */
        2: 2502:	*nullable++ = d->tokens[i] == BACKREF;
        -: 2503:
        -: 2504:	/* This position is in its own firstpos and lastpos. */
        2: 2505:	*nfirstpos++ = *nlastpos++ = 1;
        2: 2506:	--firstpos, --lastpos;
        2: 2507:	firstpos->index = lastpos->index = i;
        2: 2508:	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
        -: 2509:
        -: 2510:	/* Allocate the follow set for this position. */
        2: 2511:	nalloc[i] = 1;
        2: 2512:	MALLOC(d->follows[i].elems, position, nalloc[i]);
        2: 2513:	break;
        -: 2514:      }
        -: 2515:#ifdef DEBUG
        -: 2516:    /* ... balance the above nonsyntactic #ifdef goo... */
        -: 2517:      fprintf(stderr, "node %d:", i);
        -: 2518:      prtok(d->tokens[i]);
        -: 2519:      putc('\n', stderr);
        -: 2520:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
        -: 2521:      fprintf(stderr, " firstpos:");
        -: 2522:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
        -: 2523:	{
        -: 2524:	  fprintf(stderr, " %d:", firstpos[j].index);
        -: 2525:	  prtok(d->tokens[firstpos[j].index]);
        -: 2526:	}
        -: 2527:      fprintf(stderr, "\n lastpos:");
        -: 2528:      for (j = nlastpos[-1] - 1; j >= 0; --j)
        -: 2529:	{
        -: 2530:	  fprintf(stderr, " %d:", lastpos[j].index);
        -: 2531:	  prtok(d->tokens[lastpos[j].index]);
        -: 2532:	}
        -: 2533:      putc('\n', stderr);
        -: 2534:    }
        -: 2535:#endif
        -: 2536:
        -: 2537:  /* For each follow set that is the follow set of a real position, replace
        -: 2538:     it with its epsilon closure. */
        5: 2539:  for (i = 0; i < d->tindex; ++i)
        4: 2540:    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
        2: 2541:	|| d->tokens[i] >= CSET)
        -: 2542:      {
        -: 2543:#ifdef DEBUG
        -: 2544:	fprintf(stderr, "follows(%d:", i);
        -: 2545:	prtok(d->tokens[i]);
        -: 2546:	fprintf(stderr, "):");
        -: 2547:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
        -: 2548:	  {
        -: 2549:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
        -: 2550:	    prtok(d->tokens[d->follows[i].elems[j].index]);
        -: 2551:	  }
        -: 2552:	putc('\n', stderr);
        -: 2553:#endif
        2: 2554:	copy(&d->follows[i], &merged);
        2: 2555:	epsclosure(&merged, d);
        2: 2556:	if (d->follows[i].nelem < merged.nelem)
    #####: 2557:	  REALLOC(d->follows[i].elems, position, merged.nelem);
        2: 2558:	copy(&merged, &d->follows[i]);
        -: 2559:      }
        -: 2560:
        -: 2561:  /* Get the epsilon closure of the firstpos of the regexp.  The result will
        -: 2562:     be the set of positions of state 0. */
        1: 2563:  merged.nelem = 0;
        2: 2564:  for (i = 0; i < nfirstpos[-1]; ++i)
        1: 2565:    insert(firstpos[i], &merged);
        1: 2566:  epsclosure(&merged, d);
        -: 2567:
        -: 2568:  /* Check if any of the positions of state 0 will want newline context. */
        1: 2569:  wants_newline = 0;
        2: 2570:  for (i = 0; i < merged.nelem; ++i)
        1: 2571:    if (PREV_NEWLINE_DEPENDENT(merged.elems[i].constraint))
    #####: 2572:      wants_newline = 1;
        -: 2573:
        -: 2574:  /* Build the initial state. */
        1: 2575:  d->salloc = 1;
        1: 2576:  d->sindex = 0;
        1: 2577:  MALLOC(d->states, dfa_state, d->salloc);
        1: 2578:  state_index(d, &merged, wants_newline, 0);
        -: 2579:
        1: 2580:  free(o_nullable);
        1: 2581:  free(o_nfirst);
        1: 2582:  free(o_firstpos);
        1: 2583:  free(o_nlast);
        1: 2584:  free(o_lastpos);
        1: 2585:  free(nalloc);
        1: 2586:  free(merged.elems);
        1: 2587:}
        -: 2588:
        -: 2589:/* Find, for each character, the transition out of state s of d, and store
        -: 2590:   it in the appropriate slot of trans.
        -: 2591:
        -: 2592:   We divide the positions of s into groups (positions can appear in more
        -: 2593:   than one group).  Each group is labeled with a set of characters that
        -: 2594:   every position in the group matches (taking into account, if necessary,
        -: 2595:   preceding context information of s).  For each group, find the union
        -: 2596:   of the its elements' follows.  This set is the set of positions of the
        -: 2597:   new state.  For each character in the group's label, set the transition
        -: 2598:   on this character to be to a state corresponding to the set's positions,
        -: 2599:   and its associated backward context information, if necessary.
        -: 2600:
        -: 2601:   If we are building a searching matcher, we include the positions of state
        -: 2602:   0 in every state.
        -: 2603:
        -: 2604:   The collection of groups is constructed by building an equivalence-class
        -: 2605:   partition of the positions of s.
        -: 2606:
        -: 2607:   For each position, find the set of characters C that it matches.  Eliminate
        -: 2608:   any characters from C that fail on grounds of backward context.
        -: 2609:
        -: 2610:   Search through the groups, looking for a group whose label L has nonempty
        -: 2611:   intersection with C.  If L - C is nonempty, create a new group labeled
        -: 2612:   L - C and having the same positions as the current group, and set L to
        -: 2613:   the intersection of L and C.  Insert the position in this group, set
        -: 2614:   C = C - L, and resume scanning.
        -: 2615:
        -: 2616:   If after comparing with every group there are characters remaining in C,
        -: 2617:   create a new group labeled with the characters of C and insert this
        -: 2618:   position in that group. */
        -: 2619:void
        2: 2620:dfastate(s, d, trans)
        -: 2621:     int s;
        -: 2622:     struct dfa *d;
        -: 2623:     int trans[];
        -: 2624:{
        -: 2625:  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
        -: 2626:  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
        2: 2627:  int ngrps = 0;		/* Number of groups actually used. */
        -: 2628:  position pos;			/* Current position being considered. */
        -: 2629:  charclass matches;		/* Set of matching characters. */
        -: 2630:  int matchesf;			/* True if matches is nonempty. */
        -: 2631:  charclass intersect;		/* Intersection with some label set. */
        -: 2632:  int intersectf;		/* True if intersect is nonempty. */
        -: 2633:  charclass leftovers;		/* Stuff in the label that didn't match. */
        -: 2634:  int leftoversf;		/* True if leftovers is nonempty. */
        -: 2635:  static charclass letters;	/* Set of characters considered letters. */
        -: 2636:  static charclass newline;	/* Set of characters that aren't newline. */
        -: 2637:  position_set follows;		/* Union of the follows of some group. */
        -: 2638:  position_set tmp;		/* Temporary space for merging sets. */
        -: 2639:  int state;			/* New state. */
        -: 2640:  int wants_newline;		/* New state wants to know newline context. */
        -: 2641:  int state_newline;		/* New state on a newline transition. */
        -: 2642:  int wants_letter;		/* New state wants to know letter context. */
        -: 2643:  int state_letter;		/* New state on a letter transition. */
        -: 2644:  static int initialized;	/* Flag for static initialization. */
        -: 2645:  int i, j, k;
        -: 2646:
        -: 2647:  /* Initialize the set of letters, if necessary. */
        2: 2648:  if (! initialized)
        -: 2649:    {
        1: 2650:      initialized = 1;
      257: 2651:      for (i = 0; i < NOTCHAR; ++i)
      256: 2652:	if (IS_WORD_CONSTITUENT(i))
       63: 2653:	  setbit(i, letters);
        1: 2654:      setbit('\n', newline);
        -: 2655:    }
        -: 2656:
        2: 2657:  zeroset(matches);
        -: 2658:
        5: 2659:  for (i = 0; i < d->states[s].elems.nelem; ++i)
        -: 2660:    {
        3: 2661:      pos = d->states[s].elems.elems[i];
        3: 2662:      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
        2: 2663:	setbit(d->tokens[pos.index], matches);
        1: 2664:      else if (d->tokens[pos.index] >= CSET)
    #####: 2665:	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
        -: 2666:      else
        1: 2667:	continue;
        -: 2668:
        -: 2669:      /* Some characters may need to be eliminated from matches because
        -: 2670:	 they fail in the current context. */
       2*: 2671:      if (pos.constraint != 0xFF)
        -: 2672:	{
    #####: 2673:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
        -: 2674:					 d->states[s].newline, 1))
    #####: 2675:	    clrbit('\n', matches);
    #####: 2676:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
        -: 2677:					 d->states[s].newline, 0))
    #####: 2678:	    for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 2679:	      matches[j] &= newline[j];
    #####: 2680:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
        -: 2681:					d->states[s].letter, 1))
    #####: 2682:	    for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 2683:	      matches[j] &= ~letters[j];
    #####: 2684:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
        -: 2685:					d->states[s].letter, 0))
    #####: 2686:	    for (j = 0; j < CHARCLASS_INTS; ++j)
    #####: 2687:	      matches[j] &= letters[j];
        -: 2688:
        -: 2689:	  /* If there are no characters left, there's no point in going on. */
    #####: 2690:	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
    #####: 2691:	    continue;
    #####: 2692:	  if (j == CHARCLASS_INTS)
    #####: 2693:	    continue;
        -: 2694:	}
        -: 2695:
       2*: 2696:      for (j = 0; j < ngrps; ++j)
        -: 2697:	{
        -: 2698:	  /* If matches contains a single character only, and the current
        -: 2699:	     group's label doesn't contain that character, go on to the
        -: 2700:	     next group. */
    #####: 2701:	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
    #####: 2702:	      && !tstbit(d->tokens[pos.index], labels[j]))
    #####: 2703:	    continue;
        -: 2704:
        -: 2705:	  /* Check if this group's label has a nonempty intersection with
        -: 2706:	     matches. */
    #####: 2707:	  intersectf = 0;
    #####: 2708:	  for (k = 0; k < CHARCLASS_INTS; ++k)
    #####: 2709:	    (intersect[k] = matches[k] & labels[j][k]) ? (intersectf = 1) : 0;
    #####: 2710:	  if (! intersectf)
    #####: 2711:	    continue;
        -: 2712:
        -: 2713:	  /* It does; now find the set differences both ways. */
    #####: 2714:	  leftoversf = matchesf = 0;
    #####: 2715:	  for (k = 0; k < CHARCLASS_INTS; ++k)
        -: 2716:	    {
        -: 2717:	      /* Even an optimizing compiler can't know this for sure. */
    #####: 2718:	      int match = matches[k], label = labels[j][k];
        -: 2719:
    #####: 2720:	      (leftovers[k] = ~match & label) ? (leftoversf = 1) : 0;
    #####: 2721:	      (matches[k] = match & ~label) ? (matchesf = 1) : 0;
        -: 2722:	    }
        -: 2723:
        -: 2724:	  /* If there were leftovers, create a new group labeled with them. */
    #####: 2725:	  if (leftoversf)
        -: 2726:	    {
    #####: 2727:	      copyset(leftovers, labels[ngrps]);
    #####: 2728:	      copyset(intersect, labels[j]);
    #####: 2729:	      MALLOC(grps[ngrps].elems, position, d->nleaves);
    #####: 2730:	      copy(&grps[j], &grps[ngrps]);
    #####: 2731:	      ++ngrps;
        -: 2732:	    }
        -: 2733:
        -: 2734:	  /* Put the position in the current group.  Note that there is no
        -: 2735:	     reason to call insert() here. */
    #####: 2736:	  grps[j].elems[grps[j].nelem++] = pos;
        -: 2737:
        -: 2738:	  /* If every character matching the current position has been
        -: 2739:	     accounted for, we're done. */
    #####: 2740:	  if (! matchesf)
    #####: 2741:	    break;
        -: 2742:	}
        -: 2743:
        -: 2744:      /* If we've passed the last group, and there are still characters
        -: 2745:	 unaccounted for, then we'll have to create a new group. */
        2: 2746:      if (j == ngrps)
        -: 2747:	{
        2: 2748:	  copyset(matches, labels[ngrps]);
        2: 2749:	  zeroset(matches);
        2: 2750:	  MALLOC(grps[ngrps].elems, position, d->nleaves);
        2: 2751:	  grps[ngrps].nelem = 1;
        2: 2752:	  grps[ngrps].elems[0] = pos;
        2: 2753:	  ++ngrps;
        -: 2754:	}
        -: 2755:    }
        -: 2756:
        2: 2757:  MALLOC(follows.elems, position, d->nleaves);
        2: 2758:  MALLOC(tmp.elems, position, d->nleaves);
        -: 2759:
        -: 2760:  /* If we are a searching matcher, the default transition is to a state
        -: 2761:     containing the positions of state 0, otherwise the default transition
        -: 2762:     is to fail miserably. */
        2: 2763:  if (d->searchflag)
        -: 2764:    {
        2: 2765:      wants_newline = 0;
        2: 2766:      wants_letter = 0;
        4: 2767:      for (i = 0; i < d->states[0].elems.nelem; ++i)
        -: 2768:	{
        2: 2769:	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
    #####: 2770:	    wants_newline = 1;
        2: 2771:	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
    #####: 2772:	    wants_letter = 1;
        -: 2773:	}
        2: 2774:      copy(&d->states[0].elems, &follows);
        2: 2775:      state = state_index(d, &follows, 0, 0);
        2: 2776:      if (wants_newline)
    #####: 2777:	state_newline = state_index(d, &follows, 1, 0);
        -: 2778:      else
        2: 2779:	state_newline = state;
        2: 2780:      if (wants_letter)
    #####: 2781:	state_letter = state_index(d, &follows, 0, 1);
        -: 2782:      else
        2: 2783:	state_letter = state;
      514: 2784:      for (i = 0; i < NOTCHAR; ++i)
      512: 2785:	trans[i] = (IS_WORD_CONSTITUENT(i)) ? state_letter : state;
        2: 2786:      trans['\n'] = state_newline;
        -: 2787:    }
        -: 2788:  else
    #####: 2789:    for (i = 0; i < NOTCHAR; ++i)
    #####: 2790:      trans[i] = -1;
        -: 2791:
        4: 2792:  for (i = 0; i < ngrps; ++i)
        -: 2793:    {
        2: 2794:      follows.nelem = 0;
        -: 2795:
        -: 2796:      /* Find the union of the follows of the positions of the group.
        -: 2797:	 This is a hideously inefficient loop.  Fix it someday. */
        4: 2798:      for (j = 0; j < grps[i].nelem; ++j)
        6: 2799:	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
        4: 2800:	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
        -: 2801:
        -: 2802:      /* If we are building a searching matcher, throw in the positions
        -: 2803:	 of state 0 as well. */
        2: 2804:      if (d->searchflag)
        4: 2805:	for (j = 0; j < d->states[0].elems.nelem; ++j)
        2: 2806:	  insert(d->states[0].elems.elems[j], &follows);
        -: 2807:
        -: 2808:      /* Find out if the new state will want any context information. */
        2: 2809:      wants_newline = 0;
        2: 2810:      if (tstbit('\n', labels[i]))
    #####: 2811:	for (j = 0; j < follows.nelem; ++j)
    #####: 2812:	  if (PREV_NEWLINE_DEPENDENT(follows.elems[j].constraint))
    #####: 2813:	    wants_newline = 1;
        -: 2814:
        2: 2815:      wants_letter = 0;
        4: 2816:      for (j = 0; j < CHARCLASS_INTS; ++j)
        4: 2817:	if (labels[i][j] & letters[j])
        2: 2818:	  break;
        2: 2819:      if (j < CHARCLASS_INTS)
        6: 2820:	for (j = 0; j < follows.nelem; ++j)
        4: 2821:	  if (PREV_LETTER_DEPENDENT(follows.elems[j].constraint))
    #####: 2822:	    wants_letter = 1;
        -: 2823:
        -: 2824:      /* Find the state(s) corresponding to the union of the follows. */
        2: 2825:      state = state_index(d, &follows, 0, 0);
        2: 2826:      if (wants_newline)
    #####: 2827:	state_newline = state_index(d, &follows, 1, 0);
        -: 2828:      else
        2: 2829:	state_newline = state;
        2: 2830:      if (wants_letter)
    #####: 2831:	state_letter = state_index(d, &follows, 0, 1);
        -: 2832:      else
        2: 2833:	state_letter = state;
        -: 2834:
        -: 2835:      /* Set the transitions for each character in the current label. */
       18: 2836:      for (j = 0; j < CHARCLASS_INTS; ++j)
      528: 2837:	for (k = 0; k < INTBITS; ++k)
      512: 2838:	  if (labels[i][j] & 1 << k)
        -: 2839:	    {
        2: 2840:	      int c = j * INTBITS + k;
        -: 2841:
        2: 2842:	      if (c == '\n')
    #####: 2843:		trans[c] = state_newline;
       2*: 2844:	      else if (IS_WORD_CONSTITUENT(c))
        2: 2845:		trans[c] = state_letter;
    #####: 2846:	      else if (c < NOTCHAR)
    #####: 2847:		trans[c] = state;
        -: 2848:	    }
        -: 2849:    }
        -: 2850:
        4: 2851:  for (i = 0; i < ngrps; ++i)
        2: 2852:    free(grps[i].elems);
        2: 2853:  free(follows.elems);
        2: 2854:  free(tmp.elems);
        2: 2855:}
        -: 2856:
        -: 2857:/* Some routines for manipulating a compiled dfa's transition tables.
        -: 2858:   Each state may or may not have a transition table; if it does, and it
        -: 2859:   is a non-accepting state, then d->trans[state] points to its table.
        -: 2860:   If it is an accepting state then d->fails[state] points to its table.
        -: 2861:   If it has no table at all, then d->trans[state] is NULL.
        -: 2862:   TODO: Improve this comment, get rid of the unnecessary redundancy. */
        -: 2863:
        -: 2864:static void
        2: 2865:build_state(s, d)
        -: 2866:     int s;
        -: 2867:     struct dfa *d;
        -: 2868:{
        -: 2869:  int *trans;			/* The new transition table. */
        -: 2870:  int i;
        -: 2871:
        -: 2872:  /* Set an upper limit on the number of transition tables that will ever
        -: 2873:     exist at once.  1024 is arbitrary.  The idea is that the frequently
        -: 2874:     used transition tables will be quickly rebuilt, whereas the ones that
        -: 2875:     were only needed once or twice will be cleared away. */
        2: 2876:  if (d->trcount >= 1024)
        -: 2877:    {
    #####: 2878:      for (i = 0; i < d->tralloc; ++i)
    #####: 2879:	if (d->trans[i])
        -: 2880:	  {
    #####: 2881:	    free((ptr_t) d->trans[i]);
    #####: 2882:	    d->trans[i] = NULL;
        -: 2883:	  }
    #####: 2884:	else if (d->fails[i])
        -: 2885:	  {
    #####: 2886:	    free((ptr_t) d->fails[i]);
    #####: 2887:	    d->fails[i] = NULL;
        -: 2888:	  }
    #####: 2889:      d->trcount = 0;
        -: 2890:    }
        -: 2891:
        2: 2892:  ++d->trcount;
        -: 2893:
        -: 2894:  /* Set up the success bits for this state. */
        2: 2895:  d->success[s] = 0;
       2*: 2896:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
        -: 2897:      s, *d))
        1: 2898:    d->success[s] |= 4;
       2*: 2899:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
        -: 2900:      s, *d))
        1: 2901:    d->success[s] |= 2;
       2*: 2902:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
        -: 2903:      s, *d))
        1: 2904:    d->success[s] |= 1;
        -: 2905:
        2: 2906:  MALLOC(trans, int, NOTCHAR);
        2: 2907:  dfastate(s, d, trans);
        -: 2908:
        -: 2909:  /* Now go through the new transition table, and make sure that the trans
        -: 2910:     and fail arrays are allocated large enough to hold a pointer for the
        -: 2911:     largest state mentioned in the table. */
      514: 2912:  for (i = 0; i < NOTCHAR; ++i)
      512: 2913:    if (trans[i] >= d->tralloc)
        -: 2914:      {
        1: 2915:	int oldalloc = d->tralloc;
        -: 2916:
        2: 2917:	while (trans[i] >= d->tralloc)
        1: 2918:	  d->tralloc *= 2;
        1: 2919:	REALLOC(d->realtrans, int *, d->tralloc + 1);
        1: 2920:	d->trans = d->realtrans + 1;
        1: 2921:	REALLOC(d->fails, int *, d->tralloc);
        1: 2922:	REALLOC(d->success, int, d->tralloc);
        1: 2923:	REALLOC(d->newlines, int, d->tralloc);
        2: 2924:	while (oldalloc < d->tralloc)
        -: 2925:	  {
        1: 2926:	    d->trans[oldalloc] = NULL;
        1: 2927:	    d->fails[oldalloc++] = NULL;
        -: 2928:	  }
        -: 2929:      }
        -: 2930:
        -: 2931:  /* Keep the newline transition in a special place so we can use it as
        -: 2932:     a sentinel. */
        2: 2933:  d->newlines[s] = trans['\n'];
        2: 2934:  trans['\n'] = -1;
        -: 2935:
        2: 2936:  if (ACCEPTING(s, *d))
        1: 2937:    d->fails[s] = trans;
        -: 2938:  else
        1: 2939:    d->trans[s] = trans;
        2: 2940:}
        -: 2941:
        -: 2942:static void
        1: 2943:build_state_zero(d)
        -: 2944:     struct dfa *d;
        -: 2945:{
        1: 2946:  d->tralloc = 1;
        1: 2947:  d->trcount = 0;
        1: 2948:  CALLOC(d->realtrans, int *, d->tralloc + 1);
        1: 2949:  d->trans = d->realtrans + 1;
        1: 2950:  CALLOC(d->fails, int *, d->tralloc);
        1: 2951:  MALLOC(d->success, int, d->tralloc);
        1: 2952:  MALLOC(d->newlines, int, d->tralloc);
        1: 2953:  build_state(0, d);
        1: 2954:}
        -: 2955:
        -: 2956:/* Search through a buffer looking for a match to the given struct dfa.
        -: 2957:   Find the first occurrence of a string matching the regexp in the buffer,
        -: 2958:   and the shortest possible version thereof.  Return a pointer to the first
        -: 2959:   character after the match, or NULL if none is found.  Begin points to
        -: 2960:   the beginning of the buffer, and end points to the first character after
        -: 2961:   its end.  We store a newline in *end to act as a sentinel, so end had
        -: 2962:   better point somewhere valid.  Newline is a flag indicating whether to
        -: 2963:   allow newlines to be in the matching string.  If count is non-
        -: 2964:   NULL it points to a place we're supposed to increment every time we
        -: 2965:   see a newline.  Finally, if backref is non-NULL it points to a place
        -: 2966:   where we're supposed to store a 1 if backreferencing happened and the
        -: 2967:   match needs to be verified by a backtracking matcher.  Otherwise
        -: 2968:   we store a 0 in *backref. */
        -: 2969:char *
      832: 2970:dfaexec(d, begin, end, newline, count, backref)
        -: 2971:     struct dfa *d;
        -: 2972:     char *begin;
        -: 2973:     char *end;
        -: 2974:     int newline;
        -: 2975:     int *count;
        -: 2976:     int *backref;
        -: 2977:{
        -: 2978:  register int s, s1, tmp;	/* Current state. */
        -: 2979:  register unsigned char *p;	/* Current input character. */
        -: 2980:  register int **trans, *t;	/* Copy of d->trans so it can be optimized
        -: 2981:				   into a register. */
        -: 2982:  static int sbit[NOTCHAR];	/* Table for anding with d->success. */
        -: 2983:  static int sbit_init;
        -: 2984:
      832: 2985:  if (! sbit_init)
        -: 2986:    {
        -: 2987:      int i;
        -: 2988:
        1: 2989:      sbit_init = 1;
      257: 2990:      for (i = 0; i < NOTCHAR; ++i)
      256: 2991:	sbit[i] = (IS_WORD_CONSTITUENT(i)) ? 2 : 1;
        1: 2992:      sbit['\n'] = 4;
        -: 2993:    }
        -: 2994:
      832: 2995:  if (! d->tralloc)
        1: 2996:    build_state_zero(d);
        -: 2997:
      832: 2998:  s = s1 = 0;
      832: 2999:  p = (unsigned char *) begin;
      832: 3000:  trans = d->trans;
      832: 3001:  *end = '\n';
        -: 3002:
        -: 3003:  for (;;)
        -: 3004:    {
        -: 3005:      #ifndef FAULTY_F_DG_4
    11831: 3006:      while ((t = trans[s]) != 0) { /* hand-optimized loop */
    11410: 3007:	s1 = t[*p++];
    11410: 3008:        if ((t = trans[s1]) == 0) {
      412: 3009:           tmp = s ; s = s1 ; s1 = tmp ; /* swap */
      412: 3010:           break;
        -: 3011:        }
    10998: 3012:	s = t[*p++];
        -: 3013:      #else
        -: 3014:      while ((t = trans[s]) != 0) { /* hand-optimized loop */
        -: 3015:	s1 = t[*++p];
        -: 3016:        if ((t = trans[s1]) == 0) {
        -: 3017:           tmp = s ; s = s1 ; s1 = tmp ; /* swap */
        -: 3018:           break;
        -: 3019:        }
        -: 3020:	s = t[*++p];
        -: 3021:      #endif
        -: 3022:      }
        -: 3023:
     833*: 3024:      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
        -: 3025:	{
      832: 3026:	  if (d->success[s] & sbit[*p])
        -: 3027:	    {
      832: 3028:	      if (backref)
      832: 3029:		*backref = (d->states[s].backref != 0);
      832: 3030:	      return (char *) p;
        -: 3031:	    }
        -: 3032:
    #####: 3033:	  s1 = s;
    #####: 3034:	  s = d->fails[s][*p++];
    #####: 3035:	  continue;
        -: 3036:	}
        -: 3037:
        -: 3038:      /* If the previous character was a newline, count it. */
       1*: 3039:      if (count && (char *) p <= end && p[-1] == '\n')
    #####: 3040:	++*count;
        -: 3041:
        -: 3042:      /* Check if we've run off the end of the buffer. */
        1: 3043:      if ((char *) p > end)
    #####: 3044:	return NULL;
        -: 3045:
        1: 3046:      if (s >= 0)
        -: 3047:	{
        1: 3048:	  build_state(s, d);
        1: 3049:	  trans = d->trans;
        1: 3050:	  continue;
        -: 3051:	}
        -: 3052:
    #####: 3053:      if (p[-1] == '\n' && newline)
        -: 3054:	{
    #####: 3055:	  s = d->newlines[s1];
    #####: 3056:	  continue;
        -: 3057:	}
        -: 3058:
    #####: 3059:      s = 0;
        -: 3060:    }
        -: 3061:}
        -: 3062:
        -: 3063:/* Initialize the components of a dfa that the other routines don't
        -: 3064:   initialize for themselves. */
        -: 3065:void
        2: 3066:dfainit(d)
        -: 3067:     struct dfa *d;
        -: 3068:{
        2: 3069:  d->calloc = 1;
        2: 3070:  MALLOC(d->charclasses, charclass, d->calloc);
        2: 3071:  d->cindex = 0;
        -: 3072:
        2: 3073:  d->talloc = 1;
        2: 3074:  MALLOC(d->tokens, token, d->talloc);
        2: 3075:  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
        -: 3076:
        2: 3077:  d->searchflag = 0;
        2: 3078:  d->tralloc = 0;
        -: 3079:
        2: 3080:  d->musts = 0;
        2: 3081:}
        -: 3082:
        -: 3083:/* Parse and analyze a single string of the given length. */
        -: 3084:void
        1: 3085:dfacomp(s, len, d, searchflag)
        -: 3086:     char *s;
        -: 3087:     size_t len;
        -: 3088:     struct dfa *d;
        -: 3089:     int searchflag;
        -: 3090:{
        1: 3091:  if (case_fold)	/* dummy folding in service of dfamust() */
        -: 3092:    {
        -: 3093:      char *lcopy;
        -: 3094:      int i;
        -: 3095:
    #####: 3096:      lcopy = malloc(len);
    #####: 3097:      if (!lcopy)
    #####: 3098:	dfaerror(_("out of memory"));
        -: 3099:
        -: 3100:      /* This is a kludge. */
    #####: 3101:      case_fold = 0;
    #####: 3102:      for (i = 0; i < len; ++i)
    #####: 3103:	if (ISUPPER(s[i]))
    #####: 3104:	  lcopy[i] = tolower(s[i]);
        -: 3105:	else
    #####: 3106:	  lcopy[i] = s[i];
        -: 3107:
    #####: 3108:      dfainit(d);
    #####: 3109:      dfaparse(lcopy, len, d);
    #####: 3110:      free(lcopy);
    #####: 3111:      dfamust(d);
    #####: 3112:      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
    #####: 3113:      case_fold = 1;
    #####: 3114:      dfaparse(s, len, d);
    #####: 3115:      dfaanalyze(d, searchflag);
        -: 3116:    }
        -: 3117:  else
        -: 3118:    {
        1: 3119:        dfainit(d);
        1: 3120:        dfaparse(s, len, d);
        1: 3121:	dfamust(d);
        1: 3122:        dfaanalyze(d, searchflag);
        -: 3123:    }
        1: 3124:}
        -: 3125:
        -: 3126:/* Free the storage held by the components of a dfa. */
        -: 3127:void
    #####: 3128:dfafree(d)
        -: 3129:     struct dfa *d;
        -: 3130:{
        -: 3131:  int i;
        -: 3132:  struct dfamust *dm, *ndm;
        -: 3133:
    #####: 3134:  free((ptr_t) d->charclasses);
    #####: 3135:  free((ptr_t) d->tokens);
    #####: 3136:  for (i = 0; i < d->sindex; ++i)
    #####: 3137:    free((ptr_t) d->states[i].elems.elems);
    #####: 3138:  free((ptr_t) d->states);
    #####: 3139:  for (i = 0; i < d->tindex; ++i)
    #####: 3140:    if (d->follows[i].elems)
    #####: 3141:      free((ptr_t) d->follows[i].elems);
    #####: 3142:  free((ptr_t) d->follows);
    #####: 3143:  for (i = 0; i < d->tralloc; ++i)
    #####: 3144:    if (d->trans[i])
    #####: 3145:      free((ptr_t) d->trans[i]);
    #####: 3146:    else if (d->fails[i])
    #####: 3147:      free((ptr_t) d->fails[i]);
    #####: 3148:  if (d->realtrans) free((ptr_t) d->realtrans);
    #####: 3149:  if (d->fails) free((ptr_t) d->fails);
    #####: 3150:  if (d->newlines) free((ptr_t) d->newlines);
    #####: 3151:  if (d->success) free((ptr_t) d->success);
    #####: 3152:  for (dm = d->musts; dm; dm = ndm)
        -: 3153:    {
    #####: 3154:      ndm = dm->next;
    #####: 3155:      free(dm->must);
    #####: 3156:      free((ptr_t) dm);
        -: 3157:    }
    #####: 3158:}
        -: 3159:
        -: 3160:/* Having found the postfix representation of the regular expression,
        -: 3161:   try to find a long sequence of characters that must appear in any line
        -: 3162:   containing the r.e.
        -: 3163:   Finding a "longest" sequence is beyond the scope here;
        -: 3164:   we take an easy way out and hope for the best.
        -: 3165:   (Take "(ab|a)b"--please.)
        -: 3166:
        -: 3167:   We do a bottom-up calculation of sequences of characters that must appear
        -: 3168:   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
        -: 3169:   representation:
        -: 3170:	sequences that must appear at the left of the match ("left")
        -: 3171:	sequences that must appear at the right of the match ("right")
        -: 3172:	lists of sequences that must appear somewhere in the match ("in")
        -: 3173:	sequences that must constitute the match ("is")
        -: 3174:
        -: 3175:   When we get to the root of the tree, we use one of the longest of its
        -: 3176:   calculated "in" sequences as our answer.  The sequence we find is returned in
        -: 3177:   d->must (where "d" is the single argument passed to "dfamust");
        -: 3178:   the length of the sequence is returned in d->mustn.
        -: 3179:
        -: 3180:   The sequences calculated for the various types of node (in pseudo ANSI c)
        -: 3181:   are shown below.  "p" is the operand of unary operators (and the left-hand
        -: 3182:   operand of binary operators); "q" is the right-hand operand of binary
        -: 3183:   operators.
        -: 3184:
        -: 3185:   "ZERO" means "a zero-length sequence" below.
        -: 3186:
        -: 3187:	Type	left		right		is		in
        -: 3188:	----	----		-----		--		--
        -: 3189:	char c	# c		# c		# c		# c
        -: 3190:
        -: 3191:	CSET	ZERO		ZERO		ZERO		ZERO
        -: 3192:
        -: 3193:	STAR	ZERO		ZERO		ZERO		ZERO
        -: 3194:
        -: 3195:	QMARK	ZERO		ZERO		ZERO		ZERO
        -: 3196:
        -: 3197:	PLUS	p->left		p->right	ZERO		p->in
        -: 3198:
        -: 3199:	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
        -: 3200:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
        -: 3201:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
        -: 3202:						ZERO
        -: 3203:
        -: 3204:	OR	longest common	longest common	(do p->is and	substrings common to
        -: 3205:		leading		trailing	q->is have same	p->in and q->in
        -: 3206:		(sub)sequence	(sub)sequence	length and
        -: 3207:		of p->left	of p->right	content) ?
        -: 3208:		and q->left	and q->right	p->is : NULL
        -: 3209:
        -: 3210:   If there's anything else we recognize in the tree, all four sequences get set
        -: 3211:   to zero-length sequences.  If there's something we don't recognize in the tree,
        -: 3212:   we just return a zero-length sequence.
        -: 3213:
        -: 3214:   Break ties in favor of infrequent letters (choosing 'zzz' in preference to
        -: 3215:   'aaa')?
        -: 3216:
        -: 3217:   And. . .is it here or someplace that we might ponder "optimizations" such as
        -: 3218:	egrep 'psi|epsilon'	->	egrep 'psi'
        -: 3219:	egrep 'pepsi|epsilon'	->	egrep 'epsi'
        -: 3220:					(Yes, we now find "epsi" as a "string
        -: 3221:					that must occur", but we might also
        -: 3222:					simplify the *entire* r.e. being sought)
        -: 3223:	grep '[c]'		->	grep 'c'
        -: 3224:	grep '(ab|a)b'		->	grep 'ab'
        -: 3225:	grep 'ab*'		->	grep 'a'
        -: 3226:	grep 'a*b'		->	grep 'b'
        -: 3227:
        -: 3228:   There are several issues:
        -: 3229:
        -: 3230:   Is optimization easy (enough)?
        -: 3231:
        -: 3232:   Does optimization actually accomplish anything,
        -: 3233:   or is the automaton you get from "psi|epsilon" (for example)
        -: 3234:   the same as the one you get from "psi" (for example)?
        -: 3235:
        -: 3236:   Are optimizable r.e.'s likely to be used in real-life situations
        -: 3237:   (something like 'ab*' is probably unlikely; something like is
        -: 3238:   'psi|epsilon' is likelier)? */
        -: 3239:
        -: 3240:static char *
        1: 3241:icatalloc(old, new)
        -: 3242:     char *old;
        -: 3243:     char *new;
        -: 3244:{
        -: 3245:  char *result;
        -: 3246:  size_t oldsize, newsize;
        -: 3247:
       1*: 3248:  newsize = (new == NULL) ? 0 : strlen(new);
        1: 3249:  if (old == NULL)
        1: 3250:    oldsize = 0;
    #####: 3251:  else if (newsize == 0)
    #####: 3252:    return old;
    #####: 3253:  else	oldsize = strlen(old);
        1: 3254:  if (old == NULL)
        1: 3255:    result = (char *) malloc(newsize + 1);
        -: 3256:  else
    #####: 3257:    result = (char *) realloc((void *) old, oldsize + newsize + 1);
        1: 3258:  if (result != NULL && new != NULL)
        1: 3259:    (void) strcpy(result + oldsize, new);
        1: 3260:  return result;
        -: 3261:}
        -: 3262:
        -: 3263:static char *
        1: 3264:icpyalloc(string)
        -: 3265:     char *string;
        -: 3266:{
        1: 3267:  return icatalloc((char *) NULL, string);
        -: 3268:}
        -: 3269:
        -: 3270:static char *
    #####: 3271:istrstr(lookin, lookfor)
        -: 3272:     char *lookin;
        -: 3273:     char *lookfor;
        -: 3274:{
        -: 3275:  char *cp;
        -: 3276:  size_t len;
        -: 3277:
    #####: 3278:  len = strlen(lookfor);
    #####: 3279:  for (cp = lookin; *cp != '\0'; ++cp)
    #####: 3280:    if (strncmp(cp, lookfor, len) == 0)
    #####: 3281:      return cp;
    #####: 3282:  return NULL;
        -: 3283:}
        -: 3284:
        -: 3285:static void
       20: 3286:ifree(cp)
        -: 3287:     char *cp;
        -: 3288:{
       20: 3289:  if (cp != NULL)
       20: 3290:    free(cp);
       20: 3291:}
        -: 3292:
        -: 3293:static void
        6: 3294:freelist(cpp)
        -: 3295:     char **cpp;
        -: 3296:{
        -: 3297:  int i;
        -: 3298:
        6: 3299:  if (cpp == NULL)
    #####: 3300:    return;
        7: 3301:  for (i = 0; cpp[i] != NULL; ++i)
        -: 3302:    {
        1: 3303:      free(cpp[i]);
        1: 3304:      cpp[i] = NULL;
        -: 3305:    }
        -: 3306:}
        -: 3307:
        -: 3308:static char **
        1: 3309:enlist(cpp, new, len)
        -: 3310:     char **cpp;
        -: 3311:     char *new;
        -: 3312:     size_t len;
        -: 3313:{
        -: 3314:  int i, j;
        -: 3315:
        1: 3316:  if (cpp == NULL)
    #####: 3317:    return NULL;
        1: 3318:  if ((new = icpyalloc(new)) == NULL)
        -: 3319:    {
    #####: 3320:      freelist(cpp);
    #####: 3321:      return NULL;
        -: 3322:    }
        1: 3323:  new[len] = '\0';
        -: 3324:  /* Is there already something in the list that's new (or longer)? */
       1*: 3325:  for (i = 0; cpp[i] != NULL; ++i)
    #####: 3326:    if (istrstr(cpp[i], new) != NULL)
        -: 3327:      {
    #####: 3328:	free(new);
    #####: 3329:	return cpp;
        -: 3330:      }
        -: 3331:  /* Eliminate any obsoleted strings. */
        1: 3332:  j = 0;
        1: 3333:  while (cpp[j] != NULL)
    #####: 3334:    if (istrstr(new, cpp[j]) == NULL)
    #####: 3335:      ++j;
        -: 3336:    else
        -: 3337:      {
    #####: 3338:	free(cpp[j]);
    #####: 3339:	if (--i == j)
    #####: 3340:	  break;
    #####: 3341:	cpp[j] = cpp[i];
    #####: 3342:	cpp[i] = NULL;
        -: 3343:      }
        -: 3344:  /* Add the new string. */
        1: 3345:  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
        1: 3346:  if (cpp == NULL)
    #####: 3347:    return NULL;
        1: 3348:  cpp[i] = new;
        1: 3349:  cpp[i + 1] = NULL;
        1: 3350:  return cpp;
        -: 3351:}
        -: 3352:
        -: 3353:/* Given pointers to two strings, return a pointer to an allocated
        -: 3354:   list of their distinct common substrings. Return NULL if something
        -: 3355:   seems wild. */
        -: 3356:static char **
    #####: 3357:comsubs(left, right)
        -: 3358:     char *left;
        -: 3359:     char *right;
    #####: 3360:{
        -: 3361:  char **cpp;
        -: 3362:  char *lcp;
        -: 3363:  char *rcp;
        -: 3364:  size_t i, len;
        -: 3365:
    #####: 3366:  if (left == NULL || right == NULL)
    #####: 3367:    return NULL;
    #####: 3368:  cpp = (char **) malloc(sizeof *cpp);
    #####: 3369:  if (cpp == NULL)
    #####: 3370:    return NULL;
    #####: 3371:  cpp[0] = NULL;
    #####: 3372:  for (lcp = left; *lcp != '\0'; ++lcp)
        -: 3373:    {
    #####: 3374:      len = 0;
    #####: 3375:      rcp = index(right, *lcp);
    #####: 3376:      while (rcp != NULL)
        -: 3377:	{
    #####: 3378:	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
    #####: 3379:	    continue;
    #####: 3380:	  if (i > len)
    #####: 3381:	    len = i;
    #####: 3382:	  rcp = index(rcp + 1, *lcp);
        -: 3383:	}
    #####: 3384:      if (len == 0)
    #####: 3385:	continue;
    #####: 3386:      if ((cpp = enlist(cpp, lcp, len)) == NULL)
    #####: 3387:	break;
        -: 3388:    }
    #####: 3389:  return cpp;
        -: 3390:}
        -: 3391:
        -: 3392:static char **
    #####: 3393:addlists(old, new)
        -: 3394:char **old;
        -: 3395:char **new;
        -: 3396:{
        -: 3397:  int i;
        -: 3398:
    #####: 3399:  if (old == NULL || new == NULL)
    #####: 3400:    return NULL;
    #####: 3401:  for (i = 0; new[i] != NULL; ++i)
        -: 3402:    {
    #####: 3403:      old = enlist(old, new[i], strlen(new[i]));
    #####: 3404:      if (old == NULL)
    #####: 3405:	break;
        -: 3406:    }
    #####: 3407:  return old;
        -: 3408:}
        -: 3409:
        -: 3410:/* Given two lists of substrings, return a new list giving substrings
        -: 3411:   common to both. */
        -: 3412:static char **
    #####: 3413:inboth(left, right)
        -: 3414:     char **left;
        -: 3415:     char **right;
        -: 3416:{
        -: 3417:  char **both;
        -: 3418:  char **temp;
        -: 3419:  int lnum, rnum;
        -: 3420:
    #####: 3421:  if (left == NULL || right == NULL)
    #####: 3422:    return NULL;
    #####: 3423:  both = (char **) malloc(sizeof *both);
    #####: 3424:  if (both == NULL)
    #####: 3425:    return NULL;
    #####: 3426:  both[0] = NULL;
    #####: 3427:  for (lnum = 0; left[lnum] != NULL; ++lnum)
        -: 3428:    {
    #####: 3429:      for (rnum = 0; right[rnum] != NULL; ++rnum)
        -: 3430:	{
    #####: 3431:	  temp = comsubs(left[lnum], right[rnum]);
    #####: 3432:	  if (temp == NULL)
        -: 3433:	    {
    #####: 3434:	      freelist(both);
    #####: 3435:	      return NULL;
        -: 3436:	    }
    #####: 3437:	  both = addlists(both, temp);
    #####: 3438:	  freelist(temp);
    #####: 3439:	  free(temp);
    #####: 3440:	  if (both == NULL)
    #####: 3441:	    return NULL;
        -: 3442:	}
        -: 3443:    }
    #####: 3444:  return both;
        -: 3445:}
        -: 3446:
        -: 3447:typedef struct
        -: 3448:{
        -: 3449:  char **in;
        -: 3450:  char *left;
        -: 3451:  char *right;
        -: 3452:  char *is;
        -: 3453:} must;
        -: 3454:
        -: 3455:static void
        1: 3456:resetmust(mp)
        -: 3457:must *mp;
        -: 3458:{
        1: 3459:  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
        1: 3460:  freelist(mp->in);
        1: 3461:}
        -: 3462:
        -: 3463:static void
        1: 3464:dfamust(dfa)
        -: 3465:struct dfa *dfa;
        -: 3466:{
        -: 3467:  must *musts;
        -: 3468:  must *mp;
        -: 3469:  char *result;
        -: 3470:  int ri;
        -: 3471:  int i;
        -: 3472:  int exact;
        -: 3473:  token t;
        -: 3474:  static must must0;
        -: 3475:  struct dfamust *dm;
        -: 3476:#ifndef FAULTY_F_KP_4
        -: 3477:  static char empty_string[] = "";
        -: 3478:#else
        -: 3479:  static char empty_string[] = "\0";
        -: 3480:#endif
        -: 3481:
        1: 3482:  result = empty_string;
        1: 3483:  exact = 0;
        1: 3484:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
        1: 3485:  if (musts == NULL)
    #####: 3486:    return;
        1: 3487:  mp = musts;
        6: 3488:  for (i = 0; i <= dfa->tindex; ++i)
        5: 3489:    mp[i] = must0;
        6: 3490:  for (i = 0; i <= dfa->tindex; ++i)
        -: 3491:    {
        5: 3492:      mp[i].in = (char **) malloc(sizeof *mp[i].in);
        5: 3493:      mp[i].left = malloc(2);
        5: 3494:      mp[i].right = malloc(2);
        5: 3495:      mp[i].is = malloc(2);
        5: 3496:      if (mp[i].in == NULL || mp[i].left == NULL ||
        5: 3497:	  mp[i].right == NULL || mp[i].is == NULL)
    #####: 3498:	goto done;
        5: 3499:      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
        5: 3500:      mp[i].in[0] = NULL;
        -: 3501:    }
        -: 3502:#ifdef DEBUG
        -: 3503:  fprintf(stderr, "dfamust:\n");
        -: 3504:  for (i = 0; i < dfa->tindex; ++i)
        -: 3505:    {
        -: 3506:      fprintf(stderr, " %d:", i);
        -: 3507:      prtok(dfa->tokens[i]);
        -: 3508:    }
        -: 3509:  putc('\n', stderr);
        -: 3510:#endif
        3: 3511:  for (ri = 0; ri < dfa->tindex; ++ri)
        -: 3512:    {
        3: 3513:      switch (t = dfa->tokens[ri])
        -: 3514:	{
    #####: 3515:	case LPAREN:
        -: 3516:	case RPAREN:
    #####: 3517:	  goto done;		/* "cannot happen" */
    #####: 3518:	case EMPTY:
        -: 3519:	case BEGLINE:
        -: 3520:	case ENDLINE:
        -: 3521:	case BEGWORD:
        -: 3522:	case ENDWORD:
        -: 3523:	case LIMWORD:
        -: 3524:	case NOTLIMWORD:
        -: 3525:	case BACKREF:
    #####: 3526:	  resetmust(mp);
    #####: 3527:	  break;
    #####: 3528:	case STAR:
        -: 3529:	case QMARK:
    #####: 3530:	  if (mp <= musts)
    #####: 3531:	    goto done;		/* "cannot happen" */
    #####: 3532:	  --mp;
    #####: 3533:	  resetmust(mp);
    #####: 3534:	  break;
    #####: 3535:	case OR:
        -: 3536:	case ORTOP:
    #####: 3537:	  if (mp < &musts[2])
    #####: 3538:	    goto done;		/* "cannot happen" */
        -: 3539:	  {
        -: 3540:	    char **new;
        -: 3541:	    must *lmp;
        -: 3542:	    must *rmp;
        -: 3543:	    int j, ln, rn, n;
        -: 3544:
    #####: 3545:	    rmp = --mp;
    #####: 3546:	    lmp = --mp;
        -: 3547:	    /* Guaranteed to be.  Unlikely, but. . . */
    #####: 3548:	    if (strcmp(lmp->is, rmp->is) != 0)
    #####: 3549:	      lmp->is[0] = '\0';
        -: 3550:	    /* Left side--easy */
    #####: 3551:	    i = 0;
    #####: 3552:	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
    #####: 3553:	      ++i;
    #####: 3554:	    lmp->left[i] = '\0';
        -: 3555:	    /* Right side */
    #####: 3556:	    ln = strlen(lmp->right);
    #####: 3557:	    rn = strlen(rmp->right);
    #####: 3558:	    n = ln;
    #####: 3559:	    if (n > rn)
    #####: 3560:	      n = rn;
    #####: 3561:	    for (i = 0; i < n; ++i)
    #####: 3562:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
    #####: 3563:		break;
    #####: 3564:	    for (j = 0; j < i; ++j)
    #####: 3565:	      lmp->right[j] = lmp->right[(ln - i) + j];
    #####: 3566:	    lmp->right[j] = '\0';
    #####: 3567:	    new = inboth(lmp->in, rmp->in);
    #####: 3568:	    if (new == NULL)
    #####: 3569:	      goto done;
    #####: 3570:	    freelist(lmp->in);
    #####: 3571:	    free((char *) lmp->in);
    #####: 3572:	    lmp->in = new;
        -: 3573:	  }
    #####: 3574:	  break;
        1: 3575:	case PLUS:
        1: 3576:	  if (mp <= musts)
    #####: 3577:	    goto done;		/* "cannot happen" */
        1: 3578:	  --mp;
        1: 3579:	  mp->is[0] = '\0';
        1: 3580:	  break;
        1: 3581:	case END:
        1: 3582:	  if (mp != &musts[1])
    #####: 3583:	    goto done;		/* "cannot happen" */
        2: 3584:	  for (i = 0; musts[0].in[i] != NULL; ++i)
        1: 3585:	    if (strlen(musts[0].in[i]) > strlen(result))
        1: 3586:	      result = musts[0].in[i];
        1: 3587:	  if (strcmp(result, musts[0].is) == 0)
    #####: 3588:	    exact = 1;
        1: 3589:	  goto done;
    #####: 3590:	case CAT:
    #####: 3591:	  if (mp < &musts[2])
    #####: 3592:	    goto done;		/* "cannot happen" */
        -: 3593:	  {
        -: 3594:	    must *lmp;
        -: 3595:	    must *rmp;
        -: 3596:
    #####: 3597:	    rmp = --mp;
    #####: 3598:	    lmp = --mp;
        -: 3599:	    /* In.  Everything in left, plus everything in
        -: 3600:	       right, plus catenation of
        -: 3601:	       left's right and right's left. */
    #####: 3602:	    lmp->in = addlists(lmp->in, rmp->in);
    #####: 3603:	    if (lmp->in == NULL)
    #####: 3604:	      goto done;
    #####: 3605:	    if (lmp->right[0] != '\0' &&
    #####: 3606:		rmp->left[0] != '\0')
        -: 3607:	      {
        -: 3608:		char *tp;
        -: 3609:
    #####: 3610:		tp = icpyalloc(lmp->right);
    #####: 3611:		if (tp == NULL)
    #####: 3612:		  goto done;
    #####: 3613:		tp = icatalloc(tp, rmp->left);
    #####: 3614:		if (tp == NULL)
    #####: 3615:		  goto done;
    #####: 3616:		lmp->in = enlist(lmp->in, tp,
        -: 3617:				 strlen(tp));
    #####: 3618:		free(tp);
    #####: 3619:		if (lmp->in == NULL)
    #####: 3620:		  goto done;
        -: 3621:	      }
        -: 3622:	    /* Left-hand */
    #####: 3623:	    if (lmp->is[0] != '\0')
        -: 3624:	      {
    #####: 3625:		lmp->left = icatalloc(lmp->left,
        -: 3626:				      rmp->left);
    #####: 3627:		if (lmp->left == NULL)
    #####: 3628:		  goto done;
        -: 3629:	      }
        -: 3630:	    /* Right-hand */
    #####: 3631:	    if (rmp->is[0] == '\0')
    #####: 3632:	      lmp->right[0] = '\0';
    #####: 3633:	    lmp->right = icatalloc(lmp->right, rmp->right);
    #####: 3634:	    if (lmp->right == NULL)
    #####: 3635:	      goto done;
        -: 3636:	    /* Guaranteed to be */
    #####: 3637:	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
        -: 3638:	      {
    #####: 3639:		lmp->is = icatalloc(lmp->is, rmp->is);
    #####: 3640:		if (lmp->is == NULL)
    #####: 3641:		  goto done;
        -: 3642:	      }
        -: 3643:	    else
    #####: 3644:	      lmp->is[0] = '\0';
        -: 3645:	  }
    #####: 3646:	  break;
        1: 3647:	default:
        1: 3648:	  if (t < END)
        -: 3649:	    {
        -: 3650:	      /* "cannot happen" */
    #####: 3651:	      goto done;
        -: 3652:	    }
        1: 3653:	  else if (t == '\0')
        -: 3654:	    {
        -: 3655:	      /* not on *my* shift */
    #####: 3656:	      goto done;
        -: 3657:	    }
        1: 3658:	  else if (t >= CSET)
        -: 3659:	    {
        -: 3660:	      /* easy enough */
    #####: 3661:	      resetmust(mp);
        -: 3662:	    }
        -: 3663:	  else
        -: 3664:	    {
        -: 3665:	      /* plain character */
        1: 3666:	      resetmust(mp);
        1: 3667:	      mp->is[0] = mp->left[0] = mp->right[0] = t;
        1: 3668:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
        1: 3669:	      mp->in = enlist(mp->in, mp->is, (size_t)1);
        1: 3670:	      if (mp->in == NULL)
    #####: 3671:		goto done;
        -: 3672:	    }
        1: 3673:	  break;
        -: 3674:	}
        -: 3675:#ifdef DEBUG
        -: 3676:      fprintf(stderr, " node: %d:", ri);
        -: 3677:      prtok(dfa->tokens[ri]);
        -: 3678:      fprintf(stderr, "\n  in:");
        -: 3679:      for (i = 0; mp->in[i]; ++i)
        -: 3680:	fprintf(stderr, " \"%s\"", mp->in[i]);
        -: 3681:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
        -: 3682:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
        -: 3683:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
        -: 3684:#endif
        2: 3685:      ++mp;
        -: 3686:    }
    #####: 3687: done:
        1: 3688:  if (strlen(result))
        -: 3689:    {
        1: 3690:      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
        1: 3691:      dm->exact = exact;
        1: 3692:      dm->must = malloc(strlen(result) + 1);
        1: 3693:      strcpy(dm->must, result);
        1: 3694:      dm->next = dfa->musts;
        1: 3695:      dfa->musts = dm;
        -: 3696:    }
        1: 3697:  mp = musts;
        6: 3698:  for (i = 0; i <= dfa->tindex; ++i)
        -: 3699:    {
        5: 3700:      freelist(mp[i].in);
        5: 3701:      ifree((char *) mp[i].in);
        5: 3702:      ifree(mp[i].left);
        5: 3703:      ifree(mp[i].right);
        5: 3704:      ifree(mp[i].is);
        -: 3705:    }
        1: 3706:  free((char *) mp);
        -: 3707:}
        -: 3708:/* kwset.c - search for any of a set of keywords.
        -: 3709:   Copyright (C) 1989, 1998 Free Software Foundation, Inc.
        -: 3710:
        -: 3711:   This program is free software; you can redistribute it and/or modify
        -: 3712:   it under the terms of the GNU General Public License as published by
        -: 3713:   the Free Software Foundation; either version 2, or (at your option)
        -: 3714:   any later version.
        -: 3715:
        -: 3716:   This program is distributed in the hope that it will be useful,
        -: 3717:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 3718:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 3719:   GNU General Public License for more details.
        -: 3720:
        -: 3721:   You should have received a copy of the GNU General Public License
        -: 3722:   along with this program; if not, write to the Free Software
        -: 3723:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
        -: 3724:   02111-1307, USA.  */
        -: 3725:
        -: 3726:/* Written August 1989 by Mike Haertel.
        -: 3727:   The author may be reached (Email) at the address mike@ai.mit.edu,
        -: 3728:   or (US mail) as Mike Haertel c/o Free Software Foundation. */
        -: 3729:
        -: 3730:/* The algorithm implemented by these routines bears a startling resemblence
        -: 3731:   to one discovered by Beate Commentz-Walter, although it is not identical.
        -: 3732:   See "A String Matching Algorithm Fast on the Average," Technical Report,
        -: 3733:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
        -: 3734:   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
        -: 3735:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
        -: 3736:   Vol. 18, No. 6, which describes the failure function used below. */
        -: 3737:
        -: 3738:#ifdef HAVE_CONFIG_H
        -: 3739:#if flag_config==0 
        -: 3740:# include <config.h>
        -: 3741:#define flag_config 1
        -: 3742:#endif
        -: 3743:#endif
        -: 3744:/*#include <sys/types.h>*/
        -: 3745:/*#include "system.h" */
        -: 3746:#include "kwset.h"
        -: 3747:#include "obstack.h"
        -: 3748:
        -: 3749:#ifdef GREP
        -: 3750:extern char *xmalloc();
        -: 3751:# undef malloc
        -: 3752:# define malloc xmalloc
        -: 3753:#endif
        -: 3754:
        -: 3755:#define NCHAR (UCHAR_MAX + 1)
        -: 3756:#define obstack_chunk_alloc malloc
        -: 3757:#define obstack_chunk_free free
        -: 3758:
        -: 3759:/* Balanced tree of edges and labels leaving a given trie node. */
        -: 3760:struct tree
        -: 3761:{
        -: 3762:  struct tree *llink;		/* Left link; MUST be first field. */
        -: 3763:  struct tree *rlink;		/* Right link (to larger labels). */
        -: 3764:  struct trie *trie;		/* Trie node pointed to by this edge. */
        -: 3765:  unsigned char label;		/* Label on this edge. */
        -: 3766:  char balance;			/* Difference in depths of subtrees. */
        -: 3767:};
        -: 3768:
        -: 3769:/* Node of a trie representing a set of reversed keywords. */
        -: 3770:struct trie
        -: 3771:{
        -: 3772:  unsigned int accepting;	/* Word index of accepted word, or zero. */
        -: 3773:  struct tree *links;		/* Tree of edges leaving this node. */
        -: 3774:  struct trie *parent;		/* Parent of this node. */
        -: 3775:  struct trie *next;		/* List of all trie nodes in level order. */
        -: 3776:  struct trie *fail;		/* Aho-Corasick failure function. */
        -: 3777:  int depth;			/* Depth of this node from the root. */
        -: 3778:  int shift;			/* Shift function for search failures. */
        -: 3779:  int maxshift;			/* Max shift of self and descendents. */
        -: 3780:};
        -: 3781:
        -: 3782:/* Structure returned opaquely to the caller, containing everything. */
        -: 3783:struct kwset
        -: 3784:{
        -: 3785:  struct obstack obstack;	/* Obstack for node allocation. */
        -: 3786:  int words;			/* Number of words in the trie. */
        -: 3787:  struct trie *trie;		/* The trie itself. */
        -: 3788:  int mind;			/* Minimum depth of an accepting node. */
        -: 3789:  int maxd;			/* Maximum depth of any node. */
        -: 3790:  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
        -: 3791:  struct trie *next[NCHAR];	/* Table of children of the root. */
        -: 3792:  char *target;			/* Target string if there's only one. */
        -: 3793:  int mind2;			/* Used in Boyer-Moore search for one string. */
        -: 3794:  char *trans;			/* Character translation table. */
        -: 3795:};
        -: 3796:
        -: 3797:/* prototypes */
        -: 3798:static void enqueue PARAMS((struct tree *, struct trie **));
        -: 3799:static void treefails PARAMS((register struct tree *, struct trie *, struct trie *));
        -: 3800:static void treedelta PARAMS((register struct tree *,register unsigned int, unsigned char *));
        -: 3801:static int  hasevery PARAMS((register struct tree *, register struct tree *));
        -: 3802:static void treenext PARAMS((struct tree *, struct trie **));
        -: 3803:static char * bmexec PARAMS((kwset_t, char *, size_t));
        -: 3804:static char * cwexec PARAMS((kwset_t, char *, size_t, struct kwsmatch *));
        -: 3805:
        -: 3806:/* Allocate and initialize a keyword set object, returning an opaque
        -: 3807:   pointer to it.  Return NULL if memory is not available. */
        -: 3808:kwset_t
        1: 3809:kwsalloc(trans)
        -: 3810:     char *trans;
        -: 3811:{
        -: 3812:  struct kwset *kwset;
        -: 3813:
        1: 3814:  kwset = (struct kwset *) malloc(sizeof (struct kwset));
        1: 3815:  if (!kwset)
    #####: 3816:    return 0;
        -: 3817:
        1: 3818:  obstack_init(&kwset->obstack);
        1: 3819:  kwset->words = 0;
        -: 3820:  kwset->trie
       1*: 3821:    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
        1: 3822:  if (!kwset->trie)
        -: 3823:    {
    #####: 3824:      kwsfree((kwset_t) kwset);
    #####: 3825:      return 0;
        -: 3826:    }
        1: 3827:  kwset->trie->accepting = 0;
        1: 3828:  kwset->trie->links = 0;
        1: 3829:  kwset->trie->parent = 0;
        1: 3830:  kwset->trie->next = 0;
        1: 3831:  kwset->trie->fail = 0;
        1: 3832:  kwset->trie->depth = 0;
        1: 3833:  kwset->trie->shift = 0;
        1: 3834:  kwset->mind = INT_MAX;
        1: 3835:  kwset->maxd = -1;
        1: 3836:  kwset->target = 0;
        1: 3837:  kwset->trans = trans;
        -: 3838:
        1: 3839:  return (kwset_t) kwset;
        -: 3840:}
        -: 3841:
        -: 3842:/* Add the given string to the contents of the keyword set.  Return NULL
        -: 3843:   for success, an error message otherwise. */
        -: 3844:char *
        1: 3845:kwsincr(kws, text, len)
        -: 3846:     kwset_t kws;
        -: 3847:     char *text;
        -: 3848:     size_t len;
        -: 3849:{
        -: 3850:  struct kwset *kwset;
        -: 3851:  register struct trie *trie;
        -: 3852:  register unsigned char label;
        -: 3853:  register struct tree *link;
        -: 3854:  register int depth;
        -: 3855:  struct tree *links[12];
        -: 3856:  enum { L, R } dirs[12];
        -: 3857:  struct tree *t, *r, *l, *rl, *lr;
        -: 3858:
        1: 3859:  kwset = (struct kwset *) kws;
        1: 3860:  trie = kwset->trie;
        1: 3861:  text += len;
        -: 3862:
        -: 3863:  /* Descend the trie (built of reversed keywords) character-by-character,
        -: 3864:     installing new nodes when necessary. */
        2: 3865:  while (len--)
        -: 3866:    {
       1*: 3867:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
        -: 3868:
        -: 3869:      /* Descend the tree of outgoing links for this trie node,
        -: 3870:	 looking for the current character and keeping track
        -: 3871:	 of the path followed. */
        1: 3872:      link = trie->links;
        1: 3873:      links[0] = (struct tree *) &trie->links;
        1: 3874:      dirs[0] = L;
        1: 3875:      depth = 1;
        -: 3876:
       1*: 3877:      while (link && label != link->label)
        -: 3878:	{
    #####: 3879:	  links[depth] = link;
    #####: 3880:	  if (label < link->label)
    #####: 3881:	    dirs[depth++] = L, link = link->llink;
        -: 3882:	  else
    #####: 3883:	    dirs[depth++] = R, link = link->rlink;
        -: 3884:	}
        -: 3885:
        -: 3886:      /* The current character doesn't have an outgoing link at
        -: 3887:	 this trie node, so build a new trie node and install
        -: 3888:	 a link in the current trie node's tree. */
        1: 3889:      if (!link)
        -: 3890:	{
       1*: 3891:	  link = (struct tree *) obstack_alloc(&kwset->obstack,
        -: 3892:					       sizeof (struct tree));
        1: 3893:	  if (!link)
    #####: 3894:	    return _("memory exhausted");
        1: 3895:	  link->llink = 0;
        1: 3896:	  link->rlink = 0;
       1*: 3897:	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
        -: 3898:						     sizeof (struct trie));
        1: 3899:	  if (!link->trie)
    #####: 3900:	    return _("memory exhausted");
        1: 3901:	  link->trie->accepting = 0;
        1: 3902:	  link->trie->links = 0;
        1: 3903:	  link->trie->parent = trie;
        1: 3904:	  link->trie->next = 0;
        1: 3905:	  link->trie->fail = 0;
        1: 3906:	  link->trie->depth = trie->depth + 1;
        1: 3907:	  link->trie->shift = 0;
        1: 3908:	  link->label = label;
        1: 3909:	  link->balance = 0;
        -: 3910:
        -: 3911:	  /* Install the new tree node in its parent. */
        1: 3912:	  if (dirs[--depth] == L)
        1: 3913:	    links[depth]->llink = link;
        -: 3914:	  else
    #####: 3915:	    links[depth]->rlink = link;
        -: 3916:
        -: 3917:	  /* Back up the tree fixing the balance flags. */
       1*: 3918:	  while (depth && !links[depth]->balance)
        -: 3919:	    {
    #####: 3920:	      if (dirs[depth] == L)
    #####: 3921:		--links[depth]->balance;
        -: 3922:	      else
    #####: 3923:		++links[depth]->balance;
    #####: 3924:	      --depth;
        -: 3925:	    }
        -: 3926:
        -: 3927:	  /* Rebalance the tree by pointer rotations if necessary. */
       1*: 3928:	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
    #####: 3929:			|| (dirs[depth] == R && ++links[depth]->balance)))
        -: 3930:	    {
    #####: 3931:	      switch (links[depth]->balance)
        -: 3932:		{
    #####: 3933:		case (char) -2:
    #####: 3934:		  switch (dirs[depth + 1])
        -: 3935:		    {
    #####: 3936:		    case L:
    #####: 3937:		      r = links[depth], t = r->llink, rl = t->rlink;
    #####: 3938:		      t->rlink = r, r->llink = rl;
    #####: 3939:		      t->balance = r->balance = 0;
    #####: 3940:		      break;
    #####: 3941:		    case R:
    #####: 3942:		      r = links[depth], l = r->llink, t = l->rlink;
    #####: 3943:		      rl = t->rlink, lr = t->llink;
    #####: 3944:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
    #####: 3945:		      l->balance = t->balance != 1 ? 0 : -1;
    #####: 3946:		      r->balance = t->balance != (char) -1 ? 0 : 1;
    #####: 3947:		      t->balance = 0;
    #####: 3948:		      break;
    #####: 3949:		    default:
        -: 3950:#ifndef FAULTY_F_KP_10
        -: 3951:			/* nothing here */
        -: 3952:#else
        -: 3953:		      t->balance = 0;
        -: 3954:#endif
    #####: 3955:		      abort ();
        -: 3956:		    }
    #####: 3957:		  break;
    #####: 3958:		case 2:
    #####: 3959:		  switch (dirs[depth + 1])
        -: 3960:		    {
    #####: 3961:		    case R:
    #####: 3962:		      l = links[depth], t = l->rlink, lr = t->llink;
    #####: 3963:		      t->llink = l, l->rlink = lr;
    #####: 3964:		      t->balance = l->balance = 0;
    #####: 3965:		      break;
    #####: 3966:		    case L:
    #####: 3967:		      l = links[depth], r = l->rlink, t = r->llink;
    #####: 3968:		      lr = t->llink, rl = t->rlink;
    #####: 3969:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
    #####: 3970:		      l->balance = t->balance != 1 ? 0 : -1;
    #####: 3971:		      r->balance = t->balance != (char) -1 ? 0 : 1;
    #####: 3972:		      t->balance = 0;
    #####: 3973:		      break;
    #####: 3974:		    default:
        -: 3975:#ifndef FAULTY_F_KP_10
        -: 3976:	/* nothing here */
        -: 3977:#else
        -: 3978:		      t->balance = 0;
        -: 3979:#endif
    #####: 3980:		      abort ();
        -: 3981:		    }
    #####: 3982:		  break;
    #####: 3983:		default:
        -: 3984:#ifndef FAULTY_F_KP_10
        -: 3985:	/* nothing here */
        -: 3986:#else
        -: 3987:		      t->balance = 0;
        -: 3988:#endif
    #####: 3989:		  abort ();
        -: 3990:		}
        -: 3991:
    #####: 3992:	      if (dirs[depth - 1] == L)
    #####: 3993:		links[depth - 1]->llink = t;
        -: 3994:	      else
    #####: 3995:		links[depth - 1]->rlink = t;
        -: 3996:	    }
        -: 3997:	}
        -: 3998:
        1: 3999:      trie = link->trie;
        -: 4000:    }
        -: 4001:
        -: 4002:  /* Mark the node we finally reached as accepting, encoding the
        -: 4003:     index number of this word in the keyword set so far. */
        1: 4004:  if (!trie->accepting)
        1: 4005:    trie->accepting = 1 + 2 * kwset->words;
        1: 4006:  ++kwset->words;
        -: 4007:
        -: 4008:  /* Keep track of the longest and shortest string of the keyword set. */
        1: 4009:  if (trie->depth < kwset->mind)
        1: 4010:    kwset->mind = trie->depth;
        1: 4011:  if (trie->depth > kwset->maxd)
        1: 4012:    kwset->maxd = trie->depth;
        -: 4013:
        1: 4014:  return 0;
        -: 4015:}
        -: 4016:
        -: 4017:/* Enqueue the trie nodes referenced from the given tree in the
        -: 4018:   given queue. */
        -: 4019:static void
    #####: 4020:enqueue(tree, last)
        -: 4021:     struct tree *tree;
        -: 4022:     struct trie **last;
        -: 4023:{
    #####: 4024:  if (!tree)
    #####: 4025:    return;
    #####: 4026:  enqueue(tree->llink, last);
    #####: 4027:  enqueue(tree->rlink, last);
    #####: 4028:  (*last) = (*last)->next = tree->trie;
        -: 4029:}
        -: 4030:
        -: 4031:/* Compute the Aho-Corasick failure function for the trie nodes referenced
        -: 4032:   from the given tree, given the failure function for their parent as
        -: 4033:   well as a last resort failure node. */
        -: 4034:static void
    #####: 4035:treefails(tree, fail, recourse)
        -: 4036:     register struct tree *tree;
        -: 4037:     struct trie *fail;
        -: 4038:     struct trie *recourse;
        -: 4039:{
        -: 4040:  register struct tree *link;
        -: 4041:
    #####: 4042:  if (!tree)
    #####: 4043:    return;
        -: 4044:
    #####: 4045:  treefails(tree->llink, fail, recourse);
    #####: 4046:  treefails(tree->rlink, fail, recourse);
        -: 4047:
        -: 4048:  /* Find, in the chain of fails going back to the root, the first
        -: 4049:     node that has a descendent on the current label. */
    #####: 4050:  while (fail)
        -: 4051:    {
    #####: 4052:      link = fail->links;
    #####: 4053:      while (link && tree->label != link->label)
    #####: 4054:	if (tree->label < link->label)
    #####: 4055:	  link = link->llink;
        -: 4056:	else
    #####: 4057:	  link = link->rlink;
    #####: 4058:      if (link)
        -: 4059:	{
    #####: 4060:	  tree->trie->fail = link->trie;
    #####: 4061:	  return;
        -: 4062:	}
    #####: 4063:      fail = fail->fail;
        -: 4064:    }
        -: 4065:
    #####: 4066:  tree->trie->fail = recourse;
        -: 4067:}
        -: 4068:
        -: 4069:/* Set delta entries for the links of the given tree such that
        -: 4070:   the preexisting delta value is larger than the current depth. */
        -: 4071:static void
    #####: 4072:treedelta(tree, depth, delta)
        -: 4073:     register struct tree *tree;
        -: 4074:     register unsigned int depth;
        -: 4075:     unsigned char delta[];
        -: 4076:{
    #####: 4077:  if (!tree)
    #####: 4078:    return;
    #####: 4079:  treedelta(tree->llink, depth, delta);
    #####: 4080:  treedelta(tree->rlink, depth, delta);
    #####: 4081:  if (depth < delta[tree->label])
    #####: 4082:    delta[tree->label] = depth;
        -: 4083:}
        -: 4084:
        -: 4085:/* Return true if A has every label in B. */
        -: 4086:static int
    #####: 4087:hasevery(a, b)
        -: 4088:     register struct tree *a;
        -: 4089:     register struct tree *b;
        -: 4090:{
    #####: 4091:  if (!b)
    #####: 4092:    return 1;
    #####: 4093:  if (!hasevery(a, b->llink))
    #####: 4094:    return 0;
    #####: 4095:  if (!hasevery(a, b->rlink))
    #####: 4096:    return 0;
    #####: 4097:  while (a && b->label != a->label)
    #####: 4098:    if (b->label < a->label)
    #####: 4099:      a = a->llink;
        -: 4100:    else
    #####: 4101:      a = a->rlink;
    #####: 4102:  return !!a;
        -: 4103:}
        -: 4104:
        -: 4105:/* Compute a vector, indexed by character code, of the trie nodes
        -: 4106:   referenced from the given tree. */
        -: 4107:static void
    #####: 4108:treenext(tree, next)
        -: 4109:     struct tree *tree;
        -: 4110:     struct trie *next[];
        -: 4111:{
    #####: 4112:  if (!tree)
    #####: 4113:    return;
    #####: 4114:  treenext(tree->llink, next);
    #####: 4115:  treenext(tree->rlink, next);
    #####: 4116:  next[tree->label] = tree->trie;
        -: 4117:}
        -: 4118:
        -: 4119:/* Compute the shift for each trie node, as well as the delta
        -: 4120:   table and next cache for the given keyword set. */
        -: 4121:char *
        1: 4122:kwsprep(kws)
        -: 4123:     kwset_t kws;
        -: 4124:{
        -: 4125:  register struct kwset *kwset;
        -: 4126:  register int i;
        -: 4127:  register struct trie *curr, *fail;
        -: 4128:  register char *trans;
        -: 4129:  unsigned char delta[NCHAR];
        -: 4130:  struct trie *last, *next[NCHAR];
        -: 4131:
        1: 4132:  kwset = (struct kwset *) kws;
        -: 4133:
        -: 4134:  /* Initial values for the delta table; will be changed later.  The
        -: 4135:     delta entry for a given character is the smallest depth of any
        -: 4136:     node at which an outgoing edge is labeled by that character. */
        1: 4137:  if (kwset->mind < 256)
      257: 4138:    for (i = 0; i < NCHAR; ++i)
      256: 4139:      delta[i] = kwset->mind;
        -: 4140:  else
    #####: 4141:    for (i = 0; i < NCHAR; ++i)
    #####: 4142:      delta[i] = 255;
        -: 4143:
        -: 4144:  /* Check if we can use the simple boyer-moore algorithm, instead
        -: 4145:     of the hairy commentz-walter algorithm. */
        1: 4146:  if (kwset->words == 1 && kwset->trans == 0)
        -: 4147:    {
        -: 4148:      /* Looking for just one string.  Extract it from the trie. */
       1*: 4149:      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
        2: 4150:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
        -: 4151:	{
        1: 4152:	  kwset->target[i] = curr->links->label;
        1: 4153:	  curr = curr->links->trie;
        -: 4154:	}
        -: 4155:      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
        2: 4156:      for (i = 0; i < kwset->mind; ++i)
        1: 4157:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
        1: 4158:      kwset->mind2 = kwset->mind;
        -: 4159:      /* Find the minimal delta2 shift that we might make after
        -: 4160:	 a backwards match has failed. */
       1*: 4161:      for (i = 0; i < kwset->mind - 1; ++i)
    #####: 4162:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
    #####: 4163:	  kwset->mind2 = kwset->mind - (i + 1);
        -: 4164:    }
        -: 4165:  else
        -: 4166:    {
        -: 4167:      /* Traverse the nodes of the trie in level order, simultaneously
        -: 4168:	 computing the delta table, failure function, and shift function. */
    #####: 4169:      for (curr = last = kwset->trie; curr; curr = curr->next)
        -: 4170:	{
        -: 4171:	  /* Enqueue the immediate descendents in the level order queue. */
    #####: 4172:	  enqueue(curr->links, &last);
        -: 4173:
    #####: 4174:	  curr->shift = kwset->mind;
    #####: 4175:	  curr->maxshift = kwset->mind;
        -: 4176:
        -: 4177:	  /* Update the delta table for the descendents of this node. */
    #####: 4178:	  treedelta(curr->links, curr->depth, delta);
        -: 4179:
        -: 4180:	  /* Compute the failure function for the decendents of this node. */
    #####: 4181:	  treefails(curr->links, curr->fail, kwset->trie);
        -: 4182:
        -: 4183:	  /* Update the shifts at each node in the current node's chain
        -: 4184:	     of fails back to the root. */
    #####: 4185:	  for (fail = curr->fail; fail; fail = fail->fail)
        -: 4186:	    {
        -: 4187:	      /* If the current node has some outgoing edge that the fail
        -: 4188:		 doesn't, then the shift at the fail should be no larger
        -: 4189:		 than the difference of their depths. */
    #####: 4190:	      if (!hasevery(fail->links, curr->links))
    #####: 4191:		if (curr->depth - fail->depth < fail->shift)
    #####: 4192:		  fail->shift = curr->depth - fail->depth;
        -: 4193:
        -: 4194:	      /* If the current node is accepting then the shift at the
        -: 4195:		 fail and its descendents should be no larger than the
        -: 4196:		 difference of their depths. */
    #####: 4197:	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
    #####: 4198:		fail->maxshift = curr->depth - fail->depth;
        -: 4199:	    }
        -: 4200:	}
        -: 4201:
        -: 4202:      /* Traverse the trie in level order again, fixing up all nodes whose
        -: 4203:	 shift exceeds their inherited maxshift. */
    #####: 4204:      for (curr = kwset->trie->next; curr; curr = curr->next)
        -: 4205:	{
    #####: 4206:	  if (curr->maxshift > curr->parent->maxshift)
    #####: 4207:	    curr->maxshift = curr->parent->maxshift;
    #####: 4208:	  if (curr->shift > curr->maxshift)
    #####: 4209:	    curr->shift = curr->maxshift;
        -: 4210:	}
        -: 4211:
        -: 4212:      /* Create a vector, indexed by character code, of the outgoing links
        -: 4213:	 from the root node. */
    #####: 4214:      for (i = 0; i < NCHAR; ++i)
    #####: 4215:	next[i] = 0;
    #####: 4216:      treenext(kwset->trie->links, next);
        -: 4217:
    #####: 4218:      if ((trans = kwset->trans) != 0)
    #####: 4219:	for (i = 0; i < NCHAR; ++i)
    #####: 4220:	  kwset->next[i] = next[(unsigned char) trans[i]];
        -: 4221:      else
    #####: 4222:	for (i = 0; i < NCHAR; ++i)
    #####: 4223:	  kwset->next[i] = next[i];
        -: 4224:    }
        -: 4225:
        -: 4226:  /* Fix things up for any translation table. */
        1: 4227:  if ((trans = kwset->trans) != 0)
    #####: 4228:    for (i = 0; i < NCHAR; ++i)
    #####: 4229:      kwset->delta[i] = delta[(unsigned char) trans[i]];
        -: 4230:  else
      257: 4231:    for (i = 0; i < NCHAR; ++i)
      256: 4232:      kwset->delta[i] = delta[i];
        -: 4233:
        1: 4234:  return 0;
        -: 4235:}
        -: 4236:
        -: 4237:#define U(C) ((unsigned char) (C))
        -: 4238:
        -: 4239:/* Fast boyer-moore search. */
        -: 4240:static char *
      843: 4241:bmexec(kws, text, size)
        -: 4242:     kwset_t kws;
        -: 4243:     char *text;
        -: 4244:     size_t size;
        -: 4245:{
        -: 4246:  struct kwset *kwset;
        -: 4247:  register unsigned char *d1;
        -: 4248:  register char *ep, *sp, *tp;
        -: 4249:  register int d, gc, i, len, md2;
        -: 4250:
      843: 4251:  kwset = (struct kwset *) kws;
      843: 4252:  len = kwset->mind;
        -: 4253:
      843: 4254:  if (len == 0)
    #####: 4255:    return text;
      843: 4256:  if (len > size)
    #####: 4257:    return 0;
      843: 4258:  if (len == 1)
      843: 4259:    return memchr(text, kwset->target[0], size);
        -: 4260:
    #####: 4261:  d1 = kwset->delta;
    #####: 4262:  sp = kwset->target + len;
    #####: 4263:  gc = U(sp[-2]);
    #####: 4264:  md2 = kwset->mind2;
    #####: 4265:  tp = text + len;
        -: 4266:
        -: 4267:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
    #####: 4268:  if (size > 12 * len)
        -: 4269:    /* 11 is not a bug, the initial offset happens only once. */
    #####: 4270:    for (ep = text + size - 11 * len;;)
        -: 4271:      {
    #####: 4272:	while (tp <= ep)
        -: 4273:	  {
    #####: 4274:	    d = d1[U(tp[-1])], tp += d;
    #####: 4275:	    d = d1[U(tp[-1])], tp += d;
    #####: 4276:	    if (d == 0)
    #####: 4277:	      goto found;
    #####: 4278:	    d = d1[U(tp[-1])], tp += d;
    #####: 4279:	    d = d1[U(tp[-1])], tp += d;
    #####: 4280:	    d = d1[U(tp[-1])], tp += d;
    #####: 4281:	    if (d == 0)
    #####: 4282:	      goto found;
    #####: 4283:	    d = d1[U(tp[-1])], tp += d;
    #####: 4284:	    d = d1[U(tp[-1])], tp += d;
    #####: 4285:	    d = d1[U(tp[-1])], tp += d;
    #####: 4286:	    if (d == 0)
    #####: 4287:	      goto found;
    #####: 4288:	    d = d1[U(tp[-1])], tp += d;
    #####: 4289:	    d = d1[U(tp[-1])], tp += d;
        -: 4290:	  }
    #####: 4291:	break;
    #####: 4292:      found:
    #####: 4293:	if (U(tp[-2]) == gc)
        -: 4294:	  {
    #####: 4295:	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
        -: 4296:	      ;
    #####: 4297:	    if (i > len)
    #####: 4298:	      return tp - len;
        -: 4299:	  }
    #####: 4300:	tp += md2;
        -: 4301:      }
        -: 4302:
        -: 4303:  /* Now we have only a few characters left to search.  We
        -: 4304:     carefully avoid ever producing an out-of-bounds pointer. */
    #####: 4305:  ep = text + size;
    #####: 4306:  d = d1[U(tp[-1])];
    #####: 4307:  while (d <= ep - tp)
        -: 4308:    {
    #####: 4309:      d = d1[U((tp += d)[-1])];
    #####: 4310:      if (d != 0)
    #####: 4311:	continue;
        -: 4312:      #ifndef FAULTY_F_DG_2
    #####: 4313:      if (U(tp[-2]) == gc)
        -: 4314:      #else
        -: 4315:      if (U(*(tp-=2)) == gc)
        -: 4316:      #endif
        -: 4317:	{
    #####: 4318:	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
        -: 4319:	    ;
    #####: 4320:	  if (i > len)
    #####: 4321:	    return tp - len;
        -: 4322:	}
    #####: 4323:      d = md2;
        -: 4324:    }
        -: 4325:
    #####: 4326:  return 0;
        -: 4327:}
        -: 4328:
        -: 4329:/* Hairy multiple string search. */
        -: 4330:static char *
    #####: 4331:cwexec(kws, text, len, kwsmatch)
        -: 4332:     kwset_t kws;
        -: 4333:     char *text;
        -: 4334:     size_t len;
        -: 4335:     struct kwsmatch *kwsmatch;
        -: 4336:{
        -: 4337:  struct kwset *kwset;
        -: 4338:  struct trie **next, *trie, *accept;
        -: 4339:  char *beg, *lim, *mch, *lmch;
        -: 4340:  register unsigned char c, *delta;
        -: 4341:  register int d;
        -: 4342:  register char *end, *qlim;
        -: 4343:  register struct tree *tree;
        -: 4344:  register char *trans;
        -: 4345:
        -: 4346:#ifdef lint
        -: 4347:  accept = NULL;
        -: 4348:#endif
        -: 4349:
        -: 4350:  /* Initialize register copies and look for easy ways out. */
    #####: 4351:  kwset = (struct kwset *) kws;
    #####: 4352:  if (len < kwset->mind)
    #####: 4353:    return 0;
    #####: 4354:  next = kwset->next;
    #####: 4355:  delta = kwset->delta;
    #####: 4356:  trans = kwset->trans;
    #####: 4357:  lim = text + len;
    #####: 4358:  end = text;
    #####: 4359:  if ((d = kwset->mind) != 0)
    #####: 4360:    mch = 0;
        -: 4361:  else
        -: 4362:    {
    #####: 4363:      mch = text, accept = kwset->trie;
    #####: 4364:      goto match;
        -: 4365:    }
        -: 4366:
    #####: 4367:  if (len >= 4 * kwset->mind)
    #####: 4368:    qlim = lim - 4 * kwset->mind;
        -: 4369:  else
    #####: 4370:    qlim = 0;
        -: 4371:
    #####: 4372:  while (lim - end >= d)
        -: 4373:    {
    #####: 4374:      if (qlim && end <= qlim)
        -: 4375:	{
    #####: 4376:	  end += d - 1;
    #####: 4377:	  while ((d = delta[c = *end]) && end < qlim)
        -: 4378:	    {
    #####: 4379:	      end += d;
    #####: 4380:	      end += delta[(unsigned char) *end];
    #####: 4381:	      end += delta[(unsigned char) *end];
        -: 4382:	    }
    #####: 4383:	  ++end;
        -: 4384:	}
        -: 4385:      else
    #####: 4386:	d = delta[c = (end += d)[-1]];
    #####: 4387:      if (d)
    #####: 4388:	continue;
    #####: 4389:      beg = end - 1;
    #####: 4390:      trie = next[c];
    #####: 4391:      if (trie->accepting)
        -: 4392:	{
    #####: 4393:	  mch = beg;
    #####: 4394:	  accept = trie;
        -: 4395:	}
    #####: 4396:      d = trie->shift;
    #####: 4397:      while (beg > text)
        -: 4398:	{
    #####: 4399:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
    #####: 4400:	  tree = trie->links;
    #####: 4401:	  while (tree && c != tree->label)
    #####: 4402:	    if (c < tree->label)
    #####: 4403:	      tree = tree->llink;
        -: 4404:	    else
    #####: 4405:	      tree = tree->rlink;
    #####: 4406:	  if (tree)
        -: 4407:	    {
    #####: 4408:	      trie = tree->trie;
    #####: 4409:	      if (trie->accepting)
        -: 4410:		{
    #####: 4411:		  mch = beg;
    #####: 4412:		  accept = trie;
        -: 4413:		}
        -: 4414:	    }
        -: 4415:	  else
    #####: 4416:	    break;
    #####: 4417:	  d = trie->shift;
        -: 4418:	}
    #####: 4419:      if (mch)
    #####: 4420:	goto match;
        -: 4421:    }
    #####: 4422:  return 0;
        -: 4423:
    #####: 4424: match:
        -: 4425:  /* Given a known match, find the longest possible match anchored
        -: 4426:     at or before its starting point.  This is nearly a verbatim
        -: 4427:     copy of the preceding main search loops. */
    #####: 4428:  if (lim - mch > kwset->maxd)
    #####: 4429:    lim = mch + kwset->maxd;
    #####: 4430:  lmch = 0;
    #####: 4431:  d = 1;
    #####: 4432:  while (lim - end >= d)
        -: 4433:    {
    #####: 4434:      if ((d = delta[c = (end += d)[-1]]) != 0)
    #####: 4435:	continue;
    #####: 4436:      beg = end - 1;
    #####: 4437:      if (!(trie = next[c]))
        -: 4438:	{
    #####: 4439:	  d = 1;
    #####: 4440:	  continue;
        -: 4441:	}
    #####: 4442:      if (trie->accepting && beg <= mch)
        -: 4443:	{
    #####: 4444:	  lmch = beg;
    #####: 4445:	  accept = trie;
        -: 4446:	}
    #####: 4447:      d = trie->shift;
    #####: 4448:      while (beg > text)
        -: 4449:	{
    #####: 4450:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
    #####: 4451:	  tree = trie->links;
    #####: 4452:	  while (tree && c != tree->label)
    #####: 4453:	    if (c < tree->label)
    #####: 4454:	      tree = tree->llink;
        -: 4455:	    else
    #####: 4456:	      tree = tree->rlink;
    #####: 4457:	  if (tree)
        -: 4458:	    {
    #####: 4459:	      trie = tree->trie;
    #####: 4460:	      if (trie->accepting && beg <= mch)
        -: 4461:		{
    #####: 4462:		  lmch = beg;
    #####: 4463:		  accept = trie;
        -: 4464:		}
        -: 4465:	    }
        -: 4466:	  else
    #####: 4467:	    break;
    #####: 4468:	  d = trie->shift;
        -: 4469:	}
    #####: 4470:      if (lmch)
        -: 4471:	{
    #####: 4472:	  mch = lmch;
    #####: 4473:	  goto match;
        -: 4474:	}
    #####: 4475:      if (!d)
    #####: 4476:	d = 1;
        -: 4477:    }
        -: 4478:
    #####: 4479:  if (kwsmatch)
        -: 4480:    {
    #####: 4481:      kwsmatch->index = accept->accepting / 2;
    #####: 4482:      kwsmatch->beg[0] = mch;
    #####: 4483:      kwsmatch->size[0] = accept->depth;
        -: 4484:    }
    #####: 4485:  return mch;
        -: 4486:}
        -: 4487:
        -: 4488:/* Search through the given text for a match of any member of the
        -: 4489:   given keyword set.  Return a pointer to the first character of
        -: 4490:   the matching substring, or NULL if no match is found.  If FOUNDLEN
        -: 4491:   is non-NULL store in the referenced location the length of the
        -: 4492:   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
        -: 4493:   in the referenced location the index number of the particular
        -: 4494:   keyword matched. */
        -: 4495:char *
      843: 4496:kwsexec(kws, text, size, kwsmatch)
        -: 4497:     kwset_t kws;
        -: 4498:     char *text;
        -: 4499:     size_t size;
        -: 4500:     struct kwsmatch *kwsmatch;
        -: 4501:{
        -: 4502:  struct kwset *kwset;
        -: 4503:  char *ret;
        -: 4504:
      843: 4505:  kwset = (struct kwset *) kws;
      843: 4506:  if (kwset->words == 1 && kwset->trans == 0)
        -: 4507:    {
      843: 4508:      ret = bmexec(kws, text, size);
      843: 4509:      if (kwsmatch != 0 && ret != 0)
        -: 4510:	{
      832: 4511:	  kwsmatch->index = 0;
      832: 4512:	  kwsmatch->beg[0] = ret;
      832: 4513:	  kwsmatch->size[0] = kwset->mind;
        -: 4514:	}
      843: 4515:      return ret;
        -: 4516:    }
        -: 4517:  else
    #####: 4518:    return cwexec(kws, text, size, kwsmatch);
        -: 4519:}
        -: 4520:
        -: 4521:/* Free the components of the given keyword set. */
        -: 4522:void
    #####: 4523:kwsfree(kws)
        -: 4524:     kwset_t kws;
        -: 4525:{
        -: 4526:  struct kwset *kwset;
        -: 4527:
    #####: 4528:  kwset = (struct kwset *) kws;
    #####: 4529:  obstack_free(&kwset->obstack, 0);
    #####: 4530:  free(kws);
    #####: 4531:}
        -: 4532:/* obstack.h - object stack macros
        -: 4533:   Copyright (C) 1988,89,90,91,92,93,94,96,97, 98 Free Software Foundation, Inc.
        -: 4534:
        -: 4535:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 4536:
        -: 4537:NOTE: The canonical source of this file is maintained with the
        -: 4538:GNU C Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.
        -: 4539:
        -: 4540:This program is free software; you can redistribute it and/or modify it
        -: 4541:under the terms of the GNU General Public License as published by the
        -: 4542:Free Software Foundation; either version 2, or (at your option) any
        -: 4543:later version.
        -: 4544:
        -: 4545:This program is distributed in the hope that it will be useful,
        -: 4546:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4547:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4548:GNU General Public License for more details.
        -: 4549:
        -: 4550:You should have received a copy of the GNU General Public License
        -: 4551:along with this program; if not, write to the Free Software Foundation,
        -: 4552:Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 4553:
        -: 4554:#ifdef HAVE_CONFIG_H
        -: 4555:#if flag_config==0
        -: 4556:#include <config.h>
        -: 4557:#define flag_config 1
        -: 4558:#endif
        -: 4559:#endif
        -: 4560:
        -: 4561:/*#include "obstack.h"*/
        -: 4562:
        -: 4563:/* NOTE BEFORE MODIFYING THIS FILE: This version number must be
        -: 4564:   incremented whenever callers compiled using an old obstack.h can no
        -: 4565:   longer properly call the functions in this obstack.c.  */
        -: 4566:#define OBSTACK_INTERFACE_VERSION 1
        -: 4567:
        -: 4568:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 4569:   actually compiling the library itself, and the installed library
        -: 4570:   supports the same library interface we do.  This code is part of the GNU
        -: 4571:   C Library, but also included in many other GNU distributions.  Compiling
        -: 4572:   and linking in this code is a waste when using the GNU C library
        -: 4573:   (especially if it is a shared library).  Rather than having every GNU
        -: 4574:   program understand `configure --with-gnu-libc' and omit the object
        -: 4575:   files, it is simpler to just do this in the source for each such file.  */
        -: 4576:
        -: 4577:/*#include <stdio.h> */		/* Random thing to get __GNU_LIBRARY__.  */
        -: 4578:#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
        -: 4579:#include <gnu-versions.h>
        -: 4580:#define flag_gnuversions 1
        -: 4581:#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
        -: 4582:#define ELIDE_CODE
        -: 4583:#endif
        -: 4584:#endif
        -: 4585:
        -: 4586:
        -: 4587:#ifndef ELIDE_CODE
        -: 4588:
        -: 4589:
        -: 4590:#if defined (__STDC__) && __STDC__
        -: 4591:#define POINTER void *
        -: 4592:#else
        -: 4593:#define POINTER char *
        -: 4594:#endif
        -: 4595:
        -: 4596:/* Determine default alignment.  */
        -: 4597:struct fooalign {char x; double d;};
        -: 4598:#define DEFAULT_ALIGNMENT  \
        -: 4599:  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))
        -: 4600:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
        -: 4601:   But in fact it might be less smart and round addresses to as much as
        -: 4602:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
        -: 4603:union fooround {long x; double d;};
        -: 4604:#define DEFAULT_ROUNDING (sizeof (union fooround))
        -: 4605:
        -: 4606:/* When we copy a long block of data, this is the unit to do it with.
        -: 4607:   On some machines, copying successive ints does not work;
        -: 4608:   in such a case, redefine COPYING_UNIT to `long' (if that works)
        -: 4609:   or `char' as a last resort.  */
        -: 4610:#ifndef COPYING_UNIT
        -: 4611:#define COPYING_UNIT int
        -: 4612:#endif
        -: 4613:
        -: 4614:
        -: 4615:/* The functions allocating more room by calling `obstack_chunk_alloc'
        -: 4616:   jump to the handler pointed to by `obstack_alloc_failed_handler'.
        -: 4617:   This variable by default points to the internal function
        -: 4618:   `print_and_abort'.  */
        -: 4619:#if defined (__STDC__) && __STDC__
        -: 4620:static void print_and_abort (void);
        -: 4621:void (*obstack_alloc_failed_handler) (void) = print_and_abort;
        -: 4622:#else
        -: 4623:static void print_and_abort ();
        -: 4624:void (*obstack_alloc_failed_handler) () = print_and_abort;
        -: 4625:#endif
        -: 4626:
        -: 4627:/* Exit value used when `print_and_abort' is used.  */
        -: 4628:#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H
        -: 4629:#if flag_stdlib==0
        -: 4630:#include <stdlib.h>
        -: 4631:#define flag_stdlib 1
        -: 4632:#endif
        -: 4633:#endif
        -: 4634:#ifndef EXIT_FAILURE
        -: 4635:#define EXIT_FAILURE 1
        -: 4636:#endif
        -: 4637:int obstack_exit_failure = EXIT_FAILURE;
        -: 4638:
        -: 4639:/* The non-GNU-C macros copy the obstack into this global variable
        -: 4640:   to avoid multiple evaluation.  */
        -: 4641:
        -: 4642:struct obstack *_obstack;
        -: 4643:
        -: 4644:/* Define a macro that either calls functions with the traditional malloc/free
        -: 4645:   calling interface, or calls functions with the mmalloc/mfree interface
        -: 4646:   (that adds an extra first argument), based on the state of use_extra_arg.
        -: 4647:   For free, do not use ?:, since some compilers, like the MIPS compilers,
        -: 4648:   do not allow (expr) ? void : void.  */
        -: 4649:
        -: 4650:#if defined (__STDC__) && __STDC__
        -: 4651:#define CALL_CHUNKFUN(h, size) \
        -: 4652:  (((h) -> use_extra_arg) \
        -: 4653:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 4654:   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
        -: 4655:
        -: 4656:#define CALL_FREEFUN(h, old_chunk) \
        -: 4657:  do { \
        -: 4658:    if ((h) -> use_extra_arg) \
        -: 4659:      obstack_chunk_free((h)->extra_arg/*, (old_chunk)*/); \
        -: 4660:    else \
        -: 4661:     obstack_chunk_free((old_chunk)); \
        -: 4662:  } while (0)
        -: 4663:
        -: 4664:#define CALL_FREEFUN(h, old_chunk) \
        -: 4665:  do { \
        -: 4666:      free ((old_chunk)); \
        -: 4667:  } while (0)
        -: 4668:
        -: 4669:/*
        -: 4670:#define CALL_FREEFUN(h, old_chunk) \
        -: 4671:  do { \
        -: 4672:    if ((h) -> use_extra_arg) \
        -: 4673:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 4674:    else \
        -: 4675:      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
        -: 4676:  } while (0)
        -: 4677:*/
        -: 4678:#else
        -: 4679:#define CALL_CHUNKFUN(h, size) \
        -: 4680:  (((h) -> use_extra_arg) \
        -: 4681:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 4682:   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
        -: 4683:
        -: 4684:#define CALL_FREEFUN(h, old_chunk) \
        -: 4685:  do { \
        -: 4686:    if ((h) -> use_extra_arg) \
        -: 4687:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 4688:    else \
        -: 4689:      (*(void (*) ()) (h)->freefun) ((old_chunk)); \
        -: 4690:  } while (0)
        -: 4691:#endif
        -: 4692:
        -: 4693:
        -: 4694:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
        -: 4695:   Objects start on multiples of ALIGNMENT (0 means use default).
        -: 4696:   CHUNKFUN is the function to use to allocate chunks,
        -: 4697:   and FREEFUN the function to free them.
        -: 4698:
        -: 4699:   Return nonzero if successful, zero if out of memory.
        -: 4700:   To recover from an out of memory error,
        -: 4701:   free up some memory, then call this again.  */
        -: 4702:
        -: 4703:int
        -: 4704:_obstack_begin (h, size, alignment, chunkfun, freefun)
        -: 4705:     struct obstack *h;
        -: 4706:     int size;
        -: 4707:     int alignment;
        -: 4708:#if defined (__STDC__) && __STDC__
        -: 4709:     POINTER (*chunkfun) (long);
        -: 4710:     void (*freefun) (void *);
        -: 4711:#else
        -: 4712:     POINTER (*chunkfun) ();
        -: 4713:     void (*freefun) ();
        -: 4714:#endif
        -: 4715:{
        -: 4716:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 4717:
        -: 4718:  if (alignment == 0)
        -: 4719:    alignment = (int) DEFAULT_ALIGNMENT;
        -: 4720:  if (size == 0)
        -: 4721:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 4722:    {
        -: 4723:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 4724:	 Use the values for range checking, because if range checking is off,
        -: 4725:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 4726:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 4727:	 allocated.
        -: 4728:
        -: 4729:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 4730:	 less sensitive to the size of the request.  */
        -: 4731:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 4732:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 4733:		   & ~(DEFAULT_ROUNDING - 1));
        -: 4734:      size = 4096 - extra;
        -: 4735:    }
        -: 4736:
        -: 4737:#if defined (__STDC__) && __STDC__
        -: 4738:  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
        -: 4739:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 4740:#else
        -: 4741:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 4742:  h->freefun = freefun;
        -: 4743:#endif
        -: 4744:  h->chunk_size = size;
        -: 4745:  h->alignment_mask = alignment - 1;
        -: 4746:  h->use_extra_arg = 0;
        -: 4747:
        -: 4748:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 4749:  if (!chunk)
        -: 4750:    (*obstack_alloc_failed_handler) ();
        -: 4751:  h->next_free = h->object_base = chunk->contents;
        -: 4752:  h->chunk_limit = chunk->limit
        -: 4753:    = (char *) chunk + h->chunk_size;
        -: 4754:  chunk->prev = 0;
        -: 4755:  /* The initial chunk now contains no empty object.  */
        -: 4756:  h->maybe_empty_object = 0;
        -: 4757:  h->alloc_failed = 0;
        -: 4758:  return 1;
        -: 4759:}
        -: 4760:
        -: 4761:int
        -: 4762:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
        -: 4763:     struct obstack *h;
        -: 4764:     int size;
        -: 4765:     int alignment;
        -: 4766:#if defined (__STDC__) && __STDC__
        -: 4767:     POINTER (*chunkfun) (POINTER, long);
        -: 4768:     void (*freefun) (POINTER, POINTER);
        -: 4769:#else
        -: 4770:     POINTER (*chunkfun) ();
        -: 4771:     void (*freefun) ();
        -: 4772:#endif
        -: 4773:     POINTER arg;
        -: 4774:{
        -: 4775:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 4776:
        -: 4777:  if (alignment == 0)
        -: 4778:    alignment = (int) DEFAULT_ALIGNMENT;
        -: 4779:  if (size == 0)
        -: 4780:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 4781:    {
        -: 4782:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 4783:	 Use the values for range checking, because if range checking is off,
        -: 4784:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 4785:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 4786:	 allocated.
        -: 4787:
        -: 4788:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 4789:	 less sensitive to the size of the request.  */
        -: 4790:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 4791:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 4792:		   & ~(DEFAULT_ROUNDING - 1));
        -: 4793:      size = 4096 - extra;
        -: 4794:    }
        -: 4795:
        -: 4796:#if defined(__STDC__) && __STDC__
        -: 4797:  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
        -: 4798:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 4799:#else
        -: 4800:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 4801:  h->freefun = freefun;
        -: 4802:#endif
        -: 4803:  h->chunk_size = size;
        -: 4804:  h->alignment_mask = alignment - 1;
        -: 4805:  h->extra_arg = arg;
        -: 4806:  h->use_extra_arg = 1;
        -: 4807:
        -: 4808:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 4809:  if (!chunk)
        -: 4810:    (*obstack_alloc_failed_handler) ();
        -: 4811:  h->next_free = h->object_base = chunk->contents;
        -: 4812:  h->chunk_limit = chunk->limit
        -: 4813:    = (char *) chunk + h->chunk_size;
        -: 4814:  chunk->prev = 0;
        -: 4815:  /* The initial chunk now contains no empty object.  */
        -: 4816:  h->maybe_empty_object = 0;
        -: 4817:  h->alloc_failed = 0;
        -: 4818:  return 1;
        -: 4819:}
        -: 4820:
        -: 4821:/* Allocate a new current chunk for the obstack *H
        -: 4822:   on the assumption that LENGTH bytes need to be added
        -: 4823:   to the current object, or a new object of length LENGTH allocated.
        -: 4824:   Copies any partial object from the end of the old chunk
        -: 4825:   to the beginning of the new one.  */
        -: 4826:
        -: 4827:void
        -: 4828:_obstack_newchunk (h, length)
        -: 4829:     struct obstack *h;
        -: 4830:     int length;
        -: 4831:{
        -: 4832:  register struct _obstack_chunk *old_chunk = h->chunk;
        -: 4833:  register struct _obstack_chunk *new_chunk;
        -: 4834:  register long	new_size;
        -: 4835:  register long obj_size = h->next_free - h->object_base;
        -: 4836:  register long i;
        -: 4837:  long already;
        -: 4838:
        -: 4839:  /* Compute size for new chunk.  */
        -: 4840:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
        -: 4841:  if (new_size < h->chunk_size)
        -: 4842:    new_size = h->chunk_size;
        -: 4843:
        -: 4844:  /* Allocate and initialize the new chunk.  */
        -: 4845:  #ifndef FAULTY_F_DG_1
        -: 4846:  new_chunk = CALL_CHUNKFUN (h, new_size);
        -: 4847:  if (!new_chunk)
        -: 4848:    (*obstack_alloc_failed_handler) ();
        -: 4849:  h->chunk = new_chunk;
        -: 4850:  #else
        -: 4851:  new_chunk = CALL_CHUNKFUN (h, new_size);
        -: 4852:  if (new_chunk)
        -: 4853:    (*obstack_alloc_failed_handler) ();
        -: 4854:  h->chunk = new_chunk;
        -: 4855:  #endif
        -: 4856:  new_chunk->prev = old_chunk;
        -: 4857:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
        -: 4858:
        -: 4859:  /* Move the existing object to the new chunk.
        -: 4860:     Word at a time is fast and is safe if the object
        -: 4861:     is sufficiently aligned.  */
        -: 4862:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
        -: 4863:    {
        -: 4864:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
        -: 4865:	   i >= 0; i--)
        -: 4866:	((COPYING_UNIT *)new_chunk->contents)[i]
        -: 4867:	  = ((COPYING_UNIT *)h->object_base)[i];
        -: 4868:      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
        -: 4869:	 but that can cross a page boundary on a machine
        -: 4870:	 which does not do strict alignment for COPYING_UNITS.  */
        -: 4871:      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
        -: 4872:    }
        -: 4873:  else
        -: 4874:    already = 0;
        -: 4875:  /* Copy remaining bytes one by one.  */
        -: 4876:  for (i = already; i < obj_size; i++)
        -: 4877:    new_chunk->contents[i] = h->object_base[i];
        -: 4878:
        -: 4879:  /* If the object just copied was the only data in OLD_CHUNK,
        -: 4880:     free that chunk and remove it from the chain.
        -: 4881:     But not if that chunk might contain an empty object.  */
        -: 4882:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
        -: 4883:    {
        -: 4884:      new_chunk->prev = old_chunk->prev;
        -: 4885:      CALL_FREEFUN (h, old_chunk);
        -: 4886:    }
        -: 4887:
        -: 4888:  h->object_base = new_chunk->contents;
        -: 4889:  h->next_free = h->object_base + obj_size;
        -: 4890:  /* The new chunk certainly contains no empty object yet.  */
        -: 4891:  h->maybe_empty_object = 0;
        -: 4892:}
        -: 4893:
        -: 4894:/* Return nonzero if object OBJ has been allocated from obstack H.
        -: 4895:   This is here for debugging.
        -: 4896:   If you use it in a program, you are probably losing.  */
        -: 4897:
        -: 4898:#if defined (__STDC__) && __STDC__
        -: 4899:/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
        -: 4900:   obstack.h because it is just for debugging.  */
        -: 4901:int _obstack_allocated_p (struct obstack *h, POINTER obj);
        -: 4902:#endif
        -: 4903:
        -: 4904:int
        -: 4905:_obstack_allocated_p (h, obj)
        -: 4906:     struct obstack *h;
        -: 4907:     POINTER obj;
        -: 4908:{
        -: 4909:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4910:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4911:
        -: 4912:  lp = (h)->chunk;
        -: 4913:  /* We use >= rather than > since the object cannot be exactly at
        -: 4914:     the beginning of the chunk but might be an empty object exactly
        -: 4915:     at the end of an adjacent chunk.  */
        -: 4916:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4917:    {
        -: 4918:      plp = lp->prev;
        -: 4919:      lp = plp;
        -: 4920:    }
        -: 4921:  return lp != 0;
        -: 4922:}
        -: 4923:
        -: 4924:/* Free objects in obstack H, including OBJ and everything allocate
        -: 4925:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
        -: 4926:
        -: 4927:#undef obstack_free
        -: 4928:
        -: 4929:/* This function has two names with identical definitions.
        -: 4930:   This is the first one, called from non-ANSI code.  */
        -: 4931:
        -: 4932:void
        -: 4933:_obstack_free (h, obj)
        -: 4934:     struct obstack *h;
        -: 4935:     POINTER obj;
        -: 4936:{
        -: 4937:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4938:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4939:
        -: 4940:  lp = h->chunk;
        -: 4941:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 4942:     But there can be an empty object at that address
        -: 4943:     at the end of another chunk.  */
        -: 4944:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4945:    {
        -: 4946:      plp = lp->prev;
        -: 4947:      CALL_FREEFUN (h, lp);
        -: 4948:      lp = plp;
        -: 4949:      /* If we switch chunks, we can't tell whether the new current
        -: 4950:	 chunk contains an empty object, so assume that it may.  */
        -: 4951:      h->maybe_empty_object = 1;
        -: 4952:    }
        -: 4953:  if (lp)
        -: 4954:    {
        -: 4955:      h->object_base = h->next_free = (char *) (obj);
        -: 4956:      h->chunk_limit = lp->limit;
        -: 4957:      h->chunk = lp;
        -: 4958:    }
        -: 4959:  else if (obj != 0)
        -: 4960:    /* obj is not in any of the chunks! */
        -: 4961:    abort ();
        -: 4962:}
        -: 4963:
        -: 4964:/* This function is used from ANSI code.  */
        -: 4965:
        -: 4966:void
        -: 4967:obstack_free (h, obj)
        -: 4968:     struct obstack *h;
        -: 4969:     POINTER obj;
        -: 4970:{
        -: 4971:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 4972:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 4973:
        -: 4974:  lp = h->chunk;
        -: 4975:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 4976:     But there can be an empty object at that address
        -: 4977:     at the end of another chunk.  */
        -: 4978:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 4979:    {
        -: 4980:      plp = lp->prev;
        -: 4981:      CALL_FREEFUN (h, lp);
        -: 4982:      lp = plp;
        -: 4983:      /* If we switch chunks, we can't tell whether the new current
        -: 4984:	 chunk contains an empty object, so assume that it may.  */
        -: 4985:      h->maybe_empty_object = 1;
        -: 4986:    }
        -: 4987:  if (lp)
        -: 4988:    {
        -: 4989:      h->object_base = h->next_free = (char *) (obj);
        -: 4990:      h->chunk_limit = lp->limit;
        -: 4991:      h->chunk = lp;
        -: 4992:    }
        -: 4993:  else if (obj != 0)
        -: 4994:    /* obj is not in any of the chunks! */
        -: 4995:    abort ();
        -: 4996:}
        -: 4997:
        -: 4998:int
        -: 4999:_obstack_memory_used (h)
        -: 5000:     struct obstack *h;
        -: 5001:{
        -: 5002:  register struct _obstack_chunk* lp;
        -: 5003:  register int nbytes = 0;
        -: 5004:
        -: 5005:  for (lp = h->chunk; lp != 0; lp = lp->prev)
        -: 5006:    {
        -: 5007:      nbytes += lp->limit - (char *) lp;
        -: 5008:    }
        -: 5009:  return nbytes;
        -: 5010:}
        -: 5011:
        -: 5012:/* Define the error handler.  */
        -: 5013:#ifndef _
        -: 5014:# ifdef HAVE_LIBINTL_H
        -: 5015:#if flag_libintl==0
        -: 5016:#  include <libintl.h>
        -: 5017:#define flag_libintl 1
        -: 5018:#endif
        -: 5019:#  ifndef _
        -: 5020:#   define _(Str) gettext (Str)
        -: 5021:#  endif
        -: 5022:# else
        -: 5023:#  define _(Str) (Str)
        -: 5024:# endif
        -: 5025:#endif
        -: 5026:
        -: 5027:static void
        -: 5028:print_and_abort ()
        -: 5029:{
        -: 5030:  fputs (_("memory exhausted\n"), stderr);
        -: 5031:  exit (obstack_exit_failure);
        -: 5032:}
        -: 5033:
        -: 5034:#if 0
        -: 5035:/* These are now turned off because the applications do not use it
        -: 5036:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
        -: 5037:
        -: 5038:/* Now define the functional versions of the obstack macros.
        -: 5039:   Define them to simply use the corresponding macros to do the job.  */
        -: 5040:
        -: 5041:#if defined (__STDC__) && __STDC__
        -: 5042:/* These function definitions do not work with non-ANSI preprocessors;
        -: 5043:   they won't pass through the macro names in parentheses.  */
        -: 5044:
        -: 5045:/* The function names appear in parentheses in order to prevent
        -: 5046:   the macro-definitions of the names from being expanded there.  */
        -: 5047:
        -: 5048:POINTER (obstack_base) (obstack)
        -: 5049:     struct obstack *obstack;
        -: 5050:{
        -: 5051:  return obstack_base (obstack);
        -: 5052:}
        -: 5053:
        -: 5054:POINTER (obstack_next_free) (obstack)
        -: 5055:     struct obstack *obstack;
        -: 5056:{
        -: 5057:  return obstack_next_free (obstack);
        -: 5058:}
        -: 5059:
        -: 5060:int (obstack_object_size) (obstack)
        -: 5061:     struct obstack *obstack;
        -: 5062:{
        -: 5063:  return obstack_object_size (obstack);
        -: 5064:}
        -: 5065:
        -: 5066:int (obstack_room) (obstack)
        -: 5067:     struct obstack *obstack;
        -: 5068:{
        -: 5069:  return obstack_room (obstack);
        -: 5070:}
        -: 5071:
        -: 5072:int (obstack_make_room) (obstack, length)
        -: 5073:     struct obstack *obstack;
        -: 5074:     int length;
        -: 5075:{
        -: 5076:  return obstack_make_room (obstack, length);
        -: 5077:}
        -: 5078:
        -: 5079:void (obstack_grow) (obstack, pointer, length)
        -: 5080:     struct obstack *obstack;
        -: 5081:     POINTER pointer;
        -: 5082:     int length;
        -: 5083:{
        -: 5084:  obstack_grow (obstack, pointer, length);
        -: 5085:}
        -: 5086:
        -: 5087:void (obstack_grow0) (obstack, pointer, length)
        -: 5088:     struct obstack *obstack;
        -: 5089:     POINTER pointer;
        -: 5090:     int length;
        -: 5091:{
        -: 5092:  obstack_grow0 (obstack, pointer, length);
        -: 5093:}
        -: 5094:
        -: 5095:void (obstack_1grow) (obstack, character)
        -: 5096:     struct obstack *obstack;
        -: 5097:     int character;
        -: 5098:{
        -: 5099:  obstack_1grow (obstack, character);
        -: 5100:}
        -: 5101:
        -: 5102:void (obstack_blank) (obstack, length)
        -: 5103:     struct obstack *obstack;
        -: 5104:     int length;
        -: 5105:{
        -: 5106:  obstack_blank (obstack, length);
        -: 5107:}
        -: 5108:
        -: 5109:void (obstack_1grow_fast) (obstack, character)
        -: 5110:     struct obstack *obstack;
        -: 5111:     int character;
        -: 5112:{
        -: 5113:  obstack_1grow_fast (obstack, character);
        -: 5114:}
        -: 5115:
        -: 5116:void (obstack_blank_fast) (obstack, length)
        -: 5117:     struct obstack *obstack;
        -: 5118:     int length;
        -: 5119:{
        -: 5120:  obstack_blank_fast (obstack, length);
        -: 5121:}
        -: 5122:
        -: 5123:POINTER (obstack_finish) (obstack)
        -: 5124:     struct obstack *obstack;
        -: 5125:{
        -: 5126:  return obstack_finish (obstack);
        -: 5127:}
        -: 5128:
        -: 5129:POINTER (obstack_alloc) (obstack, length)
        -: 5130:     struct obstack *obstack;
        -: 5131:     int length;
        -: 5132:{
        -: 5133:  return obstack_alloc (obstack, length);
        -: 5134:}
        -: 5135:
        -: 5136:POINTER (obstack_copy) (obstack, pointer, length)
        -: 5137:     struct obstack *obstack;
        -: 5138:     POINTER pointer;
        -: 5139:     int length;
        -: 5140:{
        -: 5141:  return obstack_copy (obstack, pointer, length);
        -: 5142:}
        -: 5143:
        -: 5144:POINTER (obstack_copy0) (obstack, pointer, length)
        -: 5145:     struct obstack *obstack;
        -: 5146:     POINTER pointer;
        -: 5147:     int length;
        -: 5148:{
        -: 5149:  return obstack_copy0 (obstack, pointer, length);
        -: 5150:}
        -: 5151:
        -: 5152:#endif /* __STDC__ */
        -: 5153:
        -: 5154:#endif /* 0 */
        -: 5155:
        -: 5156:#endif	/* !ELIDE_CODE */
        -: 5157:/* Getopt for GNU.
        -: 5158:   NOTE: getopt is now part of the C library, so if you don't know what
        -: 5159:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
        -: 5160:   before changing it!
        -: 5161:
        -: 5162:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97
        -: 5163:   	Free Software Foundation, Inc.
        -: 5164:
        -: 5165:   This file is part of the GNU C Library.  Its master source is NOT part of
        -: 5166:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 5167:
        -: 5168:   The GNU C Library is free software; you can redistribute it and/or
        -: 5169:   modify it under the terms of the GNU Library General Public License as
        -: 5170:   published by the Free Software Foundation; either version 2 of the
        -: 5171:   License, or (at your option) any later version.
        -: 5172:
        -: 5173:   The GNU C Library is distributed in the hope that it will be useful,
        -: 5174:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5175:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 5176:   Library General Public License for more details.
        -: 5177:
        -: 5178:   You should have received a copy of the GNU Library General Public
        -: 5179:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 5180:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 5181:   Boston, MA 02111-1307, USA.  */
        -: 5182:
        -: 5183:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 5184:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 5185:#ifndef _NO_PROTO
        -: 5186:#define _NO_PROTO
        -: 5187:#endif
        -: 5188:
        -: 5189:#ifdef HAVE_CONFIG_H
        -: 5190:#if flag_config==0
        -: 5191:#include <config.h>
        -: 5192:#define flag_config 1
        -: 5193:#endif
        -: 5194:#endif
        -: 5195:
        -: 5196:#if !defined (__STDC__) || !__STDC__
        -: 5197:/* This is a separate conditional since some stdc systems
        -: 5198:   reject `defined (const)'.  */
        -: 5199:#ifndef const
        -: 5200:#define const
        -: 5201:#endif
        -: 5202:#endif
        -: 5203:
        -: 5204:/*#include <stdio.h> */
        -: 5205:
        -: 5206:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 5207:   actually compiling the library itself.  This code is part of the GNU C
        -: 5208:   Library, but also included in many other GNU distributions.  Compiling
        -: 5209:   and linking in this code is a waste when using the GNU C library
        -: 5210:   (especially if it is a shared library).  Rather than having every GNU
        -: 5211:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 5212:   it is simpler to just do this in the source for each such file.  */
        -: 5213:
        -: 5214:#define GETOPT_INTERFACE_VERSION 2
        -: 5215:#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2
        -: 5216:#if flag_gnuversions==0
        -: 5217:#include <gnu-versions.h>
        -: 5218:#define flag_gnu-versions 1
        -: 5219:#endif
        -: 5220:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 5221:#define ELIDE_CODE
        -: 5222:#endif
        -: 5223:#endif
        -: 5224:
        -: 5225:#ifndef ELIDE_CODE
        -: 5226:
        -: 5227:
        -: 5228:/* This needs to come after some library #include
        -: 5229:   to get __GNU_LIBRARY__ defined.  */
        -: 5230:#ifdef	__GNU_LIBRARY__
        -: 5231:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 5232:   contain conflicting prototypes for getopt.  */
        -: 5233:#if flag_stdlib==0   
        -: 5234:#include <stdlib.h>
        -: 5235:#define flag_stdlib 1
        -: 5236:#endif
        -: 5237:#include <unistd.h>
        -: 5238:#endif	/* GNU C library.  */
        -: 5239:
        -: 5240:#ifdef VMS
        -: 5241:#include <unixlib.h>
        -: 5242:#if HAVE_STRING_H - 0
        -: 5243:#if flag_string==0
        -: 5244:#include <string.h>
        -: 5245:#define flag_string 1
        -: 5246:#endif
        -: 5247:#endif
        -: 5248:#endif
        -: 5249:
        -: 5250:#if defined (WIN32) && !defined (__CYGWIN32__)
        -: 5251:/* It's not Unix, really.  See?  Capital letters.  */
        -: 5252:#include <windows.h>
        -: 5253:#define getpid() GetCurrentProcessId()
        -: 5254:#endif
        -: 5255:
        -: 5256:#ifndef _
        -: 5257:/* This is for other GNU distributions with internationalized messages.
        -: 5258:   When compiling libc, the _ macro is predefined.  */
        -: 5259:#ifdef HAVE_LIBINTL_H
        -: 5260:#if flag_libintl==0
        -: 5261:# include <libintl.h>
        -: 5262:#define flag_libintl 1
        -: 5263:#endif
        -: 5264:# define _(msgid)	gettext (msgid)
        -: 5265:#else
        -: 5266:# define _(msgid)	(msgid)
        -: 5267:#endif
        -: 5268:#endif
        -: 5269:
        -: 5270:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 5271:   but it behaves differently for the user, since it allows the user
        -: 5272:   to intersperse the options with the other arguments.
        -: 5273:
        -: 5274:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 5275:   when it is done, all the options precede everything else.  Thus
        -: 5276:   all application programs are extended to handle flexible argument order.
        -: 5277:
        -: 5278:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 5279:   Then the behavior is completely standard.
        -: 5280:
        -: 5281:   GNU application programs can use a third alternative mode in which
        -: 5282:   they can distinguish the relative order of options and other arguments.  */
        -: 5283:
        -: 5284:/*#include "getopt.h" */
        -: 5285:
        -: 5286:/* For communication from `getopt' to the caller.
        -: 5287:   When `getopt' finds an option that takes an argument,
        -: 5288:   the argument value is returned here.
        -: 5289:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 5290:   each non-option ARGV-element is returned here.  */
        -: 5291:
        -: 5292:char *optarg = NULL;
        -: 5293:
        -: 5294:/* Index in ARGV of the next element to be scanned.
        -: 5295:   This is used for communication to and from the caller
        -: 5296:   and for communication between successive calls to `getopt'.
        -: 5297:
        -: 5298:   On entry to `getopt', zero means this is the first call; initialize.
        -: 5299:
        -: 5300:   When `getopt' returns -1, this is the index of the first of the
        -: 5301:   non-option elements that the caller should itself scan.
        -: 5302:
        -: 5303:   Otherwise, `optind' communicates from one call to the next
        -: 5304:   how much of ARGV has been scanned so far.  */
        -: 5305:
        -: 5306:/* 1003.2 says this must be 1 before any call.  */
        -: 5307:int optind = 1;
        -: 5308:
        -: 5309:/* Formerly, initialization of getopt depended on optind==0, which
        -: 5310:   causes problems with re-calling getopt as programs generally don't
        -: 5311:   know that. */
        -: 5312:
        -: 5313:int __getopt_initialized = 0;
        -: 5314:
        -: 5315:/* The next char to be scanned in the option-element
        -: 5316:   in which the last option character we returned was found.
        -: 5317:   This allows us to pick up the scan where we left off.
        -: 5318:
        -: 5319:   If this is zero, or a null string, it means resume the scan
        -: 5320:   by advancing to the next ARGV-element.  */
        -: 5321:
        -: 5322:static char *nextchar;
        -: 5323:
        -: 5324:/* Callers store zero here to inhibit the error message
        -: 5325:   for unrecognized options.  */
        -: 5326:
        -: 5327:int opterr = 1;
        -: 5328:
        -: 5329:/* Set to an option character which was unrecognized.
        -: 5330:   This must be initialized on some systems to avoid linking in the
        -: 5331:   system's own getopt implementation.  */
        -: 5332:
        -: 5333:int optopt = '?';
        -: 5334:
        -: 5335:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 5336:
        -: 5337:   If the caller did not specify anything,
        -: 5338:   the default is REQUIRE_ORDER if the environment variable
        -: 5339:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 5340:
        -: 5341:   REQUIRE_ORDER means don't recognize them as options;
        -: 5342:   stop option processing when the first non-option is seen.
        -: 5343:   This is what Unix does.
        -: 5344:   This mode of operation is selected by either setting the environment
        -: 5345:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 5346:   of the list of option characters.
        -: 5347:
        -: 5348:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 5349:   so that eventually all the non-options are at the end.  This allows options
        -: 5350:   to be given in any order, even with programs that were not written to
        -: 5351:   expect this.
        -: 5352:
        -: 5353:   RETURN_IN_ORDER is an option available to programs that were written
        -: 5354:   to expect options and other ARGV-elements in any order and that care about
        -: 5355:   the ordering of the two.  We describe each non-option ARGV-element
        -: 5356:   as if it were the argument of an option with character code 1.
        -: 5357:   Using `-' as the first character of the list of option characters
        -: 5358:   selects this mode of operation.
        -: 5359:
        -: 5360:   The special argument `--' forces an end of option-scanning regardless
        -: 5361:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 5362:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 5363:
        -: 5364:static enum
        -: 5365:{
        -: 5366:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 5367:} ordering;
        -: 5368:
        -: 5369:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 5370:static char *posixly_correct;
        -: 5371:
        -: 5372:#ifdef	__GNU_LIBRARY__
        -: 5373:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 5374:   because there are many ways it can cause trouble.
        -: 5375:   On some systems, it contains special magic macros that don't work
        -: 5376:   in GCC.  */
        -: 5377:#if flag_string==0
        -: 5378:#include <string.h>
        -: 5379:#define flag_string 1
        -: 5380:#endif
        -: 5381:#define	my_index	strchr
        -: 5382:#else
        -: 5383:
        -: 5384:/* Avoid depending on library functions or files
        -: 5385:   whose names are inconsistent.  */
        -: 5386:
        -: 5387:char *getenv ();
        -: 5388:
        -: 5389:static char *
        -: 5390:my_index (str, chr)
        -: 5391:     const char *str;
        -: 5392:     int chr;
        -: 5393:{
        -: 5394:  while (*str)
        -: 5395:    {
        -: 5396:      if (*str == chr)
        -: 5397:	return (char *) str;
        -: 5398:      str++;
        -: 5399:    }
        -: 5400:  return 0;
        -: 5401:}
        -: 5402:
        -: 5403:/* If using GCC, we can safely declare strlen this way.
        -: 5404:   If not using GCC, it is ok not to declare it.  */
        -: 5405:#ifdef __GNUC__
        -: 5406:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 5407:   That was relevant to code that was here before.  */
        -: 5408:#if !defined (__STDC__) || !__STDC__
        -: 5409:/* gcc with -traditional declares the built-in strlen to return int,
        -: 5410:   and has done so at least since version 2.4.5. -- rms.  */
        -: 5411:extern int strlen (const char *);
        -: 5412:#endif /* not __STDC__ */
        -: 5413:#endif /* __GNUC__ */
        -: 5414:
        -: 5415:#endif /* not __GNU_LIBRARY__ */
        -: 5416:
        -: 5417:/* Handle permutation of arguments.  */
        -: 5418:
        -: 5419:/* Describe the part of ARGV that contains non-options that have
        -: 5420:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 5421:   `last_nonopt' is the index after the last of them.  */
        -: 5422:
        -: 5423:static int first_nonopt;
        -: 5424:static int last_nonopt;
        -: 5425:
        -: 5426:#ifdef _LIBC
        -: 5427:/* Bash 2.0 gives us an environment variable containing flags
        -: 5428:   indicating ARGV elements that should not be considered arguments.  */
        -: 5429:
        -: 5430:static const char *nonoption_flags;
        -: 5431:static int nonoption_flags_len;
        -: 5432:
        -: 5433:static int original_argc;
        -: 5434:static char *const *original_argv;
        -: 5435:
        -: 5436:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 5437:   is valid for the getopt call we must make sure that the ARGV passed
        -: 5438:   to getopt is that one passed to the process.  */
        -: 5439:static void store_args (int argc, char *const *argv) __attribute__ ((unused));
        -: 5440:static void
        -: 5441:store_args (int argc, char *const *argv)
        -: 5442:{
        -: 5443:  /* XXX This is no good solution.  We should rather copy the args so
        -: 5444:     that we can compare them later.  But we must not use malloc(3).  */
        -: 5445:  original_argc = argc;
        -: 5446:  original_argv = argv;
        -: 5447:}
        -: 5448:text_set_element (__libc_subinit, store_args);
        -: 5449:#endif
        -: 5450:
        -: 5451:/* Exchange two adjacent subsequences of ARGV.
        -: 5452:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 5453:   which contains all the non-options that have been skipped so far.
        -: 5454:   The other is elements [last_nonopt,optind), which contains all
        -: 5455:   the options processed since those non-options were skipped.
        -: 5456:
        -: 5457:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 5458:   the new indices of the non-options in ARGV after they are moved.  */
        -: 5459:
        -: 5460:#if defined (__STDC__) && __STDC__
        -: 5461:static void exchange (char **);
        -: 5462:#endif
        -: 5463:
        -: 5464:static void
        -: 5465:exchange (argv)
        -: 5466:     char **argv;
        -: 5467:{
        -: 5468:  int bottom = first_nonopt;
        -: 5469:  int middle = last_nonopt;
        -: 5470:  int top = optind;
        -: 5471:  char *tem;
        -: 5472:
        -: 5473:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 5474:     That puts the shorter segment into the right place.
        -: 5475:     It leaves the longer segment in the right place overall,
        -: 5476:     but it consists of two parts that need to be swapped next.  */
        -: 5477:
        -: 5478:  while (top > middle && middle > bottom)
        -: 5479:    {
        -: 5480:      if (top - middle > middle - bottom)
        -: 5481:	{
        -: 5482:	  /* Bottom segment is the short one.  */
        -: 5483:	  int len = middle - bottom;
        -: 5484:	  register int i;
        -: 5485:
        -: 5486:	  /* Swap it with the top part of the top segment.  */
        -: 5487:	  for (i = 0; i < len; i++)
        -: 5488:	    {
        -: 5489:	      tem = argv[bottom + i];
        -: 5490:              #ifndef FAULTY_F_DG_6 
        -: 5491:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 5492:	      argv[top - (middle - bottom) + i] = tem;
        -: 5493:              #else
        -: 5494:	      argv[bottom + i] = argv[top - middle - bottom + i];
        -: 5495:	      argv[top - middle - bottom + i] = tem;
        -: 5496:              #endif
        -: 5497:	    }
        -: 5498:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 5499:	  top -= len;
        -: 5500:	}
        -: 5501:      else
        -: 5502:	{
        -: 5503:	  /* Top segment is the short one.  */
        -: 5504:	  int len = top - middle;
        -: 5505:	  register int i;
        -: 5506:
        -: 5507:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 5508:	  for (i = 0; i < len; i++)
        -: 5509:	    {
        -: 5510:	      tem = argv[bottom + i];
        -: 5511:	      argv[bottom + i] = argv[middle + i];
        -: 5512:	      argv[middle + i] = tem;
        -: 5513:	    }
        -: 5514:	  /* Exclude the moved top segment from further swapping.  */
        -: 5515:	  bottom += len;
        -: 5516:	}
        -: 5517:    }
        -: 5518:
        -: 5519:  /* Update records for the slots the non-options now occupy.  */
        -: 5520:
        -: 5521:  first_nonopt += (optind - last_nonopt);
        -: 5522:  last_nonopt = optind;
        -: 5523:}
        -: 5524:
        -: 5525:/* Initialize the internal data when the first call is made.  */
        -: 5526:
        -: 5527:#if defined (__STDC__) && __STDC__
        -: 5528:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 5529:#endif
        -: 5530:static const char *
        -: 5531:_getopt_initialize (argc, argv, optstring)
        -: 5532:     int argc;
        -: 5533:     char *const *argv;
        -: 5534:     const char *optstring;
        -: 5535:{
        -: 5536:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 5537:     is the program name); the sequence of previously skipped
        -: 5538:     non-option ARGV-elements is empty.  */
        -: 5539:
        -: 5540:  first_nonopt = last_nonopt = optind = 1;
        -: 5541:
        -: 5542:  nextchar = NULL;
        -: 5543:
        -: 5544:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 5545:
        -: 5546:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 5547:
        -: 5548:  if (optstring[0] == '-')
        -: 5549:    {
        -: 5550:      ordering = RETURN_IN_ORDER;
        -: 5551:      ++optstring;
        -: 5552:    }
        -: 5553:  else if (optstring[0] == '+')
        -: 5554:    {
        -: 5555:      ordering = REQUIRE_ORDER;
        -: 5556:      ++optstring;
        -: 5557:    }
        -: 5558:  else if (posixly_correct != NULL)
        -: 5559:    ordering = REQUIRE_ORDER;
        -: 5560:  else
        -: 5561:    ordering = PERMUTE;
        -: 5562:
        -: 5563:#ifdef _LIBC
        -: 5564:  if (posixly_correct == NULL
        -: 5565:      && argc == original_argc && argv == original_argv)
        -: 5566:    {
        -: 5567:      /* Bash 2.0 puts a special variable in the environment for each
        -: 5568:	 command it runs, specifying which ARGV elements are the results of
        -: 5569:	 file name wildcard expansion and therefore should not be
        -: 5570:	 considered as options.  */
        -: 5571:      char var[100];
        -: 5572:      sprintf (var, "_%d_GNU_nonoption_argv_flags_", getpid ());
        -: 5573:      nonoption_flags = getenv (var);
        -: 5574:      if (nonoption_flags == NULL)
        -: 5575:	nonoption_flags_len = 0;
        -: 5576:      else
        -: 5577:	nonoption_flags_len = strlen (nonoption_flags);
        -: 5578:    }
        -: 5579:  else
        -: 5580:    nonoption_flags_len = 0;
        -: 5581:#endif
        -: 5582:
        -: 5583:  return optstring;
        -: 5584:}
        -: 5585:
        -: 5586:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 5587:   given in OPTSTRING.
        -: 5588:
        -: 5589:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 5590:   then it is an option element.  The characters of this element
        -: 5591:   (aside from the initial '-') are option characters.  If `getopt'
        -: 5592:   is called repeatedly, it returns successively each of the option characters
        -: 5593:   from each of the option elements.
        -: 5594:
        -: 5595:   If `getopt' finds another option character, it returns that character,
        -: 5596:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 5597:   resume the scan with the following option character or ARGV-element.
        -: 5598:
        -: 5599:   If there are no more option characters, `getopt' returns -1.
        -: 5600:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 5601:   that is not an option.  (The ARGV-elements have been permuted
        -: 5602:   so that those that are not options now come last.)
        -: 5603:
        -: 5604:   OPTSTRING is a string containing the legitimate option characters.
        -: 5605:   If an option character is seen that is not listed in OPTSTRING,
        -: 5606:   return '?' after printing an error message.  If you set `opterr' to
        -: 5607:   zero, the error message is suppressed but we still return '?'.
        -: 5608:
        -: 5609:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 5610:   so the following text in the same ARGV-element, or the text of the following
        -: 5611:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 5612:   wants an optional arg; if there is text in the current ARGV-element,
        -: 5613:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 5614:
        -: 5615:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 5616:   handling the non-option ARGV-elements.
        -: 5617:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 5618:
        -: 5619:   Long-named options begin with `--' instead of `-'.
        -: 5620:   Their names may be abbreviated as long as the abbreviation is unique
        -: 5621:   or is an exact match for some defined option.  If they have an
        -: 5622:   argument, it follows the option name in the same ARGV-element, separated
        -: 5623:   from the option name by a `=', or else the in next ARGV-element.
        -: 5624:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 5625:   `flag' field is nonzero, the value of the option's `val' field
        -: 5626:   if the `flag' field is zero.
        -: 5627:
        -: 5628:   The elements of ARGV aren't really const, because we permute them.
        -: 5629:   But we pretend they're const in the prototype to be compatible
        -: 5630:   with other systems.
        -: 5631:
        -: 5632:   LONGOPTS is a vector of `struct option' terminated by an
        -: 5633:   element containing a name which is zero.
        -: 5634:
        -: 5635:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 5636:   It is only valid when a long-named option has been found by the most
        -: 5637:   recent call.
        -: 5638:
        -: 5639:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 5640:   long-named options.  */
        -: 5641:
        -: 5642:int
        -: 5643:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 5644:     int argc;
        -: 5645:     char *const *argv;
        -: 5646:     const char *optstring;
        -: 5647:     const struct option *longopts;
        -: 5648:     int *longind;
        -: 5649:     int long_only;
        -: 5650:{
        -: 5651:  optarg = NULL;
        -: 5652:
        -: 5653:#ifndef FAULTY_F_KP_8
        -: 5654:  if (!__getopt_initialized || optind == 0)
        -: 5655:#else
        -: 5656:  if (optind == 0 && !__getopt_initialized )
        -: 5657:#endif
        -: 5658:    {
        -: 5659:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 5660:      optind = 1;		/* Don't scan ARGV[0], the program name.  */
        -: 5661:      __getopt_initialized = 1;
        -: 5662:    }
        -: 5663:
        -: 5664:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 5665:     Either it does not have option syntax, or there is an environment flag
        -: 5666:     from the shell indicating it is not an option.  The later information
        -: 5667:     is only used when the used in the GNU libc.  */
        -: 5668:#ifdef _LIBC
        -: 5669:#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 5670:		     || (optind < nonoption_flags_len			      \
        -: 5671:			 && nonoption_flags[optind] == '1'))
        -: 5672:#else
        -: 5673:#define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 5674:#endif
        -: 5675:
        -: 5676:  if (nextchar == NULL || *nextchar == '\0')
        -: 5677:    {
        -: 5678:      /* Advance to the next ARGV-element.  */
        -: 5679:
        -: 5680:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 5681:	 moved back by the user (who may also have changed the arguments).  */
        -: 5682:      if (last_nonopt > optind)
        -: 5683:	last_nonopt = optind;
        -: 5684:      if (first_nonopt > optind)
        -: 5685:	first_nonopt = optind;
        -: 5686:
        -: 5687:      if (ordering == PERMUTE)
        -: 5688:	{
        -: 5689:	  /* If we have just processed some options following some non-options,
        -: 5690:	     exchange them so that the options come first.  */
        -: 5691:
        -: 5692:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 5693:	    exchange ((char **) argv);
        -: 5694:	  else if (last_nonopt != optind)
        -: 5695:	    first_nonopt = optind;
        -: 5696:
        -: 5697:	  /* Skip any additional non-options
        -: 5698:	     and extend the range of non-options previously skipped.  */
        -: 5699:
        -: 5700:	  while (optind < argc && NONOPTION_P)
        -: 5701:	    optind++;
        -: 5702:	  last_nonopt = optind;
        -: 5703:	}
        -: 5704:
        -: 5705:      /* The special ARGV-element `--' means premature end of options.
        -: 5706:	 Skip it like a null option,
        -: 5707:	 then exchange with previous non-options as if it were an option,
        -: 5708:	 then skip everything else like a non-option.  */
        -: 5709:
        -: 5710:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 5711:	{
        -: 5712:	  optind++;
        -: 5713:
        -: 5714:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 5715:	    exchange ((char **) argv);
        -: 5716:	  else if (first_nonopt == last_nonopt)
        -: 5717:	    first_nonopt = optind;
        -: 5718:	  last_nonopt = argc;
        -: 5719:
        -: 5720:	  optind = argc;
        -: 5721:	}
        -: 5722:
        -: 5723:      /* If we have done all the ARGV-elements, stop the scan
        -: 5724:	 and back over any non-options that we skipped and permuted.  */
        -: 5725:
        -: 5726:      if (optind == argc)
        -: 5727:	{
        -: 5728:	  /* Set the next-arg-index to point at the non-options
        -: 5729:	     that we previously skipped, so the caller will digest them.  */
        -: 5730:	  if (first_nonopt != last_nonopt)
        -: 5731:	    optind = first_nonopt;
        -: 5732:	  return -1;
        -: 5733:	}
        -: 5734:
        -: 5735:      /* If we have come to a non-option and did not permute it,
        -: 5736:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 5737:
        -: 5738:      if (NONOPTION_P)
        -: 5739:	{
        -: 5740:	  if (ordering == REQUIRE_ORDER)
        -: 5741:	    return -1;
        -: 5742:	  optarg = argv[optind++];
        -: 5743:	  return 1;
        -: 5744:	}
        -: 5745:
        -: 5746:      /* We have found another option-ARGV-element.
        -: 5747:	 Skip the initial punctuation.  */
        -: 5748:
        -: 5749:      nextchar = (argv[optind] + 1
        -: 5750:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 5751:    }
        -: 5752:
        -: 5753:  /* Decode the current option-ARGV-element.  */
        -: 5754:
        -: 5755:  /* Check whether the ARGV-element is a long option.
        -: 5756:
        -: 5757:     If long_only and the ARGV-element has the form "-f", where f is
        -: 5758:     a valid short option, don't consider it an abbreviated form of
        -: 5759:     a long option that starts with f.  Otherwise there would be no
        -: 5760:     way to give the -f short option.
        -: 5761:
        -: 5762:     On the other hand, if there's a long option "fubar" and
        -: 5763:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 5764:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 5765:
        -: 5766:     This distinction seems to be the most useful approach.  */
        -: 5767:
        -: 5768:  if (longopts != NULL
        -: 5769:      && (argv[optind][1] == '-'
        -: 5770:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 5771:    {
        -: 5772:      char *nameend;
        -: 5773:      const struct option *p;
        -: 5774:      const struct option *pfound = NULL;
        -: 5775:      int exact = 0;
        -: 5776:      int ambig = 0;
        -: 5777:      int indfound = -1;
        -: 5778:      int option_index;
        -: 5779:
        -: 5780:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 5781:	/* Do nothing.  */ ;
        -: 5782:
        -: 5783:      /* Test all long options for either exact match
        -: 5784:	 or abbreviated matches.  */
        -: 5785:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 5786:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 5787:	  {
        -: 5788:	    if ((unsigned int) (nameend - nextchar)
        -: 5789:		== (unsigned int) strlen (p->name))
        -: 5790:	      {
        -: 5791:		/* Exact match found.  */
        -: 5792:		pfound = p;
        -: 5793:		indfound = option_index;
        -: 5794:		exact = 1;
        -: 5795:		break;
        -: 5796:	      }
        -: 5797:	    else if (pfound == NULL)
        -: 5798:	      {
        -: 5799:		/* First nonexact match found.  */
        -: 5800:		pfound = p;
        -: 5801:		indfound = option_index;
        -: 5802:	      }
        -: 5803:	    else
        -: 5804:	      /* Second or later nonexact match found.  */
        -: 5805:	      ambig = 1;
        -: 5806:	  }
        -: 5807:
        -: 5808:      if (ambig && !exact)
        -: 5809:	{
        -: 5810:	  if (opterr)
        -: 5811:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 5812:		     argv[0], argv[optind]);
        -: 5813:	  nextchar += strlen (nextchar);
        -: 5814:	  optind++;
        -: 5815:	  optopt = 0;
        -: 5816:	  return '?';
        -: 5817:	}
        -: 5818:
        -: 5819:      if (pfound != NULL)
        -: 5820:	{
        -: 5821:	  option_index = indfound;
        -: 5822:	  optind++;
        -: 5823:	  if (*nameend)
        -: 5824:	    {
        -: 5825:	      /* Don't test has_arg with >, because some C compilers don't
        -: 5826:		 allow it to be used on enums.  */
        -: 5827:	      if (pfound->has_arg)
        -: 5828:		optarg = nameend + 1;
        -: 5829:	      else
        -: 5830:		{
        -: 5831:		  if (opterr)
        -: 5832:		   if (argv[optind - 1][1] == '-')
        -: 5833:		    /* --option */
        -: 5834:		    fprintf (stderr,
        -: 5835:		     _("%s: option `--%s' doesn't allow an argument\n"),
        -: 5836:		     argv[0], pfound->name);
        -: 5837:		   else
        -: 5838:		    /* +option or -option */
        -: 5839:		    fprintf (stderr,
        -: 5840:		     _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 5841:		     argv[0], argv[optind - 1][0], pfound->name);
        -: 5842:
        -: 5843:		  nextchar += strlen (nextchar);
        -: 5844:
        -: 5845:		  optopt = pfound->val;
        -: 5846:		  return '?';
        -: 5847:		}
        -: 5848:	    }
        -: 5849:	  else if (pfound->has_arg == 1)
        -: 5850:	    {
        -: 5851:	      if (optind < argc)
        -: 5852:		optarg = argv[optind++];
        -: 5853:	      else
        -: 5854:		{
        -: 5855:		  if (opterr)
        -: 5856:		    fprintf (stderr,
        -: 5857:			   _("%s: option `%s' requires an argument\n"),
        -: 5858:			   argv[0], argv[optind - 1]);
        -: 5859:		  nextchar += strlen (nextchar);
        -: 5860:		  optopt = pfound->val;
        -: 5861:		  return optstring[0] == ':' ? ':' : '?';
        -: 5862:		}
        -: 5863:	    }
        -: 5864:	  nextchar += strlen (nextchar);
        -: 5865:	  if (longind != NULL)
        -: 5866:	    *longind = option_index;
        -: 5867:	  if (pfound->flag)
        -: 5868:	    {
        -: 5869:	      *(pfound->flag) = pfound->val;
        -: 5870:	      return 0;
        -: 5871:	    }
        -: 5872:	  return pfound->val;
        -: 5873:	}
        -: 5874:
        -: 5875:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 5876:	 or the option starts with '--' or is not a valid short
        -: 5877:	 option, then it's an error.
        -: 5878:	 Otherwise interpret it as a short option.  */
        -: 5879:      if (!long_only || argv[optind][1] == '-'
        -: 5880:	  || my_index (optstring, *nextchar) == NULL)
        -: 5881:	{
        -: 5882:	  if (opterr)
        -: 5883:	    {
        -: 5884:	      if (argv[optind][1] == '-')
        -: 5885:		/* --option */
        -: 5886:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 5887:			 argv[0], nextchar);
        -: 5888:	      else
        -: 5889:		/* +option or -option */
        -: 5890:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 5891:			 argv[0], argv[optind][0], nextchar);
        -: 5892:	    }
        -: 5893:	  nextchar = (char *) "";
        -: 5894:	  optind++;
        -: 5895:	  optopt = 0;
        -: 5896:	  return '?';
        -: 5897:	}
        -: 5898:    }
        -: 5899:
        -: 5900:  /* Look at and handle the next short option-character.  */
        -: 5901:
        -: 5902:  {
        -: 5903:    char c = *nextchar++;
        -: 5904:    char *temp = my_index (optstring, c);
        -: 5905:
        -: 5906:    /* Increment `optind' when we start to process its last character.  */
        -: 5907:    if (*nextchar == '\0')
        -: 5908:      ++optind;
        -: 5909:
        -: 5910:    if (temp == NULL || c == ':')
        -: 5911:      {
        -: 5912:	if (opterr)
        -: 5913:	  {
        -: 5914:	    if (posixly_correct)
        -: 5915:	      /* 1003.2 specifies the format of this message.  */
        -: 5916:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 5917:		       argv[0], c);
        -: 5918:	    else
        -: 5919:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 5920:		       argv[0], c);
        -: 5921:	  }
        -: 5922:	optopt = c;
        -: 5923:	return '?';
        -: 5924:      }
        -: 5925:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 5926:    #ifndef FAULTY_F_DG_3
        -: 5927:    if (temp[0] == 'W' && temp[1] == ';')
        -: 5928:    #else
        -: 5929:    if (temp[0] == 'W')
        -: 5930:    #endif
        -: 5931:      {
        -: 5932:	char *nameend;
        -: 5933:	const struct option *p;
        -: 5934:	const struct option *pfound = NULL;
        -: 5935:	int exact = 0;
        -: 5936:	int ambig = 0;
        -: 5937:	int indfound = 0;
        -: 5938:	int option_index;
        -: 5939:
        -: 5940:	/* This is an option that requires an argument.  */
        -: 5941:	if (*nextchar != '\0')
        -: 5942:	  {
        -: 5943:	    optarg = nextchar;
        -: 5944:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 5945:	       we must advance to the next element now.  */
        -: 5946:	    optind++;
        -: 5947:	  }
        -: 5948:	else if (optind == argc)
        -: 5949:	  {
        -: 5950:	    if (opterr)
        -: 5951:	      {
        -: 5952:		/* 1003.2 specifies the format of this message.  */
        -: 5953:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 5954:			 argv[0], c);
        -: 5955:	      }
        -: 5956:	    optopt = c;
        -: 5957:	    if (optstring[0] == ':')
        -: 5958:	      c = ':';
        -: 5959:	    else
        -: 5960:	      c = '?';
        -: 5961:	    return c;
        -: 5962:	  }
        -: 5963:	else
        -: 5964:	  /* We already incremented `optind' once;
        -: 5965:	     increment it again when taking next ARGV-elt as argument.  */
        -: 5966:	  optarg = argv[optind++];
        -: 5967:
        -: 5968:	/* optarg is now the argument, see if it's in the
        -: 5969:	   table of longopts.  */
        -: 5970:
        -: 5971:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 5972:	  /* Do nothing.  */ ;
        -: 5973:
        -: 5974:	/* Test all long options for either exact match
        -: 5975:	   or abbreviated matches.  */
        -: 5976:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 5977:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 5978:	    {
        -: 5979:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 5980:		{
        -: 5981:		  /* Exact match found.  */
        -: 5982:		  pfound = p;
        -: 5983:		  indfound = option_index;
        -: 5984:		  exact = 1;
        -: 5985:		  break;
        -: 5986:		}
        -: 5987:	      else if (pfound == NULL)
        -: 5988:		{
        -: 5989:		  /* First nonexact match found.  */
        -: 5990:		  pfound = p;
        -: 5991:		  indfound = option_index;
        -: 5992:		}
        -: 5993:	      else
        -: 5994:		/* Second or later nonexact match found.  */
        -: 5995:		ambig = 1;
        -: 5996:	    }
        -: 5997:	if (ambig && !exact)
        -: 5998:	  {
        -: 5999:	    if (opterr)
        -: 6000:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 6001:		       argv[0], argv[optind]);
        -: 6002:	    nextchar += strlen (nextchar);
        -: 6003:	    optind++;
        -: 6004:	    return '?';
        -: 6005:	  }
        -: 6006:	if (pfound != NULL)
        -: 6007:	  {
        -: 6008:	    option_index = indfound;
        -: 6009:	    if (*nameend)
        -: 6010:	      {
        -: 6011:		/* Don't test has_arg with >, because some C compilers don't
        -: 6012:		   allow it to be used on enums.  */
        -: 6013:		if (pfound->has_arg)
        -: 6014:		  optarg = nameend + 1;
        -: 6015:		else
        -: 6016:		  {
        -: 6017:		    if (opterr)
        -: 6018:		      fprintf (stderr, _("\
        -: 6019:%s: option `-W %s' doesn't allow an argument\n"),
        -: 6020:			       argv[0], pfound->name);
        -: 6021:
        -: 6022:		    nextchar += strlen (nextchar);
        -: 6023:		    return '?';
        -: 6024:		  }
        -: 6025:	      }
        -: 6026:	    else if (pfound->has_arg == 1)
        -: 6027:	      {
        -: 6028:		if (optind < argc)
        -: 6029:		  optarg = argv[optind++];
        -: 6030:		else
        -: 6031:		  {
        -: 6032:		    if (opterr)
        -: 6033:		      fprintf (stderr,
        -: 6034:			       _("%s: option `%s' requires an argument\n"),
        -: 6035:			       argv[0], argv[optind - 1]);
        -: 6036:		    nextchar += strlen (nextchar);
        -: 6037:		    return optstring[0] == ':' ? ':' : '?';
        -: 6038:		  }
        -: 6039:	      }
        -: 6040:	    nextchar += strlen (nextchar);
        -: 6041:	    if (longind != NULL)
        -: 6042:	      *longind = option_index;
        -: 6043:	    if (pfound->flag)
        -: 6044:	      {
        -: 6045:		*(pfound->flag) = pfound->val;
        -: 6046:		return 0;
        -: 6047:	      }
        -: 6048:	    return pfound->val;
        -: 6049:	  }
        -: 6050:	  nextchar = NULL;
        -: 6051:	  return 'W';	/* Let the application handle it.   */
        -: 6052:      }
        -: 6053:    if (temp[1] == ':')
        -: 6054:      {
        -: 6055:	if (temp[2] == ':')
        -: 6056:	  {
        -: 6057:	    /* This is an option that accepts an argument optionally.  */
        -: 6058:	    if (*nextchar != '\0')
        -: 6059:	      {
        -: 6060:		optarg = nextchar;
        -: 6061:		optind++;
        -: 6062:	      }
        -: 6063:	    else
        -: 6064:	      optarg = NULL;
        -: 6065:	    nextchar = NULL;
        -: 6066:	  }
        -: 6067:	else
        -: 6068:	  {
        -: 6069:	    /* This is an option that requires an argument.  */
        -: 6070:	    if (*nextchar != '\0')
        -: 6071:	      {
        -: 6072:		optarg = nextchar;
        -: 6073:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 6074:		   we must advance to the next element now.  */
        -: 6075:		optind++;
        -: 6076:	      }
        -: 6077:	    else if (optind == argc)
        -: 6078:	      {
        -: 6079:		if (opterr)
        -: 6080:		  {
        -: 6081:		    /* 1003.2 specifies the format of this message.  */
        -: 6082:		    fprintf (stderr,
        -: 6083:			   _("%s: option requires an argument -- %c\n"),
        -: 6084:			   argv[0], c);
        -: 6085:		  }
        -: 6086:		optopt = c;
        -: 6087:		if (optstring[0] == ':')
        -: 6088:		  c = ':';
        -: 6089:		else
        -: 6090:		  c = '?';
        -: 6091:	      }
        -: 6092:	    else
        -: 6093:	      /* We already incremented `optind' once;
        -: 6094:		 increment it again when taking next ARGV-elt as argument.  */
        -: 6095:	      optarg = argv[optind++];
        -: 6096:	    nextchar = NULL;
        -: 6097:	  }
        -: 6098:      }
        -: 6099:    return c;
        -: 6100:  }
        -: 6101:}
        -: 6102:
        -: 6103:int
        -: 6104:getopt (argc, argv, optstring)
        -: 6105:     int argc;
        -: 6106:     char *const *argv;
        -: 6107:     const char *optstring;
        -: 6108:{
        -: 6109:  return _getopt_internal (argc, argv, optstring,
        -: 6110:			   (const struct option *) 0,
        -: 6111:			   (int *) 0,
        -: 6112:			   0);
        -: 6113:}
        -: 6114:
        -: 6115:#endif	/* Not ELIDE_CODE.  */
        -: 6116:
        -: 6117:#ifdef TEST
        -: 6118:
        -: 6119:/* Compile with -DTEST to make an executable for use in testing
        -: 6120:   the above definition of `getopt'.  */
        -: 6121:
        -: 6122:int
        -: 6123:main (argc, argv)
        -: 6124:     int argc;
        -: 6125:     char **argv;
        -: 6126:{
        -: 6127:  int c;
        -: 6128:  int digit_optind = 0;
        -: 6129:
        -: 6130:  while (1)
        -: 6131:    {
        -: 6132:      int this_option_optind = optind ? optind : 1;
        -: 6133:
        -: 6134:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 6135:      if (c == -1)
        -: 6136:	break;
        -: 6137:
        -: 6138:      switch (c)
        -: 6139:	{
        -: 6140:	case '0':
        -: 6141:	case '1':
        -: 6142:	case '2':
        -: 6143:	case '3':
        -: 6144:	case '4':
        -: 6145:	case '5':
        -: 6146:	case '6':
        -: 6147:	case '7':
        -: 6148:	case '8':
        -: 6149:	case '9':
        -: 6150:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6151:	    printf ("digits occur in two different argv-elements.\n");
        -: 6152:	  digit_optind = this_option_optind;
        -: 6153:	  printf ("option %c\n", c);
        -: 6154:	  break;
        -: 6155:
        -: 6156:	case 'a':
        -: 6157:	  printf ("option a\n");
        -: 6158:	  break;
        -: 6159:
        -: 6160:	case 'b':
        -: 6161:	  printf ("option b\n");
        -: 6162:	  break;
        -: 6163:
        -: 6164:	case 'c':
        -: 6165:	  printf ("option c with value `%s'\n", optarg);
        -: 6166:	  break;
        -: 6167:
        -: 6168:	case '?':
        -: 6169:	  break;
        -: 6170:
        -: 6171:	default:
        -: 6172:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6173:	}
        -: 6174:    }
        -: 6175:
        -: 6176:  if (optind < argc)
        -: 6177:    {
        -: 6178:      printf ("non-option ARGV-elements: ");
        -: 6179:      while (optind < argc)
        -: 6180:	printf ("%s ", argv[optind++]);
        -: 6181:      printf ("\n");
        -: 6182:    }
        -: 6183:
        -: 6184:  exit (0);
        -: 6185:}
        -: 6186:
        -: 6187:#endif /* TEST */
        -: 6188:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 6189:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97, 98 Free Software Foundation, Inc.
        -: 6190:
        -: 6191:   This file is part of the GNU C Library.  Its master source is NOT part of
        -: 6192:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 6193:
        -: 6194:   The GNU C Library is free software; you can redistribute it and/or
        -: 6195:   modify it under the terms of the GNU Library General Public License as
        -: 6196:   published by the Free Software Foundation; either version 2 of the
        -: 6197:   License, or (at your option) any later version.
        -: 6198:
        -: 6199:   The GNU C Library is distributed in the hope that it will be useful,
        -: 6200:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6201:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 6202:   Library General Public License for more details.
        -: 6203:
        -: 6204:   You should have received a copy of the GNU Library General Public
        -: 6205:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 6206:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 6207:   Boston, MA 02111-1307, USA.  */
        -: 6208:
        -: 6209:#ifdef HAVE_CONFIG_H
        -: 6210:#if flag_config==0 
        -: 6211:#include <config.h>
        -: 6212:#define flag_config 1
        -: 6213:#endif
        -: 6214:#endif
        -: 6215:
        -: 6216:/*#include "getopt.h" */
        -: 6217:
        -: 6218:#if !defined (__STDC__) || !__STDC__
        -: 6219:/* This is a separate conditional since some stdc systems
        -: 6220:   reject `defined (const)'.  */
        -: 6221:#ifndef const
        -: 6222:#define const
        -: 6223:#endif
        -: 6224:#endif
        -: 6225:
        -: 6226:/*#include <stdio.h>*/
        -: 6227:
        -: 6228:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 6229:   actually compiling the library itself.  This code is part of the GNU C
        -: 6230:   Library, but also included in many other GNU distributions.  Compiling
        -: 6231:   and linking in this code is a waste when using the GNU C library
        -: 6232:   (especially if it is a shared library).  Rather than having every GNU
        -: 6233:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 6234:   it is simpler to just do this in the source for each such file.  */
        -: 6235:
        -: 6236:#define GETOPT_INTERFACE_VERSION 2
        -: 6237:#if !defined (_LIBC) && defined (__GLIBC__) && __GLIBC__ >= 2
        -: 6238:#if flag_gnuversions==0
        -: 6239:#include <gnu-versions.h>
        -: 6240:#define flag_gnuversions 1
        -: 6241:#endif
        -: 6242:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 6243:#define ELIDE_CODE
        -: 6244:#endif
        -: 6245:#endif
        -: 6246:
        -: 6247:#ifndef ELIDE_CODE
        -: 6248:
        -: 6249:
        -: 6250:/* This needs to come after some library #include
        -: 6251:   to get __GNU_LIBRARY__ defined.  */
        -: 6252:#ifdef __GNU_LIBRARY__
        -: 6253:#if flag_stdlib==0
        -: 6254:#include <stdlib.h>
        -: 6255:#define flag_stdlib 1
        -: 6256:#endif
        -: 6257:#endif
        -: 6258:
        -: 6259:#ifndef	NULL
        -: 6260:#define NULL 0
        -: 6261:#endif
        -: 6262:
        -: 6263:int
        -: 6264:getopt_long (argc, argv, options, long_options, opt_index)
        -: 6265:     int argc;
        -: 6266:     char *const *argv;
        -: 6267:     const char *options;
        -: 6268:     const struct option *long_options;
        -: 6269:     int *opt_index;
        -: 6270:{
        -: 6271:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 6272:}
        -: 6273:
        -: 6274:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 6275:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 6276:   but does match a short option, it is parsed as a short option
        -: 6277:   instead.  */
        -: 6278:
        -: 6279:int
        -: 6280:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 6281:     int argc;
        -: 6282:     char *const *argv;
        -: 6283:     const char *options;
        -: 6284:     const struct option *long_options;
        -: 6285:     int *opt_index;
        -: 6286:{
        -: 6287:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 6288:}
        -: 6289:
        -: 6290:
        -: 6291:#endif	/* Not ELIDE_CODE.  */
        -: 6292:
        -: 6293:#ifdef TEST
        -: 6294:
        -: 6295:/*#include <stdio.h> */
        -: 6296:
        -: 6297:int
        -: 6298:main (argc, argv)
        -: 6299:     int argc;
        -: 6300:     char **argv;
        -: 6301:{
        -: 6302:  int c;
        -: 6303:  int digit_optind = 0;
        -: 6304:
        -: 6305:  while (1)
        -: 6306:    {
        -: 6307:      int this_option_optind = optind ? optind : 1;
        -: 6308:      int option_index = 0;
        -: 6309:      static struct option long_options[] =
        -: 6310:      {
        -: 6311:	{"add", 1, 0, 0},
        -: 6312:	{"append", 0, 0, 0},
        -: 6313:	{"delete", 1, 0, 0},
        -: 6314:	{"verbose", 0, 0, 0},
        -: 6315:	{"create", 0, 0, 0},
        -: 6316:	{"file", 1, 0, 0},
        -: 6317:	{0, 0, 0, 0}
        -: 6318:      };
        -: 6319:
        -: 6320:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 6321:		       long_options, &option_index);
        -: 6322:      if (c == -1)
        -: 6323:	break;
        -: 6324:
        -: 6325:      switch (c)
        -: 6326:	{
        -: 6327:	case 0:
        -: 6328:	  printf (_("option %s"), long_options[option_index].name);
        -: 6329:	  if (optarg)
        -: 6330:	    printf (_(" with arg %s"), optarg);
        -: 6331:	  printf ("\n");
        -: 6332:	  break;
        -: 6333:
        -: 6334:	case '0':
        -: 6335:	case '1':
        -: 6336:	case '2':
        -: 6337:	case '3':
        -: 6338:	case '4':
        -: 6339:	case '5':
        -: 6340:	case '6':
        -: 6341:	case '7':
        -: 6342:	case '8':
        -: 6343:	case '9':
        -: 6344:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6345:	    printf (_("digits occur in two different argv-elements.\n"));
        -: 6346:	  digit_optind = this_option_optind;
        -: 6347:	  printf (_("option %c\n"), c);
        -: 6348:	  break;
        -: 6349:
        -: 6350:	case 'a':
        -: 6351:	  printf (_("option a\n"));
        -: 6352:	  break;
        -: 6353:
        -: 6354:	case 'b':
        -: 6355:	  printf (_("option b\n"));
        -: 6356:	  break;
        -: 6357:
        -: 6358:	case 'c':
        -: 6359:	  printf (_("option c with value `%s'\n"), optarg);
        -: 6360:	  break;
        -: 6361:
        -: 6362:	case 'd':
        -: 6363:	  printf (_("option d with value `%s'\n"), optarg);
        -: 6364:	  break;
        -: 6365:
        -: 6366:	case '?':
        -: 6367:	  break;
        -: 6368:
        -: 6369:	default:
        -: 6370:	  printf (_("?? getopt returned character code 0%o ??\n"), c);
        -: 6371:	}
        -: 6372:    }
        -: 6373:
        -: 6374:  if (optind < argc)
        -: 6375:    {
        -: 6376:      printf (_("non-option ARGV-elements: "));
        -: 6377:      while (optind < argc)
        -: 6378:	printf ("%s ", argv[optind++]);
        -: 6379:      printf ("\n");
        -: 6380:    }
        -: 6381:
        -: 6382:  exit (0);
        -: 6383:}
        -: 6384:
        -: 6385:#endif /* TEST */
        -: 6386:/* search.c - searching subroutines using dfa, kwset and regex for grep.
        -: 6387:   Copyright (C) 1992, 1998 Free Software Foundation, Inc.
        -: 6388:
        -: 6389:   This program is free software; you can redistribute it and/or modify
        -: 6390:   it under the terms of the GNU General Public License as published by
        -: 6391:   the Free Software Foundation; either version 2, or (at your option)
        -: 6392:   any later version.
        -: 6393:
        -: 6394:   This program is distributed in the hope that it will be useful,
        -: 6395:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6396:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6397:   GNU General Public License for more details.
        -: 6398:
        -: 6399:   You should have received a copy of the GNU General Public License
        -: 6400:   along with this program; if not, write to the Free Software
        -: 6401:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
        -: 6402:   02111-1307, USA.  */
        -: 6403:
        -: 6404:/* Written August 1992 by Mike Haertel. */
        -: 6405:
        -: 6406:#ifdef HAVE_CONFIG_H
        -: 6407:#if flag_config==0
        -: 6408:# include <config.h>
        -: 6409:#define flag_config 1
        -: 6410:#endif
        -: 6411:#endif
        -: 6412:/*#include <sys/types.h>*/
        -: 6413:/*#include "system.h"*/
        -: 6414:/*#include "grep.h"*/
        -: 6415:/*#include "regex.h"*/
        -: 6416:/*#include "dfa.h"*/
        -: 6417:/*#include "kwset.h"*/
        -: 6418:
        -: 6419:#define NCHAR (UCHAR_MAX + 1)
        -: 6420:
        -: 6421:static void Gcompile PARAMS((char *, size_t));
        -: 6422:static void Ecompile PARAMS((char *, size_t));
        -: 6423:static char *EGexecute PARAMS((char *, size_t, char **));
        -: 6424:static void Fcompile PARAMS((char *, size_t));
        -: 6425:static char *Fexecute PARAMS((char *, size_t, char **));
        -: 6426:static void kwsinit PARAMS((void));
        -: 6427:
        -: 6428:/* Here is the matchers vector for the main program. */
        -: 6429:struct matcher matchers[] = {
        -: 6430:  { "default", Gcompile, EGexecute },
        -: 6431:  { "grep", Gcompile, EGexecute },
        -: 6432:  { "ggrep", Gcompile, EGexecute },
        -: 6433:  { "egrep", Ecompile, EGexecute },
        -: 6434:  { "posix-egrep", Ecompile, EGexecute },
        -: 6435:  { "awk", Ecompile, EGexecute },
        -: 6436:  { "gegrep", Ecompile, EGexecute },
        -: 6437:  { "fgrep", Fcompile, Fexecute },
        -: 6438:  { "gfgrep", Fcompile, Fexecute },
        -: 6439:  { 0, 0, 0 },
        -: 6440:};
        -: 6441:
        -: 6442:/* For -w, we also consider _ to be word constituent.  */
        -: 6443:#define WCHAR(C) (ISALNUM(C) || (C) == '_')
        -: 6444:
        -: 6445:/* DFA compiled regexp. */
        -: 6446:static struct dfa dfa_1;
        -: 6447:
        -: 6448:/* Regex compiled regexp. */
        -: 6449:static struct re_pattern_buffer regex;
        -: 6450:
        -: 6451:/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
        -: 6452:   a list of strings, at least one of which is known to occur in
        -: 6453:   any string matching the regexp. */
        -: 6454:static kwset_t kwset;
        -: 6455:
        -: 6456:/* Last compiled fixed string known to exactly match the regexp.
        -: 6457:   If kwsexec() returns < lastexact, then we don't need to
        -: 6458:   call the regexp matcher at all. */
        -: 6459:static int lastexact;
        -: 6460:
        -: 6461:void
    #####: 6462:dfaerror(mesg)
        -: 6463:  const char *mesg;
        -: 6464:{
    #####: 6465:  fatal(mesg, 0);
    #####: 6466:}
        -: 6467:
        -: 6468:static void
        1: 6469:kwsinit()
        -: 6470:{
        -: 6471:  static char trans[NCHAR];
        -: 6472:  int i;
        -: 6473:
        1: 6474:  if (match_icase)
    #####: 6475:    for (i = 0; i < NCHAR; ++i)
    #####: 6476:      trans[i] = TOLOWER(i);
        -: 6477:
       1*: 6478:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
    #####: 6479:    fatal("memory exhausted", 0);
        1: 6480:}
        -: 6481:
        -: 6482:/* If the DFA turns out to have some set of fixed strings one of
        -: 6483:   which must occur in the match, then we build a kwset matcher
        -: 6484:   to find those strings, and thus quickly filter out impossible
        -: 6485:   matches. */
        -: 6486:static void
        1: 6487:kwsmusts()
        -: 6488:{
        -: 6489:  struct dfamust *dm;
        -: 6490:  char *err;
        -: 6491:
        1: 6492:  if (dfa_1.musts)
        -: 6493:    {
        1: 6494:      kwsinit();
        -: 6495:      /* First, we compile in the substrings known to be exact
        -: 6496:	 matches.  The kwset matcher will return the index
        -: 6497:	 of the matching string that it chooses. */
        2: 6498:      for (dm = dfa_1.musts; dm; dm = dm->next)
        -: 6499:	{
        1: 6500:	  if (!dm->exact)
        1: 6501:	    continue;
    #####: 6502:	  ++lastexact;
    #####: 6503:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
    #####: 6504:	    fatal(err, 0);
        -: 6505:	}
        -: 6506:      /* Now, we compile the substrings that will require
        -: 6507:	 the use of the regexp matcher.  */
        2: 6508:      for (dm = dfa_1.musts; dm; dm = dm->next)
        -: 6509:	{
       1*: 6510:	  if (dm->exact)
    #####: 6511:	    continue;
        1: 6512:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
    #####: 6513:	    fatal(err, 0);
        -: 6514:	}
        1: 6515:      if ((err = kwsprep(kwset)) != 0)
    #####: 6516:	fatal(err, 0);
        -: 6517:    }
        1: 6518:}
        -: 6519:
        -: 6520:static void
        1: 6521:Gcompile(pattern, size)
        -: 6522:     char *pattern;
        -: 6523:     size_t size;
        -: 6524:{
        -: 6525:  const char *err;
        -: 6526:
        1: 6527:  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
        1: 6528:  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);
        -: 6529:
        1: 6530:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    #####: 6531:    fatal(err, 0);
        -: 6532:
        1: 6533:  dfainit(&dfa_1);
        -: 6534:
        -: 6535:  /* In the match_words and match_lines cases, we use a different pattern
        -: 6536:     for the DFA matcher that will quickly throw out cases that won't work.
        -: 6537:     Then if DFA succeeds we do some hairy stuff using the regex matcher
        -: 6538:     to decide whether the match should really count. */
        1: 6539:  if (match_words || match_lines)
    #####: 6540:    {
        -: 6541:      /* In the whole-word case, we use the pattern:
        -: 6542:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
        -: 6543:	 In the whole-line case, we use the pattern:
        -: 6544:	 ^(userpattern)$.
        -: 6545:	 BUG: Using [A-Za-z_] is locale-dependent!  */
        -: 6546:
    #####: 6547:      char *n = malloc(size + 50);
    #####: 6548:      int i = 0;
        -: 6549:
    #####: 6550:      strcpy(n, "");
        -: 6551:
    #####: 6552:      if (match_lines)
    #####: 6553:	strcpy(n, "^\\(");
    #####: 6554:      if (match_words)
    #####: 6555:	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
        -: 6556:
    #####: 6557:      i = strlen(n);
        -: 6558:      #ifndef FAULTY_F_DG_8
    #####: 6559:      memcpy(n + i, pattern, size);
        -: 6560:      #else
        -: 6561:      memcpy(pattern, n + i, size);
        -: 6562:      #endif
    #####: 6563:      i += size;
        -: 6564:
    #####: 6565:      if (match_words)
    #####: 6566:	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
    #####: 6567:      if (match_lines)
    #####: 6568:	strcpy(n + i, "\\)$");
        -: 6569:
    #####: 6570:      i += strlen(n + i);
    #####: 6571:      dfacomp(n, i, &dfa_1, 1);
        -: 6572:    }
        -: 6573:  else
        1: 6574:    dfacomp(pattern, size, &dfa_1, 1);
        -: 6575:
        1: 6576:  kwsmusts();
        1: 6577:}
        -: 6578:
        -: 6579:static void
    #####: 6580:Ecompile(pattern, size)
        -: 6581:     char *pattern;
        -: 6582:     size_t size;
        -: 6583:{
        -: 6584:  const char *err;
        -: 6585:
    #####: 6586:  if (strcmp(matcher, "posix-egrep") == 0)
        -: 6587:    {
    #####: 6588:      re_set_syntax(RE_SYNTAX_POSIX_EGREP);
    #####: 6589:      dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);
        -: 6590:    }
    #####: 6591:  else if (strcmp(matcher, "awk") == 0)
        -: 6592:    {
    #####: 6593:      re_set_syntax(RE_SYNTAX_AWK);
    #####: 6594:      dfasyntax(RE_SYNTAX_AWK, match_icase);
        -: 6595:    }
        -: 6596:  else
        -: 6597:    {
    #####: 6598:      re_set_syntax(RE_SYNTAX_EGREP);
    #####: 6599:      dfasyntax(RE_SYNTAX_EGREP, match_icase);
        -: 6600:    }
        -: 6601:
    #####: 6602:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    #####: 6603:    fatal(err, 0);
        -: 6604:
    #####: 6605:  dfainit(&dfa_1);
        -: 6606:
        -: 6607:  /* In the match_words and match_lines cases, we use a different pattern
        -: 6608:     for the DFA matcher that will quickly throw out cases that won't work.
        -: 6609:     Then if DFA succeeds we do some hairy stuff using the regex matcher
        -: 6610:     to decide whether the match should really count. */
    #####: 6611:  if (match_words || match_lines)
    #####: 6612:    {
        -: 6613:      /* In the whole-word case, we use the pattern:
        -: 6614:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
        -: 6615:	 In the whole-line case, we use the pattern:
        -: 6616:	 ^(userpattern)$.
        -: 6617:	 BUG: Using [A-Za-z_] is locale-dependent!  */
        -: 6618:
    #####: 6619:      char *n = malloc(size + 50);
    #####: 6620:      int i = 0;
        -: 6621:
    #####: 6622:      strcpy(n, "");
        -: 6623:
    #####: 6624:      if (match_lines)
    #####: 6625:	strcpy(n, "^(");
    #####: 6626:      if (match_words)
    #####: 6627:	strcpy(n, "(^|[^0-9A-Za-z_])(");
        -: 6628:
    #####: 6629:      i = strlen(n);
    #####: 6630:      memcpy(n + i, pattern, size);
    #####: 6631:      i += size;
        -: 6632:
    #####: 6633:      if (match_words)
    #####: 6634:	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
    #####: 6635:      if (match_lines)
    #####: 6636:	strcpy(n + i, ")$");
        -: 6637:
    #####: 6638:      i += strlen(n + i);
    #####: 6639:      dfacomp(n, i, &dfa_1, 1);
        -: 6640:    }
        -: 6641:  else
    #####: 6642:    dfacomp(pattern, size, &dfa_1, 1);
        -: 6643:
    #####: 6644:  kwsmusts();
    #####: 6645:}
        -: 6646:
        -: 6647:static char *
      843: 6648:EGexecute(buf, size, endp)
        -: 6649:     char *buf;
        -: 6650:     size_t size;
        -: 6651:     char **endp;
        -: 6652:{
        -: 6653:  register char *buflim, *beg, *end, save;
        -: 6654:  int backref, start, len;
        -: 6655:  struct kwsmatch kwsm;
        -: 6656:  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
        -: 6657:				    Q@#%!# library interface in regex.c.  */
        -: 6658:
      843: 6659:  buflim = buf + size;
        -: 6660:
     843*: 6661:  for (beg = end = buf; end < buflim; beg = end + 1)
        -: 6662:    {
      843: 6663:      if (kwset)
        -: 6664:	{
        -: 6665:	  /* Find a possible match using the KWset matcher. */
      843: 6666:	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
      843: 6667:	  if (!beg)
       11: 6668:	    goto failure;
        -: 6669:	  /* Narrow down to the line containing the candidate, and
        -: 6670:	     run it through DFA. */
      832: 6671:	  end = memchr(beg, '\n', buflim - beg);
      832: 6672:	  if (!end)
    #####: 6673:	    end = buflim;
    22408: 6674:	  while (beg > buf && beg[-1] != '\n')
    21576: 6675:	    --beg;
      832: 6676:	  save = *end;
      832: 6677:	  if (kwsm.index < lastexact)
    #####: 6678:	    goto success;
     832*: 6679:	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
        -: 6680:	    {
    #####: 6681:	      *end = save;
    #####: 6682:	      continue;
        -: 6683:	    }
      832: 6684:	  *end = save;
        -: 6685:	  /* Successful, no backreferences encountered. */
      832: 6686:	  if (!backref)
      832: 6687:	    goto success;
        -: 6688:	}
        -: 6689:      else
        -: 6690:	{
        -: 6691:	  /* No good fixed strings; start with DFA. */
    #####: 6692:	  save = *buflim;
    #####: 6693:	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
    #####: 6694:	  *buflim = save;
    #####: 6695:	  if (!beg)
    #####: 6696:	    goto failure;
        -: 6697:	  /* Narrow down to the line we've found. */
    #####: 6698:	  end = memchr(beg, '\n', buflim - beg);
    #####: 6699:	  if (!end)
    #####: 6700:	    end = buflim;
    #####: 6701:	  while (beg > buf && beg[-1] != '\n')
    #####: 6702:	    --beg;
        -: 6703:	  /* Successful, no backreferences encountered! */
    #####: 6704:	  if (!backref)
    #####: 6705:	    goto success;
        -: 6706:	}
        -: 6707:      /* If we've made it to this point, this means DFA has seen
        -: 6708:	 a probable match, and we need to run it through Regex. */
    #####: 6709:      regex.not_eol = 0;
    #####: 6710:      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
        -: 6711:	{
    #####: 6712:	  len = regs.end[0] - start;
    #####: 6713:	  if ((!match_lines && !match_words)
    #####: 6714:	      || (match_lines && len == end - beg))
    #####: 6715:	    goto success;
        -: 6716:	  /* If -w, check if the match aligns with word boundaries.
        -: 6717:	     We do this iteratively because:
        -: 6718:	     (a) the line may contain more than one occurence of the pattern, and
        -: 6719:	     (b) Several alternatives in the pattern might be valid at a given
        -: 6720:	     point, and we may need to consider a shorter one to find a word
        -: 6721:	     boundary. */
    #####: 6722:	  if (match_words)
    #####: 6723:	    while (start >= 0)
        -: 6724:	      {
    #####: 6725:		if ((start == 0 || !WCHAR(beg[start - 1]))
    #####: 6726:		    && (len == end - beg || !WCHAR(beg[start + len])))
    #####: 6727:		  goto success;
    #####: 6728:		if (len > 0)
        -: 6729:		  {
        -: 6730:		    /* Try a shorter length anchored at the same place. */
    #####: 6731:		    --len;
    #####: 6732:		    regex.not_eol = 1;
    #####: 6733:		    len = re_match(&regex, beg, start + len, start, &regs);
        -: 6734:		  }
    #####: 6735:		if (len <= 0)
        -: 6736:		  {
        -: 6737:		    /* Try looking further on. */
    #####: 6738:		    if (start == end - beg)
    #####: 6739:		      break;
    #####: 6740:		    ++start;
    #####: 6741:		    regex.not_eol = 0;
    #####: 6742:		    start = re_search(&regex, beg, end - beg,
    #####: 6743:				      start, end - beg - start, &regs);
    #####: 6744:		    len = regs.end[0] - start;
        -: 6745:		  }
        -: 6746:	      }
        -: 6747:	}
        -: 6748:    }
        -: 6749:
    #####: 6750: failure:
       11: 6751:  return 0;
        -: 6752:
      832: 6753: success:
     832*: 6754:  *endp = end < buflim ? end + 1 : end;
      832: 6755:  return beg;
        -: 6756:}
        -: 6757:
        -: 6758:static void
    #####: 6759:Fcompile(pattern, size)
        -: 6760:     char *pattern;
        -: 6761:     size_t size;
        -: 6762:{
        -: 6763:  char *beg, *lim, *err;
        -: 6764:
    #####: 6765:  kwsinit();
    #####: 6766:  beg = pattern;
        -: 6767:  do
        -: 6768:    {
    #####: 6769:      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
        -: 6770:	;
    #####: 6771:      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
    #####: 6772:	fatal(err, 0);
    #####: 6773:      if (lim < pattern + size)
    #####: 6774:	++lim;
    #####: 6775:      beg = lim;
        -: 6776:    }
    #####: 6777:  while (beg < pattern + size);
        -: 6778:
    #####: 6779:  if ((err = kwsprep(kwset)) != 0)
    #####: 6780:    fatal(err, 0);
    #####: 6781:}
        -: 6782:
        -: 6783:static char *
    #####: 6784:Fexecute(buf, size, endp)
        -: 6785:     char *buf;
        -: 6786:     size_t size;
        -: 6787:     char **endp;
        -: 6788:{
        -: 6789:  register char *beg, *try, *end;
        -: 6790:  register size_t len;
        -: 6791:  struct kwsmatch kwsmatch;
        -: 6792:
    #####: 6793:  for (beg = buf; beg <= buf + size; ++beg)
        -: 6794:    {
    #####: 6795:      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
    #####: 6796:	return 0;
    #####: 6797:      len = kwsmatch.size[0];
    #####: 6798:      if (match_lines)
        -: 6799:	{
    #####: 6800:	  if (beg > buf && beg[-1] != '\n')
    #####: 6801:	    continue;
    #####: 6802:	  if (beg + len < buf + size && beg[len] != '\n')
    #####: 6803:	    continue;
    #####: 6804:	  goto success;
        -: 6805:	}
    #####: 6806:      else if (match_words)
    #####: 6807:	for (try = beg; len && try;)
        -: 6808:	  {
    #####: 6809:	    if (try > buf && WCHAR((unsigned char) try[-1]))
        -: 6810:	      break;
    #####: 6811:	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
        -: 6812:	      {
    #####: 6813:		try = kwsexec(kwset, beg, --len, &kwsmatch);
    #####: 6814:		len = kwsmatch.size[0];
        -: 6815:	      }
        -: 6816:	    else
    #####: 6817:	      goto success;
        -: 6818:	  }
        -: 6819:      else
    #####: 6820:	goto success;
        -: 6821:    }
        -: 6822:
    #####: 6823:  return 0;
        -: 6824:
    #####: 6825: success:
    #####: 6826:  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
    #####: 6827:    ++end;
        -: 6828:  else
    #####: 6829:    end = buf + size;
    #####: 6830:  *endp = end;
    #####: 6831:  while (beg > buf && beg[-1] != '\n')
    #####: 6832:    --beg;
    #####: 6833:  return beg;
        -: 6834:}
        -: 6835:/* Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
        -: 6836:   This file is part of the GNU C Library.
        -: 6837:   Contributed by Ulrich Drepper, <drepper@gnu.ai.mit.edu>
        -: 6838:
        -: 6839:   The GNU C Library is free software; you can redistribute it and/or
        -: 6840:   modify it under the terms of the GNU Library General Public License as
        -: 6841:   published by the Free Software Foundation; either version 2 of the
        -: 6842:   License, or (at your option) any later version.
        -: 6843:
        -: 6844:   The GNU C Library is distributed in the hope that it will be useful,
        -: 6845:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6846:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 6847:   Library General Public License for more details.
        -: 6848:
        -: 6849:   You should have received a copy of the GNU Library General Public
        -: 6850:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 6851:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 6852:   Boston, MA 02111-1307, USA.  */
        -: 6853:
        -: 6854:/*#include <stdio.h>*/
        -: 6855:#include <wchar.h>
        -: 6856:#define flag_wchar 1
        -: 6857:
        -: 6858:
        -: 6859:/* We use UTF8 encoding for multibyte strings and therefore a valid
        -: 6860:   one byte multibyte string only can have a value from 0 to 0x7f.  */
        -: 6861:wint_t
        -: 6862:btowc (c)
        -: 6863:     int c;
        -: 6864:{
    #####: 6865:  if (WEOF != (wint_t) EOF || c < 0 || c > 0x7f)
    #####: 6866:    return WEOF;
        -: 6867:  else
    #####: 6868:    return (wint_t) c;
        -: 6869:}
        -: 6870:/* Extended regular expression matching and search library,
        -: 6871:   version 0.12.
        -: 6872:   (Implements POSIX draft P1003.2/D11.2, except for some of the
        -: 6873:   internationalization features.)
        -: 6874:
        -: 6875:   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
        -: 6876:
        -: 6877:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 6878:
        -: 6879:NOTE: The canonical source of this file is maintained with the
        -: 6880:GNU C Library.  Bugs can be reported to bug-glibc@prep.ai.mit.edu.
        -: 6881:
        -: 6882:This program is free software; you can redistribute it and/or modify it
        -: 6883:under the terms of the GNU General Public License as published by the
        -: 6884:Free Software Foundation; either version 2, or (at your option) any
        -: 6885:later version.
        -: 6886:
        -: 6887:This program is distributed in the hope that it will be useful,
        -: 6888:but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6889:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6890:GNU General Public License for more details.
        -: 6891:
        -: 6892:You should have received a copy of the GNU General Public License
        -: 6893:along with this program; if not, write to the Free Software Foundation,
        -: 6894:Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 6895:
        -: 6896:/* AIX requires this to be the first thing in the file. */
        -: 6897:#if defined (_AIX) && !defined (REGEX_MALLOC)
        -: 6898:  #pragma alloca
        -: 6899:#endif
        -: 6900:
        -: 6901:#undef	_GNU_SOURCE
        -: 6902:#define _GNU_SOURCE
        -: 6903:
        -: 6904:#ifdef HAVE_CONFIG_H
        -: 6905:#if flag_config==0
        -: 6906:#include <config.h>
        -: 6907:#define flag_config 1
        -: 6908:#endif
        -: 6909:#endif
        -: 6910:
        -: 6911:#if defined(STDC_HEADERS) && !defined(emacs)
        -: 6912:#include <stddef.h>
        -: 6913:#else
        -: 6914:/* We need this for `regex.h', and perhaps for the Emacs include files.  */
        -: 6915:#if flag_typesh==0
        -: 6916:#include <sys/types.h>
        -: 6917:#define flag_typesh 1
        -: 6918:#endif
        -: 6919:#endif
        -: 6920:
        -: 6921:/* For platform which support the ISO C amendement 1 functionality we
        -: 6922:   support user defined character classes.  */
        -: 6923:#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
        -: 6924: /* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
        -: 6925:#if flag_wchar==0 
        -: 6926:# include <wchar.h>
        -: 6927:#define flag_wchar 1
        -: 6928:#endif
        -: 6929:#undef ISPRINT
        -: 6930:# include <wctype.h>
        -: 6931:#endif
        -: 6932:
        -: 6933:/* This is for other GNU distributions with internationalized messages.  */
        -: 6934:#if HAVE_LIBINTL_H || defined (_LIBC)
        -: 6935:#if flag_libintl==0
        -: 6936:# include <libintl.h>
        -: 6937:#define flag_libintl 1
        -: 6938:#endif
        -: 6939:#else
        -: 6940:# define gettext(msgid) (msgid)
        -: 6941:#endif
        -: 6942:
        -: 6943:#ifndef gettext_noop
        -: 6944:/* This define is so xgettext can find the internationalizable
        -: 6945:   strings.  */
        -: 6946:#define gettext_noop(String) String
        -: 6947:#endif
        -: 6948:
        -: 6949:/* The `emacs' switch turns on certain matching commands
        -: 6950:   that make sense only in Emacs. */
        -: 6951:#ifdef emacs
        -: 6952:
        -: 6953:#include "lisp.h"
        -: 6954:#include "buffer.h"
        -: 6955:#include "syntax.h"
        -: 6956:
        -: 6957:#else  /* not emacs */
        -: 6958:
        -: 6959:/* If we are not linking with Emacs proper,
        -: 6960:   we can't use the relocating allocator
        -: 6961:   even if config.h says that we can.  */
        -: 6962:#undef REL_ALLOC
        -: 6963:
        -: 6964:#if defined (STDC_HEADERS) || defined (_LIBC)
        -: 6965:#if flag_stdlib==0
        -: 6966:#include <stdlib.h>
        -: 6967:#define flag_stdlib 1
        -: 6968:#endif
        -: 6969:#else
        -: 6970:char *malloc ();
        -: 6971:char *realloc ();
        -: 6972:#endif
        -: 6973:
        -: 6974:/* When used in Emacs's lib-src, we need to get bzero and bcopy somehow.
        -: 6975:   If nothing else has been done, use the method below.  */
        -: 6976:#ifdef INHIBIT_STRING_HEADER
        -: 6977:#if !(defined (HAVE_BZERO) && defined (HAVE_BCOPY))
        -: 6978:#if !defined (bzero) && !defined (bcopy)
        -: 6979:#undef INHIBIT_STRING_HEADER
        -: 6980:#endif
        -: 6981:#endif
        -: 6982:#endif
        -: 6983:
        -: 6984:/* This is the normal way of making sure we have a bcopy and a bzero.
        -: 6985:   This is used in most programs--a few other programs avoid this
        -: 6986:   by defining INHIBIT_STRING_HEADER.  */
        -: 6987:#ifndef INHIBIT_STRING_HEADER
        -: 6988:#if defined (HAVE_STRING_H) || defined (STDC_HEADERS) || defined (_LIBC)
        -: 6989:#if flag_string==0
        -: 6990:#include <string.h>
        -: 6991:#define flag_string 1
        -: 6992:#endif
        -: 6993:#ifndef bcmp
        -: 6994:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
        -: 6995:#endif
        -: 6996:#ifndef bcopy
        -: 6997:#define bcopy(s, d, n)	memcpy ((d), (s), (n))
        -: 6998:#endif
        -: 6999:#ifndef bzero
        -: 7000:#define bzero(s, n)	memset ((s), 0, (n))
        -: 7001:#endif
        -: 7002:#else
        -: 7003:#if flag_strings==0
        -: 7004:#include <strings.h>
        -: 7005:#define flag_strings 1
        -: 7006:#endif
        -: 7007:#endif
        -: 7008:#endif
        -: 7009:
        -: 7010:/* Define the syntax stuff for \<, \>, etc.  */
        -: 7011:
        -: 7012:/* This must be nonzero for the wordchar and notwordchar pattern
        -: 7013:   commands in re_match_2.  */
        -: 7014:#ifndef Sword
        -: 7015:#define Sword 1
        -: 7016:#endif
        -: 7017:
        -: 7018:#ifdef SWITCH_ENUM_BUG
        -: 7019:#define SWITCH_ENUM_CAST(x) ((int)(x))
        -: 7020:#else
        -: 7021:#define SWITCH_ENUM_CAST(x) (x)
        -: 7022:#endif
        -: 7023:
        -: 7024:#ifdef SYNTAX_TABLE
        -: 7025:
        -: 7026:extern char *re_syntax_table;
        -: 7027:
        -: 7028:#else /* not SYNTAX_TABLE */
        -: 7029:
        -: 7030:/* How many characters in the character set.  */
        -: 7031:#define CHAR_SET_SIZE 256
        -: 7032:
        -: 7033:static char re_syntax_table[CHAR_SET_SIZE];
        -: 7034:
        -: 7035:static void
        1: 7036:init_syntax_once ()
        -: 7037:{
        -: 7038:   register int c;
        -: 7039:   static int done = 0;
        -: 7040:
        1: 7041:   if (done)
    #####: 7042:     return;
        -: 7043:
        1: 7044:   bzero (re_syntax_table, sizeof re_syntax_table);
        -: 7045:
       27: 7046:   for (c = 'a'; c <= 'z'; c++)
       26: 7047:     re_syntax_table[c] = Sword;
        -: 7048:
       27: 7049:   for (c = 'A'; c <= 'Z'; c++)
       26: 7050:     re_syntax_table[c] = Sword;
        -: 7051:
       11: 7052:   for (c = '0'; c <= '9'; c++)
       10: 7053:     re_syntax_table[c] = Sword;
        -: 7054:
        1: 7055:   re_syntax_table['_'] = Sword;
        -: 7056:
        1: 7057:   done = 1;
        -: 7058:}
        -: 7059:
        -: 7060:#endif /* not SYNTAX_TABLE */
        -: 7061:
        -: 7062:#define SYNTAX(c) re_syntax_table[c]
        -: 7063:
        -: 7064:#endif /* not emacs */
        -: 7065:
        -: 7066:/* Get the interface, including the syntax bits.  */
        -: 7067:/*#include "regex.h"*/
        -: 7068:
        -: 7069:/* isalpha etc. are used for the character classes.  */
        -: 7070:/*#include <ctype.h>*/
        -: 7071:
        -: 7072:/* Jim Meyering writes:
        -: 7073:
        -: 7074:   "... Some ctype macros are valid only for character codes that
        -: 7075:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
        -: 7076:   using /bin/cc or gcc but without giving an ansi option).  So, all
        -: 7077:   ctype uses should be through macros like ISPRINT...  If
        -: 7078:   STDC_HEADERS is defined, then autoconf has verified that the ctype
        -: 7079:   macros don't need to be guarded with references to isascii. ...
        -: 7080:   Defining isascii to 1 should let any compiler worth its salt
        -: 7081:   eliminate the && through constant folding."  */
        -: 7082:
        -: 7083:#undef ISASCII
        -: 7084:#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
        -: 7085:#define ISASCII(c) 1
        -: 7086:#else
        -: 7087:#define ISASCII(c) isascii(c)
        -: 7088:#endif
        -: 7089:
        -: 7090:#ifdef isblank
        -: 7091:#define ISBLANK(c) (ISASCII (c) && isblank (c))
        -: 7092:#else
        -: 7093:#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
        -: 7094:#endif
        -: 7095:
        -: 7096:#undef ISGRAPH
        -: 7097:#undef ISDIGIT
        -: 7098:#undef  ISALNUM
        -: 7099:#undef ISALPHA
        -: 7100:#undef ISCNTRL
        -: 7101:#undef ISLOWER
        -: 7102:#undef ISPUNCT
        -: 7103:#undef  ISSPACE
        -: 7104:#undef  ISUPPER
        -: 7105:#undef ISXDIGIT
        -: 7106:
        -: 7107:
        -: 7108:#ifdef isgraph
        -: 7109:#define ISGRAPH(c) (ISASCII (c) && isgraph (c))
        -: 7110:#else
        -: 7111:#define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
        -: 7112:#endif
        -: 7113:
        -: 7114:#undef ISPRINT
        -: 7115:#define ISPRINT(c) (ISASCII (c) && isprint (c))
        -: 7116:#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
        -: 7117:#define ISALNUM(c) (ISASCII (c) && isalnum (c))
        -: 7118:#define ISALPHA(c) (ISASCII (c) && isalpha (c))
        -: 7119:#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
        -: 7120:#define ISLOWER(c) (ISASCII (c) && islower (c))
        -: 7121:#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
        -: 7122:#define ISSPACE(c) (ISASCII (c) && isspace (c))
        -: 7123:#define ISUPPER(c) (ISASCII (c) && isupper (c))
        -: 7124:#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
        -: 7125:
        -: 7126:#ifndef NULL
        -: 7127:#define NULL (void *)0
        -: 7128:#endif
        -: 7129:
        -: 7130:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
        -: 7131:   since ours (we hope) works properly with all combinations of
        -: 7132:   machines, compilers, `char' and `unsigned char' argument types.
        -: 7133:   (Per Bothner suggested the basic approach.)  */
        -: 7134:#undef SIGN_EXTEND_CHAR
        -: 7135:#if __STDC__
        -: 7136:#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
        -: 7137:#else  /* not __STDC__ */
        -: 7138:/* As in Harbison and Steele.  */
        -: 7139:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
        -: 7140:#endif
        -: 7141:
        -: 7142:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
        -: 7143:   use `alloca' instead of `malloc'.  This is because using malloc in
        -: 7144:   re_search* or re_match* could cause memory leaks when C-g is used in
        -: 7145:   Emacs; also, malloc is slower and causes storage fragmentation.  On
        -: 7146:   the other hand, malloc is more portable, and easier to debug.
        -: 7147:
        -: 7148:   Because we sometimes use alloca, some routines have to be macros,
        -: 7149:   not functions -- `alloca'-allocated space disappears at the end of the
        -: 7150:   function it is called in.  */
        -: 7151:
        -: 7152:#ifdef REGEX_MALLOC
        -: 7153:
        -: 7154:#define REGEX_ALLOCATE malloc
        -: 7155:#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
        -: 7156:#define REGEX_FREE free
        -: 7157:
        -: 7158:#else /* not REGEX_MALLOC  */
        -: 7159:
        -: 7160:/* Emacs already defines alloca, sometimes.  */
        -: 7161:#ifndef alloca
        -: 7162:
        -: 7163:/* Make alloca work the best possible way.  */
        -: 7164:#ifdef __GNUC__
        -: 7165:#define alloca __builtin_alloca
        -: 7166:#else /* not __GNUC__ */
        -: 7167:#if HAVE_ALLOCA_H
        -: 7168:#include <alloca.h>
        -: 7169:#else /* not __GNUC__ or HAVE_ALLOCA_H */
        -: 7170:#if 0 /* It is a bad idea to declare alloca.  We always cast the result.  */
        -: 7171:#ifndef _AIX /* Already did AIX, up at the top.  */
        -: 7172:char *alloca ();
        -: 7173:#endif /* not _AIX */
        -: 7174:#endif
        -: 7175:#endif /* not HAVE_ALLOCA_H */
        -: 7176:#endif /* not __GNUC__ */
        -: 7177:
        -: 7178:#endif /* not alloca */
        -: 7179:
        -: 7180:#define REGEX_ALLOCATE alloca
        -: 7181:
        -: 7182:/* Assumes a `char *destination' variable.  */
        -: 7183:#define REGEX_REALLOCATE(source, osize, nsize)				\
        -: 7184:  (destination = (char *) alloca (nsize),				\
        -: 7185:   bcopy (source, destination, osize),					\
        -: 7186:   destination)
        -: 7187:
        -: 7188:/* No need to do anything to free, after alloca.  */
        -: 7189:#define REGEX_FREE(arg) ((void)0) /* Do nothing!  But inhibit gcc warning.  */
        -: 7190:
        -: 7191:#endif /* not REGEX_MALLOC */
        -: 7192:
        -: 7193:/* Define how to allocate the failure stack.  */
        -: 7194:
        -: 7195:#if defined (REL_ALLOC) && defined (REGEX_MALLOC)
        -: 7196:
        -: 7197:#define REGEX_ALLOCATE_STACK(size)				\
        -: 7198:  r_alloc (&failure_stack_ptr, (size))
        -: 7199:#define REGEX_REALLOCATE_STACK(source, osize, nsize)		\
        -: 7200:  r_re_alloc (&failure_stack_ptr, (nsize))
        -: 7201:#define REGEX_FREE_STACK(ptr)					\
        -: 7202:  r_alloc_free (&failure_stack_ptr)
        -: 7203:
        -: 7204:#else /* not using relocating allocator */
        -: 7205:
        -: 7206:#ifdef REGEX_MALLOC
        -: 7207:
        -: 7208:#define REGEX_ALLOCATE_STACK malloc
        -: 7209:#define REGEX_REALLOCATE_STACK(source, osize, nsize) realloc (source, nsize)
        -: 7210:#define REGEX_FREE_STACK free
        -: 7211:
        -: 7212:#else /* not REGEX_MALLOC */
        -: 7213:
        -: 7214:#define REGEX_ALLOCATE_STACK alloca
        -: 7215:
        -: 7216:#define REGEX_REALLOCATE_STACK(source, osize, nsize)			\
        -: 7217:   REGEX_REALLOCATE (source, osize, nsize)
        -: 7218:/* No need to explicitly free anything.  */
        -: 7219:#define REGEX_FREE_STACK(arg)
        -: 7220:
        -: 7221:#endif /* not REGEX_MALLOC */
        -: 7222:#endif /* not using relocating allocator */
        -: 7223:
        -: 7224:
        -: 7225:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
        -: 7226:   `string1' or just past its end.  This works if PTR is NULL, which is
        -: 7227:   a good thing.  */
        -: 7228:#define FIRST_STRING_P(ptr) 					\
        -: 7229:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
        -: 7230:
        -: 7231:/* (Re)Allocate N items of type T using malloc, or fail.  */
        -: 7232:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
        -: 7233:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
        -: 7234:#define RETALLOC_IF(addr, n, t) \
        -: 7235:  if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
        -: 7236:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
        -: 7237:
        -: 7238:#define BYTEWIDTH 8 /* In bits.  */
        -: 7239:
        -: 7240:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
        -: 7241:
        -: 7242:#undef MAX
        -: 7243:#undef MIN
        -: 7244:#define MAX(a, b) ((a) > (b) ? (a) : (b))
        -: 7245:#define MIN(a, b) ((a) < (b) ? (a) : (b))
        -: 7246:
        -: 7247:typedef char boolean;
        -: 7248:#define false 0
        -: 7249:#define true 1
        -: 7250:
        -: 7251:static int re_match_2_internal ();
        -: 7252:
        -: 7253:/* These are the command codes that appear in compiled regular
        -: 7254:   expressions.  Some opcodes are followed by argument bytes.  A
        -: 7255:   command code can specify any interpretation whatsoever for its
        -: 7256:   arguments.  Zero bytes may appear in the compiled regular expression.  */
        -: 7257:
        -: 7258:typedef enum
        -: 7259:{
        -: 7260:  no_op = 0,
        -: 7261:
        -: 7262:  /* Succeed right away--no more backtracking.  */
        -: 7263:  succeed,
        -: 7264:
        -: 7265:        /* Followed by one byte giving n, then by n literal bytes.  */
        -: 7266:  exactn,
        -: 7267:
        -: 7268:        /* Matches any (more or less) character.  */
        -: 7269:  anychar,
        -: 7270:
        -: 7271:        /* Matches any one char belonging to specified set.  First
        -: 7272:           following byte is number of bitmap bytes.  Then come bytes
        -: 7273:           for a bitmap saying which chars are in.  Bits in each byte
        -: 7274:           are ordered low-bit-first.  A character is in the set if its
        -: 7275:           bit is 1.  A character too large to have a bit in the map is
        -: 7276:           automatically not in the set.  */
        -: 7277:  charset,
        -: 7278:
        -: 7279:        /* Same parameters as charset, but match any character that is
        -: 7280:           not one of those specified.  */
        -: 7281:  charset_not,
        -: 7282:
        -: 7283:        /* Start remembering the text that is matched, for storing in a
        -: 7284:           register.  Followed by one byte with the register number, in
        -: 7285:           the range 0 to one less than the pattern buffer's re_nsub
        -: 7286:           field.  Then followed by one byte with the number of groups
        -: 7287:           inner to this one.  (This last has to be part of the
        -: 7288:           start_memory only because we need it in the on_failure_jump
        -: 7289:           of re_match_2.)  */
        -: 7290:  start_memory,
        -: 7291:
        -: 7292:        /* Stop remembering the text that is matched and store it in a
        -: 7293:           memory register.  Followed by one byte with the register
        -: 7294:           number, in the range 0 to one less than `re_nsub' in the
        -: 7295:           pattern buffer, and one byte with the number of inner groups,
        -: 7296:           just like `start_memory'.  (We need the number of inner
        -: 7297:           groups here because we don't have any easy way of finding the
        -: 7298:           corresponding start_memory when we're at a stop_memory.)  */
        -: 7299:  stop_memory,
        -: 7300:
        -: 7301:        /* Match a duplicate of something remembered. Followed by one
        -: 7302:           byte containing the register number.  */
        -: 7303:  duplicate,
        -: 7304:
        -: 7305:        /* Fail unless at beginning of line.  */
        -: 7306:  begline,
        -: 7307:
        -: 7308:        /* Fail unless at end of line.  */
        -: 7309:  endline,
        -: 7310:
        -: 7311:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
        -: 7312:           of string to be matched (if not).  */
        -: 7313:  begbuf,
        -: 7314:
        -: 7315:        /* Analogously, for end of buffer/string.  */
        -: 7316:  endbuf,
        -: 7317:
        -: 7318:        /* Followed by two byte relative address to which to jump.  */
        -: 7319:  jump,
        -: 7320:
        -: 7321:	/* Same as jump, but marks the end of an alternative.  */
        -: 7322:  jump_past_alt,
        -: 7323:
        -: 7324:        /* Followed by two-byte relative address of place to resume at
        -: 7325:           in case of failure.  */
        -: 7326:  on_failure_jump,
        -: 7327:
        -: 7328:        /* Like on_failure_jump, but pushes a placeholder instead of the
        -: 7329:           current string position when executed.  */
        -: 7330:  on_failure_keep_string_jump,
        -: 7331:
        -: 7332:        /* Throw away latest failure point and then jump to following
        -: 7333:           two-byte relative address.  */
        -: 7334:  pop_failure_jump,
        -: 7335:
        -: 7336:        /* Change to pop_failure_jump if know won't have to backtrack to
        -: 7337:           match; otherwise change to jump.  This is used to jump
        -: 7338:           back to the beginning of a repeat.  If what follows this jump
        -: 7339:           clearly won't match what the repeat does, such that we can be
        -: 7340:           sure that there is no use backtracking out of repetitions
        -: 7341:           already matched, then we change it to a pop_failure_jump.
        -: 7342:           Followed by two-byte address.  */
        -: 7343:  maybe_pop_jump,
        -: 7344:
        -: 7345:        /* Jump to following two-byte address, and push a dummy failure
        -: 7346:           point. This failure point will be thrown away if an attempt
        -: 7347:           is made to use it for a failure.  A `+' construct makes this
        -: 7348:           before the first repeat.  Also used as an intermediary kind
        -: 7349:           of jump when compiling an alternative.  */
        -: 7350:  dummy_failure_jump,
        -: 7351:
        -: 7352:	/* Push a dummy failure point and continue.  Used at the end of
        -: 7353:	   alternatives.  */
        -: 7354:  push_dummy_failure,
        -: 7355:
        -: 7356:        /* Followed by two-byte relative address and two-byte number n.
        -: 7357:           After matching N times, jump to the address upon failure.  */
        -: 7358:  succeed_n,
        -: 7359:
        -: 7360:        /* Followed by two-byte relative address, and two-byte number n.
        -: 7361:           Jump to the address N times, then fail.  */
        -: 7362:  jump_n,
        -: 7363:
        -: 7364:        /* Set the following two-byte relative address to the
        -: 7365:           subsequent two-byte number.  The address *includes* the two
        -: 7366:           bytes of number.  */
        -: 7367:  set_number_at,
        -: 7368:
        -: 7369:  wordchar,	/* Matches any word-constituent character.  */
        -: 7370:  notwordchar,	/* Matches any char that is not a word-constituent.  */
        -: 7371:
        -: 7372:  wordbeg,	/* Succeeds if at word beginning.  */
        -: 7373:  wordend,	/* Succeeds if at word end.  */
        -: 7374:
        -: 7375:  wordbound,	/* Succeeds if at a word boundary.  */
        -: 7376:  notwordbound	/* Succeeds if not at a word boundary.  */
        -: 7377:
        -: 7378:#ifdef emacs
        -: 7379:  ,before_dot,	/* Succeeds if before point.  */
        -: 7380:  at_dot,	/* Succeeds if at point.  */
        -: 7381:  after_dot,	/* Succeeds if after point.  */
        -: 7382:
        -: 7383:	/* Matches any character whose syntax is specified.  Followed by
        -: 7384:           a byte which contains a syntax code, e.g., Sword.  */
        -: 7385:  syntaxspec,
        -: 7386:
        -: 7387:	/* Matches any character whose syntax is not that specified.  */
        -: 7388:  notsyntaxspec
        -: 7389:#endif /* emacs */
        -: 7390:} re_opcode_t;
        -: 7391:
        -: 7392:/* Common operations on the compiled pattern.  */
        -: 7393:
        -: 7394:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
        -: 7395:
        -: 7396:#define STORE_NUMBER(destination, number)				\
        -: 7397:  do {									\
        -: 7398:    (destination)[0] = (number) & 0377;					\
        -: 7399:    (destination)[1] = (number) >> 8;					\
        -: 7400:  } while (0)
        -: 7401:
        -: 7402:/* Same as STORE_NUMBER, except increment DESTINATION to
        -: 7403:   the byte after where the number is stored.  Therefore, DESTINATION
        -: 7404:   must be an lvalue.  */
        -: 7405:
        -: 7406:#define STORE_NUMBER_AND_INCR(destination, number)			\
        -: 7407:  do {									\
        -: 7408:    STORE_NUMBER (destination, number);					\
        -: 7409:    (destination) += 2;							\
        -: 7410:  } while (0)
        -: 7411:
        -: 7412:/* Put into DESTINATION a number stored in two contiguous bytes starting
        -: 7413:   at SOURCE.  */
        -: 7414:
        -: 7415:#define EXTRACT_NUMBER(destination, source)				\
        -: 7416:  do {									\
        -: 7417:    (destination) = *(source) & 0377;					\
        -: 7418:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
        -: 7419:  } while (0)
        -: 7420:
        -: 7421:#ifdef DEBUG
        -: 7422:static void extract_number _RE_ARGS ((int *dest, unsigned char *source));
        -: 7423:static void
        -: 7424:extract_number (dest, source)
        -: 7425:    int *dest;
        -: 7426:    unsigned char *source;
        -: 7427:{
        -: 7428:  int temp = SIGN_EXTEND_CHAR (*(source + 1));
        -: 7429:  *dest = *source & 0377;
        -: 7430:  *dest += temp << 8;
        -: 7431:}
        -: 7432:
        -: 7433:#ifndef EXTRACT_MACROS /* To debug the macros.  */
        -: 7434:#undef EXTRACT_NUMBER
        -: 7435:#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
        -: 7436:#endif /* not EXTRACT_MACROS */
        -: 7437:
        -: 7438:#endif /* DEBUG */
        -: 7439:
        -: 7440:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
        -: 7441:   SOURCE must be an lvalue.  */
        -: 7442:
        -: 7443:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
        -: 7444:  do {									\
        -: 7445:    EXTRACT_NUMBER (destination, source);				\
        -: 7446:    (source) += 2; 							\
        -: 7447:  } while (0)
        -: 7448:
        -: 7449:#ifdef DEBUG
        -: 7450:static void extract_number_and_incr _RE_ARGS ((int *destination,
        -: 7451:					       unsigned char **source));
        -: 7452:static void
        -: 7453:extract_number_and_incr (destination, source)
        -: 7454:    int *destination;
        -: 7455:    unsigned char **source;
        -: 7456:{
        -: 7457:  extract_number (destination, *source);
        -: 7458:  *source += 2;
        -: 7459:}
        -: 7460:
        -: 7461:#ifndef EXTRACT_MACROS
        -: 7462:#undef EXTRACT_NUMBER_AND_INCR
        -: 7463:#define EXTRACT_NUMBER_AND_INCR(dest, src) \
        -: 7464:  extract_number_and_incr (&dest, &src)
        -: 7465:#endif /* not EXTRACT_MACROS */
        -: 7466:
        -: 7467:#endif /* DEBUG */
        -: 7468:
        -: 7469:/* If DEBUG is defined, Regex prints many voluminous messages about what
        -: 7470:   it is doing (if the variable `debug' is nonzero).  If linked with the
        -: 7471:   main program in `iregex.c', you can enter patterns and strings
        -: 7472:   interactively.  And if linked with the main program in `main.c' and
        -: 7473:   the other test files, you can run the already-written tests.  */
        -: 7474:
        -: 7475:#ifdef DEBUG
        -: 7476:
        -: 7477:/* We use standard I/O for debugging.  */
        -: 7478:/*#include <stdio.h>*/
        -: 7479:
        -: 7480:/* It is useful to test things that ``must'' be true when debugging.  */
        -: 7481:/*#include <assert.h>*/
        -: 7482:
        -: 7483:static int debug = 0;
        -: 7484:
        -: 7485:#define DEBUG_STATEMENT(e) e
        -: 7486:#define DEBUG_PRINT1(x) if (debug) printf (x)
        -: 7487:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
        -: 7488:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
        -: 7489:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
        -: 7490:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
        -: 7491:  if (debug) print_partial_compiled_pattern (s, e)
        -: 7492:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
        -: 7493:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
        -: 7494:
        -: 7495:
        -: 7496:/* Print the fastmap in human-readable form.  */
        -: 7497:
        -: 7498:void
        -: 7499:print_fastmap (fastmap)
        -: 7500:    char *fastmap;
        -: 7501:{
        -: 7502:  unsigned was_a_range = 0;
        -: 7503:  unsigned i = 0;
        -: 7504:
        -: 7505:  while (i < (1 << BYTEWIDTH))
        -: 7506:    {
        -: 7507:      if (fastmap[i++])
        -: 7508:	{
        -: 7509:	  was_a_range = 0;
        -: 7510:          putchar (i - 1);
        -: 7511:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
        -: 7512:            {
        -: 7513:              was_a_range = 1;
        -: 7514:              i++;
        -: 7515:            }
        -: 7516:	  if (was_a_range)
        -: 7517:            {
        -: 7518:              printf ("-");
        -: 7519:              putchar (i - 1);
        -: 7520:            }
        -: 7521:        }
        -: 7522:    }
        -: 7523:  putchar ('\n');
        -: 7524:}
        -: 7525:
        -: 7526:
        -: 7527:/* Print a compiled pattern string in human-readable form, starting at
        -: 7528:   the START pointer into it and ending just before the pointer END.  */
        -: 7529:
        -: 7530:void
        -: 7531:print_partial_compiled_pattern (start, end)
        -: 7532:    unsigned char *start;
        -: 7533:    unsigned char *end;
        -: 7534:{
        -: 7535:  int mcnt, mcnt2;
        -: 7536:  unsigned char *p1;
        -: 7537:  unsigned char *p = start;
        -: 7538:  unsigned char *pend = end;
        -: 7539:
        -: 7540:  if (start == NULL)
        -: 7541:    {
        -: 7542:      printf ("(null)\n");
        -: 7543:      return;
        -: 7544:    }
        -: 7545:
        -: 7546:  /* Loop over pattern commands.  */
        -: 7547:  while (p < pend)
        -: 7548:    {
        -: 7549:      printf ("%d:\t", p - start);
        -: 7550:
        -: 7551:      switch ((re_opcode_t) *p++)
        -: 7552:	{
        -: 7553:        case no_op:
        -: 7554:          printf ("/no_op");
        -: 7555:          break;
        -: 7556:
        -: 7557:	case exactn:
        -: 7558:	  mcnt = *p++;
        -: 7559:          printf ("/exactn/%d", mcnt);
        -: 7560:          do
        -: 7561:	    {
        -: 7562:              putchar ('/');
        -: 7563:	      putchar (*p++);
        -: 7564:            }
        -: 7565:          while (--mcnt);
        -: 7566:          break;
        -: 7567:
        -: 7568:	case start_memory:
        -: 7569:          mcnt = *p++;
        -: 7570:          printf ("/start_memory/%d/%d", mcnt, *p++);
        -: 7571:          break;
        -: 7572:
        -: 7573:	case stop_memory:
        -: 7574:          mcnt = *p++;
        -: 7575:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
        -: 7576:          break;
        -: 7577:
        -: 7578:	case duplicate:
        -: 7579:	  printf ("/duplicate/%d", *p++);
        -: 7580:	  break;
        -: 7581:
        -: 7582:	case anychar:
        -: 7583:	  printf ("/anychar");
        -: 7584:	  break;
        -: 7585:
        -: 7586:	case charset:
        -: 7587:        case charset_not:
        -: 7588:          {
        -: 7589:            register int c, last = -100;
        -: 7590:	    register int in_range = 0;
        -: 7591:
        -: 7592:	    printf ("/charset [%s",
        -: 7593:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
        -: 7594:
        -: 7595:            assert (p + *p < pend);
        -: 7596:
        -: 7597:            for (c = 0; c < 256; c++)
        -: 7598:	      if (c / 8 < *p
        -: 7599:		  && (p[1 + (c/8)] & (1 << (c % 8))))
        -: 7600:		{
        -: 7601:		  /* Are we starting a range?  */
        -: 7602:		  if (last + 1 == c && ! in_range)
        -: 7603:		    {
        -: 7604:		      putchar ('-');
        -: 7605:		      in_range = 1;
        -: 7606:		    }
        -: 7607:		  /* Have we broken a range?  */
        -: 7608:		  else if (last + 1 != c && in_range)
        -: 7609:              {
        -: 7610:		      putchar (last);
        -: 7611:		      in_range = 0;
        -: 7612:		    }
        -: 7613:
        -: 7614:		  if (! in_range)
        -: 7615:		    putchar (c);
        -: 7616:
        -: 7617:		  last = c;
        -: 7618:              }
        -: 7619:
        -: 7620:	    if (in_range)
        -: 7621:	      putchar (last);
        -: 7622:
        -: 7623:	    putchar (']');
        -: 7624:
        -: 7625:	    p += 1 + *p;
        -: 7626:	  }
        -: 7627:	  break;
        -: 7628:
        -: 7629:	case begline:
        -: 7630:	  printf ("/begline");
        -: 7631:          break;
        -: 7632:
        -: 7633:	case endline:
        -: 7634:          printf ("/endline");
        -: 7635:          break;
        -: 7636:
        -: 7637:	case on_failure_jump:
        -: 7638:          extract_number_and_incr (&mcnt, &p);
        -: 7639:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
        -: 7640:          break;
        -: 7641:
        -: 7642:	case on_failure_keep_string_jump:
        -: 7643:          extract_number_and_incr (&mcnt, &p);
        -: 7644:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
        -: 7645:          break;
        -: 7646:
        -: 7647:	case dummy_failure_jump:
        -: 7648:          extract_number_and_incr (&mcnt, &p);
        -: 7649:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
        -: 7650:          break;
        -: 7651:
        -: 7652:	case push_dummy_failure:
        -: 7653:          printf ("/push_dummy_failure");
        -: 7654:          break;
        -: 7655:
        -: 7656:        case maybe_pop_jump:
        -: 7657:          extract_number_and_incr (&mcnt, &p);
        -: 7658:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
        -: 7659:	  break;
        -: 7660:
        -: 7661:        case pop_failure_jump:
        -: 7662:	  extract_number_and_incr (&mcnt, &p);
        -: 7663:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
        -: 7664:	  break;
        -: 7665:
        -: 7666:        case jump_past_alt:
        -: 7667:	  extract_number_and_incr (&mcnt, &p);
        -: 7668:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
        -: 7669:	  break;
        -: 7670:
        -: 7671:        case jump:
        -: 7672:	  extract_number_and_incr (&mcnt, &p);
        -: 7673:  	  printf ("/jump to %d", p + mcnt - start);
        -: 7674:	  break;
        -: 7675:
        -: 7676:        case succeed_n:
        -: 7677:          extract_number_and_incr (&mcnt, &p);
        -: 7678:#ifndef FAULTY_F_KP_3
        -: 7679:	/* nothing here */
        -: 7680:#else
        -: 7681:	  p1 = p + mcnt;
        -: 7682:#endif
        -: 7683:          extract_number_and_incr (&mcnt2, &p);
        -: 7684:	  printf ("/succeed_n to %d, %d times", p1 - start, mcnt2);
        -: 7685:          break;
        -: 7686:
        -: 7687:        case jump_n:
        -: 7688:          extract_number_and_incr (&mcnt, &p);
        -: 7689:	  p1 = p + mcnt;
        -: 7690:          extract_number_and_incr (&mcnt2, &p);
        -: 7691:	  printf ("/jump_n to %d, %d times", p1 - start, mcnt2);
        -: 7692:          break;
        -: 7693:
        -: 7694:        case set_number_at:
        -: 7695:          extract_number_and_incr (&mcnt, &p);
        -: 7696:	  p1 = p + mcnt;
        -: 7697:          extract_number_and_incr (&mcnt2, &p);
        -: 7698:	  printf ("/set_number_at location %d to %d", p1 - start, mcnt2);
        -: 7699:          break;
        -: 7700:
        -: 7701:        case wordbound:
        -: 7702:	  printf ("/wordbound");
        -: 7703:	  break;
        -: 7704:
        -: 7705:	case notwordbound:
        -: 7706:	  printf ("/notwordbound");
        -: 7707:          break;
        -: 7708:
        -: 7709:	case wordbeg:
        -: 7710:	  printf ("/wordbeg");
        -: 7711:	  break;
        -: 7712:
        -: 7713:	case wordend:
        -: 7714:	  printf ("/wordend");
        -: 7715:
        -: 7716:#ifdef emacs
        -: 7717:	case before_dot:
        -: 7718:	  printf ("/before_dot");
        -: 7719:          break;
        -: 7720:
        -: 7721:	case at_dot:
        -: 7722:	  printf ("/at_dot");
        -: 7723:          break;
        -: 7724:
        -: 7725:	case after_dot:
        -: 7726:	  printf ("/after_dot");
        -: 7727:          break;
        -: 7728:
        -: 7729:	case syntaxspec:
        -: 7730:          printf ("/syntaxspec");
        -: 7731:	  mcnt = *p++;
        -: 7732:	  printf ("/%d", mcnt);
        -: 7733:          break;
        -: 7734:
        -: 7735:	case notsyntaxspec:
        -: 7736:          printf ("/notsyntaxspec");
        -: 7737:	  mcnt = *p++;
        -: 7738:	  printf ("/%d", mcnt);
        -: 7739:	  break;
        -: 7740:#endif /* emacs */
        -: 7741:
        -: 7742:	case wordchar:
        -: 7743:	  printf ("/wordchar");
        -: 7744:          break;
        -: 7745:
        -: 7746:	case notwordchar:
        -: 7747:	  printf ("/notwordchar");
        -: 7748:          break;
        -: 7749:
        -: 7750:	case begbuf:
        -: 7751:	  printf ("/begbuf");
        -: 7752:          break;
        -: 7753:
        -: 7754:	case endbuf:
        -: 7755:	  printf ("/endbuf");
        -: 7756:          break;
        -: 7757:
        -: 7758:        default:
        -: 7759:          printf ("?%d", *(p-1));
        -: 7760:	}
        -: 7761:
        -: 7762:      putchar ('\n');
        -: 7763:    }
        -: 7764:
        -: 7765:  printf ("%d:\tend of pattern.\n", p - start);
        -: 7766:}
        -: 7767:
        -: 7768:
        -: 7769:void
        -: 7770:print_compiled_pattern (bufp)
        -: 7771:    struct re_pattern_buffer *bufp;
        -: 7772:{
        -: 7773:  unsigned char *buffer = bufp->buffer;
        -: 7774:
        -: 7775:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
        -: 7776:  printf ("%ld bytes used/%ld bytes allocated.\n",
        -: 7777:	  bufp->used, bufp->allocated);
        -: 7778:
        -: 7779:  if (bufp->fastmap_accurate && bufp->fastmap)
        -: 7780:    {
        -: 7781:      printf ("fastmap: ");
        -: 7782:      print_fastmap (bufp->fastmap);
        -: 7783:    }
        -: 7784:
        -: 7785:  printf ("re_nsub: %d\t", bufp->re_nsub);
        -: 7786:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
        -: 7787:  printf ("can_be_null: %d\t", bufp->can_be_null);
        -: 7788:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
        -: 7789:  printf ("no_sub: %d\t", bufp->no_sub);
        -: 7790:  printf ("not_bol: %d\t", bufp->not_bol);
        -: 7791:  printf ("not_eol: %d\t", bufp->not_eol);
        -: 7792:  printf ("syntax: %lx\n", bufp->syntax);
        -: 7793:  /* Perhaps we should print the translate table?  */
        -: 7794:}
        -: 7795:
        -: 7796:
        -: 7797:void
        -: 7798:print_double_string (where, string1, size1, string2, size2)
        -: 7799:    const char *where;
        -: 7800:    const char *string1;
        -: 7801:    const char *string2;
        -: 7802:    int size1;
        -: 7803:    int size2;
        -: 7804:{
        -: 7805:  int this_char;
        -: 7806:
        -: 7807:  if (where == NULL)
        -: 7808:    printf ("(null)");
        -: 7809:  else
        -: 7810:    {
        -: 7811:      if (FIRST_STRING_P (where))
        -: 7812:        {
        -: 7813:          for (this_char = where - string1; this_char < size1; this_char++)
        -: 7814:            putchar (string1[this_char]);
        -: 7815:
        -: 7816:          where = string2;
        -: 7817:        }
        -: 7818:
        -: 7819:      for (this_char = where - string2; this_char < size2; this_char++)
        -: 7820:        putchar (string2[this_char]);
        -: 7821:    }
        -: 7822:}
        -: 7823:
        -: 7824:void
        -: 7825:printchar (c)
        -: 7826:     int c;
        -: 7827:{
        -: 7828:  putc (c, stderr);
        -: 7829:}
        -: 7830:
        -: 7831:#else /* not DEBUG */
        -: 7832:
        -: 7833:#undef assert
        -: 7834:#define assert(e)
        -: 7835:
        -: 7836:#define DEBUG_STATEMENT(e)
        -: 7837:#define DEBUG_PRINT1(x)
        -: 7838:#define DEBUG_PRINT2(x1, x2)
        -: 7839:#define DEBUG_PRINT3(x1, x2, x3)
        -: 7840:#define DEBUG_PRINT4(x1, x2, x3, x4)
        -: 7841:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
        -: 7842:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
        -: 7843:
        -: 7844:#endif /* not DEBUG */
        -: 7845:
        -: 7846:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
        -: 7847:   also be assigned to arbitrarily: each pattern buffer stores its own
        -: 7848:   syntax, so it can be changed between regex compilations.  */
        -: 7849:/* This has no initializer because initialized variables in Emacs
        -: 7850:   become read-only after dumping.  */
        -: 7851:reg_syntax_t re_syntax_options;
        -: 7852:
        -: 7853:
        -: 7854:/* Specify the precise syntax of regexps for compilation.  This provides
        -: 7855:   for compatibility for various utilities which historically have
        -: 7856:   different, incompatible syntaxes.
        -: 7857:
        -: 7858:   The argument SYNTAX is a bit mask comprised of the various bits
        -: 7859:   defined in regex.h.  We return the old syntax.  */
        -: 7860:
        -: 7861:reg_syntax_t
        1: 7862:re_set_syntax (syntax)
        -: 7863:    reg_syntax_t syntax;
        -: 7864:{
        1: 7865:  reg_syntax_t ret = re_syntax_options;
        -: 7866:
        1: 7867:  re_syntax_options = syntax;
        -: 7868:#ifdef DEBUG
        -: 7869:  if (syntax & RE_DEBUG)
        -: 7870:    debug = 1;
        -: 7871:  else if (debug) /* was on but now is not */
        -: 7872:    debug = 0;
        -: 7873:#endif /* DEBUG */
        1: 7874:  return ret;
        -: 7875:}
        -: 7876:
        -: 7877:/* This table gives an error message for each of the error codes listed
        -: 7878:   in regex.h.  Obviously the order here has to be same as there.
        -: 7879:   POSIX doesn't require that we do anything for REG_NOERROR,
        -: 7880:   but why not be nice?  */
        -: 7881:
        -: 7882:static const char *re_error_msgid[] =
        -: 7883:  {
        -: 7884:    gettext_noop ("Success"),	/* REG_NOERROR */
        -: 7885:    gettext_noop ("No match"),	/* REG_NOMATCH */
        -: 7886:    gettext_noop ("Invalid regular expression"), /* REG_BADPAT */
        -: 7887:    gettext_noop ("Invalid collation character"), /* REG_ECOLLATE */
        -: 7888:    gettext_noop ("Invalid character class name"), /* REG_ECTYPE */
        -: 7889:    gettext_noop ("Trailing backslash"), /* REG_EESCAPE */
        -: 7890:    gettext_noop ("Invalid back reference"), /* REG_ESUBREG */
        -: 7891:    gettext_noop ("Unmatched [ or [^"),	/* REG_EBRACK */
        -: 7892:    gettext_noop ("Unmatched ( or \\("), /* REG_EPAREN */
        -: 7893:    gettext_noop ("Unmatched \\{"), /* REG_EBRACE */
        -: 7894:    gettext_noop ("Invalid content of \\{\\}"), /* REG_BADBR */
        -: 7895:    gettext_noop ("Invalid range end"),	/* REG_ERANGE */
        -: 7896:    gettext_noop ("Memory exhausted"), /* REG_ESPACE */
        -: 7897:    gettext_noop ("Invalid preceding regular expression"), /* REG_BADRPT */
        -: 7898:    gettext_noop ("Premature end of regular expression"), /* REG_EEND */
        -: 7899:    gettext_noop ("Regular expression too big"), /* REG_ESIZE */
        -: 7900:    gettext_noop ("Unmatched ) or \\)"), /* REG_ERPAREN */
        -: 7901:  };
        -: 7902:
        -: 7903:/* Avoiding alloca during matching, to placate r_alloc.  */
        -: 7904:
        -: 7905:/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the
        -: 7906:   searching and matching functions should not call alloca.  On some
        -: 7907:   systems, alloca is implemented in terms of malloc, and if we're
        -: 7908:   using the relocating allocator routines, then malloc could cause a
        -: 7909:   relocation, which might (if the strings being searched are in the
        -: 7910:   ralloc heap) shift the data out from underneath the regexp
        -: 7911:   routines.
        -: 7912:
        -: 7913:   Here's another reason to avoid allocation: Emacs
        -: 7914:   processes input from X in a signal handler; processing X input may
        -: 7915:   call malloc; if input arrives while a matching routine is calling
        -: 7916:   malloc, then we're scrod.  But Emacs can't just block input while
        -: 7917:   calling matching routines; then we don't notice interrupts when
        -: 7918:   they come in.  So, Emacs blocks input around all regexp calls
        -: 7919:   except the matching calls, which it leaves unprotected, in the
        -: 7920:   faith that they will not malloc.  */
        -: 7921:
        -: 7922:/* Normally, this is fine.  */
        -: 7923:#define MATCH_MAY_ALLOCATE
        -: 7924:
        -: 7925:/* When using GNU C, we are not REALLY using the C alloca, no matter
        -: 7926:   what config.h may say.  So don't take precautions for it.  */
        -: 7927:#ifdef __GNUC__
        -: 7928:#undef C_ALLOCA
        -: 7929:#endif
        -: 7930:
        -: 7931:/* The match routines may not allocate if (1) they would do it with malloc
        -: 7932:   and (2) it's not safe for them to use malloc.
        -: 7933:   Note that if REL_ALLOC is defined, matching would not use malloc for the
        -: 7934:   failure stack, but we would still use it for the register vectors;
        -: 7935:   so REL_ALLOC should not affect this.  */
        -: 7936:#if (defined (C_ALLOCA) || defined (REGEX_MALLOC)) && defined (emacs)
        -: 7937:#undef MATCH_MAY_ALLOCATE
        -: 7938:#endif
        -: 7939:
        -: 7940:
        -: 7941:/* Failure stack declarations and macros; both re_compile_fastmap and
        -: 7942:   re_match_2 use a failure stack.  These have to be macros because of
        -: 7943:   REGEX_ALLOCATE_STACK.  */
        -: 7944:
        -: 7945:
        -: 7946:/* Number of failure points for which to initially allocate space
        -: 7947:   when matching.  If this number is exceeded, we allocate more
        -: 7948:   space, so it is not a hard limit.  */
        -: 7949:#ifndef INIT_FAILURE_ALLOC
        -: 7950:#define INIT_FAILURE_ALLOC 5
        -: 7951:#endif
        -: 7952:
        -: 7953:/* Roughly the maximum number of failure points on the stack.  Would be
        -: 7954:   exactly that if always used MAX_FAILURE_ITEMS items each time we failed.
        -: 7955:   This is a variable only so users of regex can assign to it; we never
        -: 7956:   change it ourselves.  */
        -: 7957:
        -: 7958:#ifdef INT_IS_16BIT
        -: 7959:
        -: 7960:#if defined (MATCH_MAY_ALLOCATE)
        -: 7961:/* 4400 was enough to cause a crash on Alpha OSF/1,
        -: 7962:   whose default stack limit is 2mb.  */
        -: 7963:long int re_max_failures = 4000;
        -: 7964:#else
        -: 7965:long int re_max_failures = 2000;
        -: 7966:#endif
        -: 7967:
        -: 7968:union fail_stack_elt
        -: 7969:{
        -: 7970:  unsigned char *pointer;
        -: 7971:  long int integer;
        -: 7972:};
        -: 7973:
        -: 7974:typedef union fail_stack_elt fail_stack_elt_t;
        -: 7975:
        -: 7976:typedef struct
        -: 7977:{
        -: 7978:  fail_stack_elt_t *stack;
        -: 7979:  unsigned long int size;
        -: 7980:  unsigned long int avail;		/* Offset of next open position.  */
        -: 7981:} fail_stack_type;
        -: 7982:
        -: 7983:#else /* not INT_IS_16BIT */
        -: 7984:
        -: 7985:#if defined (MATCH_MAY_ALLOCATE)
        -: 7986:/* 4400 was enough to cause a crash on Alpha OSF/1,
        -: 7987:   whose default stack limit is 2mb.  */
        -: 7988:int re_max_failures = 20000;
        -: 7989:#else
        -: 7990:int re_max_failures = 2000;
        -: 7991:#endif
        -: 7992:
        -: 7993:union fail_stack_elt
        -: 7994:{
        -: 7995:  unsigned char *pointer;
        -: 7996:  int integer;
        -: 7997:};
        -: 7998:
        -: 7999:typedef union fail_stack_elt fail_stack_elt_t;
        -: 8000:
        -: 8001:typedef struct
        -: 8002:{
        -: 8003:  fail_stack_elt_t *stack;
        -: 8004:  unsigned size;
        -: 8005:  unsigned avail;			/* Offset of next open position.  */
        -: 8006:} fail_stack_type;
        -: 8007:
        -: 8008:#endif /* INT_IS_16BIT */
        -: 8009:
        -: 8010:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
        -: 8011:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
        -: 8012:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
        -: 8013:
        -: 8014:
        -: 8015:/* Define macros to initialize and free the failure stack.
        -: 8016:   Do `return -2' if the alloc fails.  */
        -: 8017:
        -: 8018:#ifdef MATCH_MAY_ALLOCATE
        -: 8019:#define INIT_FAIL_STACK()						\
        -: 8020:  do {									\
        -: 8021:    fail_stack.stack = (fail_stack_elt_t *)				\
        -: 8022:      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
        -: 8023:									\
        -: 8024:    if (fail_stack.stack == NULL)					\
        -: 8025:      return -2;							\
        -: 8026:									\
        -: 8027:    fail_stack.size = INIT_FAILURE_ALLOC;				\
        -: 8028:    fail_stack.avail = 0;						\
        -: 8029:  } while (0)
        -: 8030:
        -: 8031:#define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)
        -: 8032:#else
        -: 8033:#define INIT_FAIL_STACK()						\
        -: 8034:  do {									\
        -: 8035:    fail_stack.avail = 0;						\
        -: 8036:  } while (0)
        -: 8037:
        -: 8038:#define RESET_FAIL_STACK()
        -: 8039:#endif
        -: 8040:
        -: 8041:
        -: 8042:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
        -: 8043:
        -: 8044:   Return 1 if succeeds, and 0 if either ran out of memory
        -: 8045:   allocating space for it or it was already too large.
        -: 8046:
        -: 8047:   REGEX_REALLOCATE_STACK requires `destination' be declared.   */
        -: 8048:
        -: 8049:#define DOUBLE_FAIL_STACK(fail_stack)					\
        -: 8050:  ((fail_stack).size > (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\
        -: 8051:   ? 0									\
        -: 8052:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
        -: 8053:        REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\
        -: 8054:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
        -: 8055:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
        -: 8056:									\
        -: 8057:      (fail_stack).stack == NULL					\
        -: 8058:      ? 0								\
        -: 8059:      : ((fail_stack).size <<= 1, 					\
        -: 8060:         1)))
        -: 8061:
        -: 8062:
        -: 8063:/* Push pointer POINTER on FAIL_STACK.
        -: 8064:   Return 1 if was able to do so and 0 if ran out of memory allocating
        -: 8065:   space to do so.  */
        -: 8066:#define PUSH_PATTERN_OP(POINTER, FAIL_STACK)				\
        -: 8067:  ((FAIL_STACK_FULL ()							\
        -: 8068:    && !DOUBLE_FAIL_STACK (FAIL_STACK))					\
        -: 8069:   ? 0									\
        -: 8070:   : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,	\
        -: 8071:      1))
        -: 8072:
        -: 8073:/* Push a pointer value onto the failure stack.
        -: 8074:   Assumes the variable `fail_stack'.  Probably should only
        -: 8075:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 8076:#define PUSH_FAILURE_POINTER(item)					\
        -: 8077:  fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)
        -: 8078:
        -: 8079:/* This pushes an integer-valued item onto the failure stack.
        -: 8080:   Assumes the variable `fail_stack'.  Probably should only
        -: 8081:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 8082:#define PUSH_FAILURE_INT(item)					\
        -: 8083:  fail_stack.stack[fail_stack.avail++].integer = (item)
        -: 8084:
        -: 8085:/* Push a fail_stack_elt_t value onto the failure stack.
        -: 8086:   Assumes the variable `fail_stack'.  Probably should only
        -: 8087:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 8088:#define PUSH_FAILURE_ELT(item)					\
        -: 8089:  fail_stack.stack[fail_stack.avail++] =  (item)
        -: 8090:
        -: 8091:/* These three POP... operations complement the three PUSH... operations.
        -: 8092:   All assume that `fail_stack' is nonempty.  */
        -: 8093:#define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer
        -: 8094:#define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer
        -: 8095:#define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]
        -: 8096:
        -: 8097:/* Used to omit pushing failure point id's when we're not debugging.  */
        -: 8098:#ifdef DEBUG
        -: 8099:#define DEBUG_PUSH PUSH_FAILURE_INT
        -: 8100:#define DEBUG_POP(item_addr) (item_addr)->integer = POP_FAILURE_INT ()
        -: 8101:#else
        -: 8102:#define DEBUG_PUSH(item)
        -: 8103:#define DEBUG_POP(item_addr)
        -: 8104:#endif
        -: 8105:
        -: 8106:
        -: 8107:/* Push the information about the state we will need
        -: 8108:   if we ever fail back to it.
        -: 8109:
        -: 8110:   Requires variables fail_stack, regstart, regend, reg_info, and
        -: 8111:   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
        -: 8112:   declared.
        -: 8113:
        -: 8114:   Does `return FAILURE_CODE' if runs out of memory.  */
        -: 8115:
        -: 8116:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
        -: 8117:  do {									\
        -: 8118:    char *destination;							\
        -: 8119:    /* Must be int, so when we don't save any registers, the arithmetic	\
        -: 8120:       of 0 + -1 isn't done as unsigned.  */				\
        -: 8121:    /* Can't be int, since there is not a shred of a guarantee that int	\
        -: 8122:       is wide enough to hold a value of something to which pointer can	\
        -: 8123:       be assigned */							\
        -: 8124:    s_reg_t this_reg;							\
        -: 8125:    									\
        -: 8126:    DEBUG_STATEMENT (failure_id++);					\
        -: 8127:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
        -: 8128:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
        -: 8129:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
        -: 8130:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
        -: 8131:									\
        -: 8132:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
        -: 8133:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        -: 8134:									\
        -: 8135:    /* Ensure we have enough space allocated for what we will push.  */	\
        -: 8136:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
        -: 8137:      {									\
        -: 8138:        if (!DOUBLE_FAIL_STACK (fail_stack))				\
        -: 8139:          return failure_code;						\
        -: 8140:									\
        -: 8141:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        -: 8142:		       (fail_stack).size);				\
        -: 8143:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
        -: 8144:      }									\
        -: 8145:									\
        -: 8146:    /* Push the info, starting with the registers.  */			\
        -: 8147:    DEBUG_PRINT1 ("\n");						\
        -: 8148:									\
        -: 8149:    if (1)								\
        -: 8150:      for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; \
        -: 8151:	   this_reg++)							\
        -: 8152:	{								\
        -: 8153:	  DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);		\
        -: 8154:	  DEBUG_STATEMENT (num_regs_pushed++);				\
        -: 8155:									\
        -: 8156:	  DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);	\
        -: 8157:	  PUSH_FAILURE_POINTER (regstart[this_reg]);			\
        -: 8158:									\
        -: 8159:	  DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
        -: 8160:	  PUSH_FAILURE_POINTER (regend[this_reg]);			\
        -: 8161:									\
        -: 8162:	  DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
        -: 8163:	  DEBUG_PRINT2 (" match_null=%d",				\
        -: 8164:			REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
        -: 8165:	  DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        -: 8166:	  DEBUG_PRINT2 (" matched_something=%d",			\
        -: 8167:			MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 8168:	  DEBUG_PRINT2 (" ever_matched=%d",				\
        -: 8169:			EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 8170:	  DEBUG_PRINT1 ("\n");						\
        -: 8171:	  PUSH_FAILURE_ELT (reg_info[this_reg].word);			\
        -: 8172:	}								\
        -: 8173:									\
        -: 8174:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
        -: 8175:    PUSH_FAILURE_INT (lowest_active_reg);				\
        -: 8176:									\
        -: 8177:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
        -: 8178:    PUSH_FAILURE_INT (highest_active_reg);				\
        -: 8179:									\
        -: 8180:    DEBUG_PRINT2 ("  Pushing pattern 0x%x:\n", pattern_place);		\
        -: 8181:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
        -: 8182:    PUSH_FAILURE_POINTER (pattern_place);				\
        -: 8183:									\
        -: 8184:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
        -: 8185:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
        -: 8186:				 size2);				\
        -: 8187:    DEBUG_PRINT1 ("'\n");						\
        -: 8188:    PUSH_FAILURE_POINTER (string_place);				\
        -: 8189:									\
        -: 8190:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
        -: 8191:    DEBUG_PUSH (failure_id);						\
        -: 8192:  } while (0)
        -: 8193:
        -: 8194:/* This is the number of items that are pushed and popped on the stack
        -: 8195:   for each register.  */
        -: 8196:#define NUM_REG_ITEMS  3
        -: 8197:
        -: 8198:/* Individual items aside from the registers.  */
        -: 8199:#ifdef DEBUG
        -: 8200:#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
        -: 8201:#else
        -: 8202:#define NUM_NONREG_ITEMS 4
        -: 8203:#endif
        -: 8204:
        -: 8205:/* We push at most this many items on the stack.  */
        -: 8206:/* We used to use (num_regs - 1), which is the number of registers
        -: 8207:   this regexp will save; but that was changed to 5
        -: 8208:   to avoid stack overflow for a regexp with lots of parens.  */
        -: 8209:#define MAX_FAILURE_ITEMS (5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
        -: 8210:
        -: 8211:/* We actually push this many items.  */
        -: 8212:#define NUM_FAILURE_ITEMS				\
        -: 8213:  (((0							\
        -: 8214:     ? 0 : highest_active_reg - lowest_active_reg + 1)	\
        -: 8215:    * NUM_REG_ITEMS)					\
        -: 8216:   + NUM_NONREG_ITEMS)
        -: 8217:
        -: 8218:/* How many items can still be added to the stack without overflowing it.  */
        -: 8219:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
        -: 8220:
        -: 8221:
        -: 8222:/* Pops what PUSH_FAIL_STACK pushes.
        -: 8223:
        -: 8224:   We restore into the parameters, all of which should be lvalues:
        -: 8225:     STR -- the saved data position.
        -: 8226:     PAT -- the saved pattern position.
        -: 8227:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
        -: 8228:     REGSTART, REGEND -- arrays of string positions.
        -: 8229:     REG_INFO -- array of information about each subexpression.
        -: 8230:
        -: 8231:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
        -: 8232:   `pend', `string1', `size1', `string2', and `size2'.  */
        -: 8233:
        -: 8234:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
        -: 8235:{									\
        -: 8236:  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
        -: 8237:  s_reg_t this_reg;							\
        -: 8238:  const unsigned char *string_temp;					\
        -: 8239:									\
        -: 8240:  assert (!FAIL_STACK_EMPTY ());					\
        -: 8241:									\
        -: 8242:  /* Remove failure points and point to how many regs pushed.  */	\
        -: 8243:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
        -: 8244:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
        -: 8245:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
        -: 8246:									\
        -: 8247:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
        -: 8248:									\
        -: 8249:  DEBUG_POP (&failure_id);						\
        -: 8250:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
        -: 8251:									\
        -: 8252:  /* If the saved string location is NULL, it came from an		\
        -: 8253:     on_failure_keep_string_jump opcode, and we want to throw away the	\
        -: 8254:     saved NULL, thus retaining our current position in the string.  */	\
        -: 8255:  string_temp = POP_FAILURE_POINTER ();					\
        -: 8256:  if (string_temp != NULL)						\
        -: 8257:    str = (const char *) string_temp;					\
        -: 8258:									\
        -: 8259:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
        -: 8260:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
        -: 8261:  DEBUG_PRINT1 ("'\n");							\
        -: 8262:									\
        -: 8263:  pat = (unsigned char *) POP_FAILURE_POINTER ();			\
        -: 8264:  DEBUG_PRINT2 ("  Popping pattern 0x%x:\n", pat);			\
        -: 8265:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
        -: 8266:									\
        -: 8267:  /* Restore register info.  */						\
        -: 8268:  high_reg = (active_reg_t) POP_FAILURE_INT ();				\
        -: 8269:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
        -: 8270:									\
        -: 8271:  low_reg = (active_reg_t) POP_FAILURE_INT ();				\
        -: 8272:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
        -: 8273:									\
        -: 8274:  if (1)								\
        -: 8275:    for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
        -: 8276:      {									\
        -: 8277:	DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);		\
        -: 8278:									\
        -: 8279:	reg_info[this_reg].word = POP_FAILURE_ELT ();			\
        -: 8280:	DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);	\
        -: 8281:									\
        -: 8282:	regend[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
        -: 8283:	DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
        -: 8284:									\
        -: 8285:	regstart[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
        -: 8286:	DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);	\
        -: 8287:      }									\
        -: 8288:  else									\
        -: 8289:    {									\
        -: 8290:      for (this_reg = highest_active_reg; this_reg > high_reg; this_reg--) \
        -: 8291:	{								\
        -: 8292:	  reg_info[this_reg].word.integer = 0;				\
        -: 8293:	  regend[this_reg] = 0;						\
        -: 8294:	  regstart[this_reg] = 0;					\
        -: 8295:	}								\
        -: 8296:      highest_active_reg = high_reg;					\
        -: 8297:    }									\
        -: 8298:									\
        -: 8299:  set_regs_matched_done = 0;						\
        -: 8300:  DEBUG_STATEMENT (nfailure_points_popped++);				\
        -: 8301:} /* POP_FAILURE_POINT */
        -: 8302:
        -: 8303:
        -: 8304:
        -: 8305:/* Structure for per-register (a.k.a. per-group) information.
        -: 8306:   Other register information, such as the
        -: 8307:   starting and ending positions (which are addresses), and the list of
        -: 8308:   inner groups (which is a bits list) are maintained in separate
        -: 8309:   variables.
        -: 8310:
        -: 8311:   We are making a (strictly speaking) nonportable assumption here: that
        -: 8312:   the compiler will pack our bit fields into something that fits into
        -: 8313:   the type of `word', i.e., is something that fits into one item on the
        -: 8314:   failure stack.  */
        -: 8315:
        -: 8316:
        -: 8317:/* Declarations and macros for re_match_2.  */
        -: 8318:
        -: 8319:typedef union
        -: 8320:{
        -: 8321:  fail_stack_elt_t word;
        -: 8322:  struct
        -: 8323:  {
        -: 8324:      /* This field is one if this group can match the empty string,
        -: 8325:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
        -: 8326:#define MATCH_NULL_UNSET_VALUE 3
        -: 8327:    unsigned match_null_string_p : 2;
        -: 8328:    unsigned is_active : 1;
        -: 8329:    unsigned matched_something : 1;
        -: 8330:    unsigned ever_matched_something : 1;
        -: 8331:  } bits;
        -: 8332:} register_info_type;
        -: 8333:
        -: 8334:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
        -: 8335:#define IS_ACTIVE(R)  ((R).bits.is_active)
        -: 8336:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
        -: 8337:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
        -: 8338:
        -: 8339:
        -: 8340:/* Call this when have matched a real character; it sets `matched' flags
        -: 8341:   for the subexpressions which we are currently inside.  Also records
        -: 8342:   that those subexprs have matched.  */
        -: 8343:#define SET_REGS_MATCHED()						\
        -: 8344:  do									\
        -: 8345:    {									\
        -: 8346:      if (!set_regs_matched_done)					\
        -: 8347:	{								\
        -: 8348:	  active_reg_t r;						\
        -: 8349:	  set_regs_matched_done = 1;					\
        -: 8350:	  for (r = lowest_active_reg; r <= highest_active_reg; r++)	\
        -: 8351:	    {								\
        -: 8352:	      MATCHED_SOMETHING (reg_info[r])				\
        -: 8353:		= EVER_MATCHED_SOMETHING (reg_info[r])			\
        -: 8354:		= 1;							\
        -: 8355:	    }								\
        -: 8356:	}								\
        -: 8357:    }									\
        -: 8358:  while (0)
        -: 8359:
        -: 8360:/* Registers are set to a sentinel when they haven't yet matched.  */
        -: 8361:static char reg_unset_dummy;
        -: 8362:#define REG_UNSET_VALUE (&reg_unset_dummy)
        -: 8363:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
        -: 8364:
        -: 8365:/* Subroutine declarations and macros for regex_compile.  */
        -: 8366:
        -: 8367:static reg_errcode_t regex_compile _RE_ARGS ((const char *pattern, size_t size,
        -: 8368:					      reg_syntax_t syntax,
        -: 8369:					      struct re_pattern_buffer *bufp));
        -: 8370:static void store_op1 _RE_ARGS ((re_opcode_t op, unsigned char *loc, int arg));
        -: 8371:static void store_op2 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 8372:				 int arg1, int arg2));
        -: 8373:static void insert_op1 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 8374:				  int arg, unsigned char *end));
        -: 8375:static void insert_op2 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 8376:				  int arg1, int arg2, unsigned char *end));
        -: 8377:static boolean at_begline_loc_p _RE_ARGS ((const char *pattern, const char *p,
        -: 8378:					   reg_syntax_t syntax));
        -: 8379:static boolean at_endline_loc_p _RE_ARGS ((const char *p, const char *pend,
        -: 8380:					   reg_syntax_t syntax));
        -: 8381:static reg_errcode_t compile_range _RE_ARGS ((const char **p_ptr,
        -: 8382:					      const char *pend,
        -: 8383:					      char *translate,
        -: 8384:					      reg_syntax_t syntax,
        -: 8385:					      unsigned char *b));
        -: 8386:
        -: 8387:/* Fetch the next character in the uncompiled pattern---translating it
        -: 8388:   if necessary.  Also cast from a signed character in the constant
        -: 8389:   string passed to us by the user to an unsigned char that we can use
        -: 8390:   as an array index (in, e.g., `translate').  */
        -: 8391:#ifndef PATFETCH
        -: 8392:#define PATFETCH(c)							\
        -: 8393:  do {if (p == pend) return REG_EEND;					\
        -: 8394:    c = (unsigned char) *p++;						\
        -: 8395:    if (translate) c = (unsigned char) translate[c];			\
        -: 8396:  } while (0)
        -: 8397:#endif
        -: 8398:
        -: 8399:/* Fetch the next character in the uncompiled pattern, with no
        -: 8400:   translation.  */
        -: 8401:#define PATFETCH_RAW(c)							\
        -: 8402:  do {if (p == pend) return REG_EEND;					\
        -: 8403:    c = (unsigned char) *p++; 						\
        -: 8404:  } while (0)
        -: 8405:
        -: 8406:/* Go backwards one character in the pattern.  */
        -: 8407:#define PATUNFETCH p--
        -: 8408:
        -: 8409:
        -: 8410:/* If `translate' is non-null, return translate[D], else just D.  We
        -: 8411:   cast the subscript to translate because some data is declared as
        -: 8412:   `char *', to avoid warnings when a string constant is passed.  But
        -: 8413:   when we use a character as a subscript we must make it unsigned.  */
        -: 8414:#ifndef TRANSLATE
        -: 8415:#define TRANSLATE(d) \
        -: 8416:  (translate ? (char) translate[(unsigned char) (d)] : (d))
        -: 8417:#endif
        -: 8418:
        -: 8419:
        -: 8420:/* Macros for outputting the compiled pattern into `buffer'.  */
        -: 8421:
        -: 8422:/* If the buffer isn't allocated when it comes in, use this.  */
        -: 8423:#define INIT_BUF_SIZE  32
        -: 8424:
        -: 8425:/* Make sure we have at least N more bytes of space in buffer.  */
        -: 8426:#define GET_BUFFER_SPACE(n)						\
        -: 8427:    while ((unsigned long) (b - bufp->buffer + (n)) > bufp->allocated)	\
        -: 8428:      EXTEND_BUFFER ()
        -: 8429:
        -: 8430:/* Make sure we have one more byte of buffer space and then add C to it.  */
        -: 8431:#define BUF_PUSH(c)							\
        -: 8432:  do {									\
        -: 8433:    GET_BUFFER_SPACE (1);						\
        -: 8434:    *b++ = (unsigned char) (c);						\
        -: 8435:  } while (0)
        -: 8436:
        -: 8437:
        -: 8438:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
        -: 8439:#define BUF_PUSH_2(c1, c2)						\
        -: 8440:  do {									\
        -: 8441:    GET_BUFFER_SPACE (2);						\
        -: 8442:    *b++ = (unsigned char) (c1);					\
        -: 8443:    *b++ = (unsigned char) (c2);					\
        -: 8444:  } while (0)
        -: 8445:
        -: 8446:
        -: 8447:/* As with BUF_PUSH_2, except for three bytes.  */
        -: 8448:#define BUF_PUSH_3(c1, c2, c3)						\
        -: 8449:  do {									\
        -: 8450:    GET_BUFFER_SPACE (3);						\
        -: 8451:    *b++ = (unsigned char) (c1);					\
        -: 8452:    *b++ = (unsigned char) (c2);					\
        -: 8453:    *b++ = (unsigned char) (c3);					\
        -: 8454:  } while (0)
        -: 8455:
        -: 8456:
        -: 8457:/* Store a jump with opcode OP at LOC to location TO.  We store a
        -: 8458:   relative address offset by the three bytes the jump itself occupies.  */
        -: 8459:#define STORE_JUMP(op, loc, to) \
        -: 8460:  store_op1 (op, loc, (int) ((to) - (loc) - 3))
        -: 8461:
        -: 8462:/* Likewise, for a two-argument jump.  */
        -: 8463:#define STORE_JUMP2(op, loc, to, arg) \
        -: 8464:  store_op2 (op, loc, (int) ((to) - (loc) - 3), arg)
        -: 8465:
        -: 8466:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
        -: 8467:#define INSERT_JUMP(op, loc, to) \
        -: 8468:  insert_op1 (op, loc, (int) ((to) - (loc) - 3), b)
        -: 8469:
        -: 8470:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
        -: 8471:#define INSERT_JUMP2(op, loc, to, arg) \
        -: 8472:  insert_op2 (op, loc, (int) ((to) - (loc) - 3), arg, b)
        -: 8473:
        -: 8474:
        -: 8475:/* This is not an arbitrary limit: the arguments which represent offsets
        -: 8476:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
        -: 8477:   be too small, many things would have to change.  */
        -: 8478:/* Any other compiler which, like MSC, has allocation limit below 2^16
        -: 8479:   bytes will have to use approach similar to what was done below for
        -: 8480:   MSC and drop MAX_BUF_SIZE a bit.  Otherwise you may end up
        -: 8481:   reallocating to 0 bytes.  Such thing is not going to work too well.
        -: 8482:   You have been warned!!  */
        -: 8483:#undef   REALLOC  
        -: 8484:#if defined(_MSC_VER)  && !defined(WIN32)
        -: 8485:/* Microsoft C 16-bit versions limit malloc to approx 65512 bytes.
        -: 8486:   The REALLOC define eliminates a flurry of conversion warnings,
        -: 8487:   but is not required. */
        -: 8488:#define MAX_BUF_SIZE  65500L
        -: 8489:#define REALLOC(p,s) realloc ((p), (size_t) (s))
        -: 8490:#else
        -: 8491:#define MAX_BUF_SIZE (1L << 16)
        -: 8492:#define REALLOC(p,s) realloc ((p), (s))
        -: 8493:#endif
        -: 8494:
        -: 8495:/* Extend the buffer by twice its current size via realloc and
        -: 8496:   reset the pointers that pointed into the old block to point to the
        -: 8497:   correct places in the new one.  If extending the buffer results in it
        -: 8498:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
        -: 8499:#define EXTEND_BUFFER()							\
        -: 8500:  do { 									\
        -: 8501:    unsigned char *old_buffer = bufp->buffer;				\
        -: 8502:    if (bufp->allocated == MAX_BUF_SIZE) 				\
        -: 8503:      return REG_ESIZE;							\
        -: 8504:    bufp->allocated <<= 1;						\
        -: 8505:    if (bufp->allocated > MAX_BUF_SIZE)					\
        -: 8506:      bufp->allocated = MAX_BUF_SIZE; 					\
        -: 8507:    bufp->buffer = (unsigned char *) REALLOC (bufp->buffer, bufp->allocated);\
        -: 8508:    if (bufp->buffer == NULL)						\
        -: 8509:      return REG_ESPACE;						\
        -: 8510:    /* If the buffer moved, move all the pointers into it.  */		\
        -: 8511:    if (old_buffer != bufp->buffer)					\
        -: 8512:      {									\
        -: 8513:        b = (b - old_buffer) + bufp->buffer;				\
        -: 8514:        begalt = (begalt - old_buffer) + bufp->buffer;			\
        -: 8515:        if (fixup_alt_jump)						\
        -: 8516:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
        -: 8517:        if (laststart)							\
        -: 8518:          laststart = (laststart - old_buffer) + bufp->buffer;		\
        -: 8519:        if (pending_exact)						\
        -: 8520:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
        -: 8521:      }									\
        -: 8522:  } while (0)
        -: 8523:
        -: 8524:
        -: 8525:/* Since we have one byte reserved for the register number argument to
        -: 8526:   {start,stop}_memory, the maximum number of groups we can report
        -: 8527:   things about is what fits in that byte.  */
        -: 8528:#define MAX_REGNUM 255
        -: 8529:
        -: 8530:/* But patterns can have more than `MAX_REGNUM' registers.  We just
        -: 8531:   ignore the excess.  */
        -: 8532:typedef unsigned regnum_t;
        -: 8533:
        -: 8534:
        -: 8535:/* Macros for the compile stack.  */
        -: 8536:
        -: 8537:/* Since offsets can go either forwards or backwards, this type needs to
        -: 8538:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
        -: 8539:/* int may be not enough when sizeof(int) == 2.  */
        -: 8540:typedef long pattern_offset_t;
        -: 8541:
        -: 8542:typedef struct
        -: 8543:{
        -: 8544:  pattern_offset_t begalt_offset;
        -: 8545:  pattern_offset_t fixup_alt_jump;
        -: 8546:  pattern_offset_t inner_group_offset;
        -: 8547:  pattern_offset_t laststart_offset;
        -: 8548:  regnum_t regnum;
        -: 8549:} compile_stack_elt_t;
        -: 8550:
        -: 8551:
        -: 8552:typedef struct
        -: 8553:{
        -: 8554:  compile_stack_elt_t *stack;
        -: 8555:  unsigned size;
        -: 8556:  unsigned avail;			/* Offset of next open position.  */
        -: 8557:} compile_stack_type;
        -: 8558:
        -: 8559:
        -: 8560:#define INIT_COMPILE_STACK_SIZE 32
        -: 8561:
        -: 8562:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
        -: 8563:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
        -: 8564:
        -: 8565:/* The next available element.  */
        -: 8566:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
        -: 8567:
        -: 8568:
        -: 8569:/* Set the bit for character C in a list.  */
        -: 8570:#define SET_LIST_BIT(c)                               \
        -: 8571:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
        -: 8572:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
        -: 8573:
        -: 8574:
        -: 8575:/* Get the next unsigned number in the uncompiled pattern.  */
        -: 8576:#define GET_UNSIGNED_NUMBER(num) 					\
        -: 8577:  { if (p != pend)							\
        -: 8578:     {									\
        -: 8579:       PATFETCH (c); 							\
        -: 8580:       while (ISDIGIT (c)) 						\
        -: 8581:         { 								\
        -: 8582:           if (num < 0)							\
        -: 8583:              num = 0;							\
        -: 8584:           num = num * 10 + c - '0'; 					\
        -: 8585:           if (p == pend) 						\
        -: 8586:              break; 							\
        -: 8587:           PATFETCH (c);						\
        -: 8588:         } 								\
        -: 8589:       } 								\
        -: 8590:    }
        -: 8591:
        -: 8592:#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
        -: 8593:/* The GNU C library provides support for user-defined character classes
        -: 8594:   and the functions from ISO C amendement 1.  */
        -: 8595:# ifdef CHARCLASS_NAME_MAX
        -: 8596:#  define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
        -: 8597:# else
        -: 8598:/* This shouldn't happen but some implementation might still have this
        -: 8599:   problem.  Use a reasonable default value.  */
        -: 8600:#  define CHAR_CLASS_MAX_LENGTH 256
        -: 8601:# endif
        -: 8602:
        -: 8603:# define IS_CHAR_CLASS(string) wctype (string)
        -: 8604:#else
        -: 8605:# define CHAR_CLASS_MAX_LENGTH  256 /* Namely, `xdigit'.  */
        -: 8606:
        -: 8607:# define IS_CHAR_CLASS(string)						\
        -: 8608:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
        -: 8609:    || STREQ (string, "lower") || STREQ (string, "digit")		\
        -: 8610:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
        -: 8611:    || STREQ (string, "space") || STREQ (string, "print")		\
        -: 8612:    || STREQ (string, "punct") || STREQ (string, "graph")		\
        -: 8613:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
        -: 8614:#endif
        -: 8615:
        -: 8616:#ifndef MATCH_MAY_ALLOCATE
        -: 8617:
        -: 8618:/* If we cannot allocate large objects within re_match_2_internal,
        -: 8619:   we make the fail stack and register vectors global.
        -: 8620:   The fail stack, we grow to the maximum size when a regexp
        -: 8621:   is compiled.
        -: 8622:   The register vectors, we adjust in size each time we
        -: 8623:   compile a regexp, according to the number of registers it needs.  */
        -: 8624:
        -: 8625:static fail_stack_type fail_stack;
        -: 8626:
        -: 8627:/* Size with which the following vectors are currently allocated.
        -: 8628:   That is so we can make them bigger as needed,
        -: 8629:   but never make them smaller.  */
        -: 8630:static int regs_allocated_size;
        -: 8631:
        -: 8632:static const char **     regstart, **     regend;
        -: 8633:static const char ** old_regstart, ** old_regend;
        -: 8634:static const char **best_regstart, **best_regend;
        -: 8635:static register_info_type *reg_info;
        -: 8636:static const char **reg_dummy;
        -: 8637:static register_info_type *reg_info_dummy;
        -: 8638:
        -: 8639:/* Make the register vectors big enough for NUM_REGS registers,
        -: 8640:   but don't make them smaller.  */
        -: 8641:
        -: 8642:static
        -: 8643:regex_grow_registers (num_regs)
        -: 8644:     int num_regs;
        -: 8645:{
        -: 8646:  if (num_regs > regs_allocated_size)
        -: 8647:    {
        -: 8648:      RETALLOC_IF (regstart,	 num_regs, const char *);
        -: 8649:      RETALLOC_IF (regend,	 num_regs, const char *);
        -: 8650:      RETALLOC_IF (old_regstart, num_regs, const char *);
        -: 8651:      RETALLOC_IF (old_regend,	 num_regs, const char *);
        -: 8652:      RETALLOC_IF (best_regstart, num_regs, const char *);
        -: 8653:      RETALLOC_IF (best_regend,	 num_regs, const char *);
        -: 8654:      RETALLOC_IF (reg_info,	 num_regs, register_info_type);
        -: 8655:      RETALLOC_IF (reg_dummy,	 num_regs, const char *);
        -: 8656:      RETALLOC_IF (reg_info_dummy, num_regs, register_info_type);
        -: 8657:
        -: 8658:      regs_allocated_size = num_regs;
        -: 8659:    }
        -: 8660:}
        -: 8661:
        -: 8662:#endif /* not MATCH_MAY_ALLOCATE */
        -: 8663:
        -: 8664:static boolean group_in_compile_stack _RE_ARGS ((compile_stack_type
        -: 8665:						 compile_stack,
        -: 8666:						 regnum_t regnum));
        -: 8667:
        -: 8668:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
        -: 8669:   Returns one of error codes defined in `regex.h', or zero for success.
        -: 8670:
        -: 8671:   Assumes the `allocated' (and perhaps `buffer') and `translate'
        -: 8672:   fields are set in BUFP on entry.
        -: 8673:
        -: 8674:   If it succeeds, results are put in BUFP (if it returns an error, the
        -: 8675:   contents of BUFP are undefined):
        -: 8676:     `buffer' is the compiled pattern;
        -: 8677:     `syntax' is set to SYNTAX;
        -: 8678:     `used' is set to the length of the compiled pattern;
        -: 8679:     `fastmap_accurate' is zero;
        -: 8680:     `re_nsub' is the number of subexpressions in PATTERN;
        -: 8681:     `not_bol' and `not_eol' are zero;
        -: 8682:
        -: 8683:   The `fastmap' and `newline_anchor' fields are neither
        -: 8684:   examined nor set.  */
        -: 8685:
        -: 8686:/* Return, freeing storage we allocated.  */
        -: 8687:#define FREE_STACK_RETURN(value)		\
        -: 8688:  return (free (compile_stack.stack), value)
        -: 8689:
        -: 8690:static reg_errcode_t
        1: 8691:regex_compile (pattern, size, syntax, bufp)
        -: 8692:     const char *pattern;
        -: 8693:     size_t size;
        -: 8694:     reg_syntax_t syntax;
        -: 8695:     struct re_pattern_buffer *bufp;
        -: 8696:{
        -: 8697:  /* We fetch characters from PATTERN here.  Even though PATTERN is
        -: 8698:     `char *' (i.e., signed), we declare these variables as unsigned, so
        -: 8699:     they can be reliably used as array indices.  */
        -: 8700:  register unsigned char c, c1;
        -: 8701:
        -: 8702:  /* A random temporary spot in PATTERN.  */
        -: 8703:  const char *p1;
        -: 8704:
        -: 8705:  /* Points to the end of the buffer, where we should append.  */
        -: 8706:  register unsigned char *b;
        -: 8707:
        -: 8708:  /* Keeps track of unclosed groups.  */
        -: 8709:  compile_stack_type compile_stack;
        -: 8710:
        -: 8711:  /* Points to the current (ending) position in the pattern.  */
        1: 8712:  const char *p = pattern;
        1: 8713:  const char *pend = pattern + size;
        -: 8714:
        -: 8715:  /* How to translate the characters in the pattern.  */
        1: 8716:  RE_TRANSLATE_TYPE translate = bufp->translate;
        -: 8717:
        -: 8718:  /* Address of the count-byte of the most recently inserted `exactn'
        -: 8719:     command.  This makes it possible to tell if a new exact-match
        -: 8720:     character can be added to that command or if the character requires
        -: 8721:     a new `exactn' command.  */
        1: 8722:  unsigned char *pending_exact = 0;
        -: 8723:
        -: 8724:  /* Address of start of the most recently finished expression.
        -: 8725:     This tells, e.g., postfix * where to find the start of its
        -: 8726:     operand.  Reset at the beginning of groups and alternatives.  */
        1: 8727:  unsigned char *laststart = 0;
        -: 8728:
        -: 8729:  /* Address of beginning of regexp, or inside of last group.  */
        -: 8730:  unsigned char *begalt;
        -: 8731:
        -: 8732:  /* Place in the uncompiled pattern (i.e., the {) to
        -: 8733:     which to go back if the interval is invalid.  */
        -: 8734:  const char *beg_interval;
        -: 8735:
        -: 8736:  /* Address of the place where a forward jump should go to the end of
        -: 8737:     the containing expression.  Each alternative of an `or' -- except the
        -: 8738:     last -- ends with a forward jump of this sort.  */
        1: 8739:  unsigned char *fixup_alt_jump = 0;
        -: 8740:
        -: 8741:  /* Counts open-groups as they are encountered.  Remembered for the
        -: 8742:     matching close-group on the compile stack, so the same register
        -: 8743:     number is put in the stop_memory as the start_memory.  */
        1: 8744:  regnum_t regnum = 0;
        -: 8745:
        -: 8746:#ifdef DEBUG
        -: 8747:  DEBUG_PRINT1 ("\nCompiling pattern: ");
        -: 8748:  if (debug)
        -: 8749:    {
        -: 8750:      unsigned debug_count;
        -: 8751:
        -: 8752:      for (debug_count = 0; debug_count < size; debug_count++)
        -: 8753:        putchar (pattern[debug_count]);
        -: 8754:      putchar ('\n');
        -: 8755:    }
        -: 8756:#endif /* DEBUG */
        -: 8757:
        -: 8758:  /* Initialize the compile stack.  */
        1: 8759:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
        1: 8760:  if (compile_stack.stack == NULL)
    #####: 8761:    return REG_ESPACE;
        -: 8762:
        1: 8763:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
        1: 8764:  compile_stack.avail = 0;
        -: 8765:
        -: 8766:  /* Initialize the pattern buffer.  */
        1: 8767:  bufp->syntax = syntax;
        1: 8768:  bufp->fastmap_accurate = 0;
        1: 8769:  bufp->not_bol = bufp->not_eol = 0;
        -: 8770:
        -: 8771:  /* Set `used' to zero, so that if we return an error, the pattern
        -: 8772:     printer (for debugging) will think there's no pattern.  We reset it
        -: 8773:     at the end.  */
        1: 8774:  bufp->used = 0;
        -: 8775:
        -: 8776:  /* Always count groups, whether or not bufp->no_sub is set.  */
        1: 8777:  bufp->re_nsub = 0;
        -: 8778:
        -: 8779:#if !defined (emacs) && !defined (SYNTAX_TABLE)
        -: 8780:  /* Initialize the syntax table.  */
        1: 8781:   init_syntax_once ();
        -: 8782:#endif
        -: 8783:
        1: 8784:  if (bufp->allocated == 0)
        -: 8785:    {
        1: 8786:      if (bufp->buffer)
        -: 8787:	{ /* If zero allocated, but buffer is non-null, try to realloc
        -: 8788:             enough space.  This loses if buffer's address is bogus, but
        -: 8789:             that is the user's responsibility.  */
    #####: 8790:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
        -: 8791:        }
        -: 8792:      else
        -: 8793:        { /* Caller did not allocate a buffer.  Do it for them.  */
        1: 8794:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
        -: 8795:        }
       1*: 8796:      if (!bufp->buffer) FREE_STACK_RETURN (REG_ESPACE);
        -: 8797:
        1: 8798:      bufp->allocated = INIT_BUF_SIZE;
        -: 8799:    }
        -: 8800:
        1: 8801:  begalt = b = bufp->buffer;
        -: 8802:
        -: 8803:  /* Loop through the uncompiled pattern until we're at the end.  */
        3: 8804:  while (p != pend)
        -: 8805:    {
       2*: 8806:      PATFETCH (c);
        -: 8807:
        2: 8808:      switch (c)
        -: 8809:        {
    #####: 8810:        case '^':
        -: 8811:          {
    #####: 8812:            if (   /* If at start of pattern, it's an operator.  */
    #####: 8813:                   p == pattern + 1
        -: 8814:                   /* If context independent, it's an operator.  */
    #####: 8815:                || syntax & RE_CONTEXT_INDEP_ANCHORS
        -: 8816:                   /* Otherwise, depends on what's come before.  */
    #####: 8817:                || at_begline_loc_p (pattern, p, syntax))
    #####: 8818:              BUF_PUSH (begline);
        -: 8819:            else
    #####: 8820:              goto normal_char;
        -: 8821:          }
    #####: 8822:          break;
        -: 8823:
        -: 8824:
    #####: 8825:        case '$':
        -: 8826:          {
    #####: 8827:            if (   /* If at end of pattern, it's an operator.  */
    #####: 8828:                   p == pend
        -: 8829:                   /* If context independent, it's an operator.  */
    #####: 8830:                || syntax & RE_CONTEXT_INDEP_ANCHORS
        -: 8831:                   /* Otherwise, depends on what's next.  */
    #####: 8832:                || at_endline_loc_p (p, pend, syntax))
    #####: 8833:               BUF_PUSH (endline);
        -: 8834:             else
    #####: 8835:               goto normal_char;
        -: 8836:           }
    #####: 8837:           break;
        -: 8838:
        -: 8839:
    #####: 8840:	case '+':
        -: 8841:        case '?':
    #####: 8842:          if ((syntax & RE_BK_PLUS_QM)
    #####: 8843:              || (syntax & RE_LIMITED_OPS))
    #####: 8844:            goto normal_char;
       1*: 8845:        handle_plus:
        1: 8846:        case '*':
        -: 8847:          /* If there is no previous pattern... */
        1: 8848:          if (!laststart)
        -: 8849:            {
    #####: 8850:              if (syntax & RE_CONTEXT_INVALID_OPS)
    #####: 8851:                FREE_STACK_RETURN (REG_BADRPT);
    #####: 8852:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
    #####: 8853:                goto normal_char;
        -: 8854:            }
        -: 8855:
        -: 8856:          {
        -: 8857:            /* Are we optimizing this jump?  */
        1: 8858:            boolean keep_string_p = false;
        -: 8859:
        -: 8860:            /* 1 means zero (many) matches is allowed.  */
        1: 8861:            char zero_times_ok = 0, many_times_ok = 0;
        -: 8862:
        -: 8863:            /* If there is a sequence of repetition chars, collapse it
        -: 8864:               down to just one (the right one).  We can't combine
        -: 8865:               interval operators with these because of, e.g., `a{2}*',
        -: 8866:               which should only match an even number of `a's.  */
        -: 8867:
        -: 8868:            for (;;)
        -: 8869:              {
        1: 8870:                zero_times_ok |= c != '+';
        1: 8871:                many_times_ok |= c != '?';
        -: 8872:
        1: 8873:                if (p == pend)
        1: 8874:                  break;
        -: 8875:
    #####: 8876:                PATFETCH (c);
        -: 8877:
    #####: 8878:                if (c == '*'
    #####: 8879:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
        -: 8880:                  ;
        -: 8881:
    #####: 8882:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
        -: 8883:                  {
    #####: 8884:                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
        -: 8885:
    #####: 8886:                    PATFETCH (c1);
    #####: 8887:                    if (!(c1 == '+' || c1 == '?'))
        -: 8888:                      {
    #####: 8889:                        PATUNFETCH;
    #####: 8890:                        PATUNFETCH;
    #####: 8891:                        break;
        -: 8892:                      }
        -: 8893:
    #####: 8894:                    c = c1;
        -: 8895:                  }
        -: 8896:                else
        -: 8897:                  {
    #####: 8898:                    PATUNFETCH;
    #####: 8899:                    break;
        -: 8900:                  }
        -: 8901:
        -: 8902:                /* If we get here, we found another repeat character.  */
        -: 8903:               }
        -: 8904:
        -: 8905:            /* Star, etc. applied to an empty pattern is equivalent
        -: 8906:               to an empty pattern.  */
        1: 8907:            if (!laststart)
    #####: 8908:              break;
        -: 8909:
        -: 8910:            /* Now we know whether or not zero matches is allowed
        -: 8911:               and also whether or not two or more matches is allowed.  */
        1: 8912:            if (many_times_ok)
        -: 8913:              { /* More than one repetition is allowed, so put in at the
        -: 8914:                   end a backward relative jump from `b' to before the next
        -: 8915:                   jump we're going to put in below (which jumps from
        -: 8916:                   laststart to after this jump).
        -: 8917:
        -: 8918:                   But if we are at the `*' in the exact sequence `.*\n',
        -: 8919:                   insert an unconditional jump backwards to the .,
        -: 8920:                   instead of the beginning of the loop.  This way we only
        -: 8921:                   push a failure point once, instead of every time
        -: 8922:                   through the loop.  */
        -: 8923:                assert (p - 1 > pattern);
        -: 8924:
        -: 8925:                /* Allocate the space for the jump.  */
       1*: 8926:                GET_BUFFER_SPACE (3);
        -: 8927:
        -: 8928:                /* We know we are not at the first character of the pattern,
        -: 8929:                   because laststart was nonzero.  And we've already
        -: 8930:                   incremented `p', by the way, to be the character after
        -: 8931:                   the `*'.  Do we have to do something analogous here
        -: 8932:                   for null bytes, because of RE_DOT_NOT_NULL?  */
       1*: 8933:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
    #####: 8934:		    && zero_times_ok
    #####: 8935:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
    #####: 8936:                    && !(syntax & RE_DOT_NEWLINE))
        -: 8937:                  { /* We have .*\n.  */
    #####: 8938:                    STORE_JUMP (jump, b, laststart);
    #####: 8939:                    keep_string_p = true;
        -: 8940:                  }
        -: 8941:                else
        -: 8942:                  /* Anything else.  */
        1: 8943:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
        -: 8944:
        -: 8945:                /* We've added more stuff to the buffer.  */
        1: 8946:                b += 3;
        -: 8947:              }
        -: 8948:
        -: 8949:            /* On failure, jump from laststart to b + 3, which will be the
        -: 8950:               end of the buffer after this jump is inserted.  */
       1*: 8951:            GET_BUFFER_SPACE (3);
       1*: 8952:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
        -: 8953:                                       : on_failure_jump,
        -: 8954:                         laststart, b + 3);
        1: 8955:            pending_exact = 0;
        1: 8956:            b += 3;
        -: 8957:
        1: 8958:            if (!zero_times_ok)
        -: 8959:              {
        -: 8960:                /* At least one repetition is required, so insert a
        -: 8961:                   `dummy_failure_jump' before the initial
        -: 8962:                   `on_failure_jump' instruction of the loop. This
        -: 8963:                   effects a skip over that instruction the first time
        -: 8964:                   we hit that loop.  */
       1*: 8965:                GET_BUFFER_SPACE (3);
        1: 8966:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
        1: 8967:                b += 3;
        -: 8968:              }
        -: 8969:            }
        1: 8970:	  break;
        -: 8971:
        -: 8972:
    #####: 8973:	case '.':
    #####: 8974:          laststart = b;
    #####: 8975:          BUF_PUSH (anychar);
    #####: 8976:          break;
        -: 8977:
        -: 8978:
    #####: 8979:        case '[':
        -: 8980:          {
    #####: 8981:            boolean had_char_class = false;
        -: 8982:#ifndef FAULTY_F_KP_1
        -: 8983:
    #####: 8984:            if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
        -: 8985:#else
        -: 8986:
        -: 8987:            if (p == pend) REG_EBRACK;
        -: 8988:#endif
        -: 8989:
        -: 8990:            /* Ensure that we have enough space to push a charset: the
        -: 8991:               opcode, the length count, and the bitset; 34 bytes in all.  */
    #####: 8992:	    GET_BUFFER_SPACE (34);
        -: 8993:
    #####: 8994:            laststart = b;
        -: 8995:
        -: 8996:            /* We test `*p == '^' twice, instead of using an if
        -: 8997:               statement, so we only need one BUF_PUSH.  */
    #####: 8998:            BUF_PUSH (*p == '^' ? charset_not : charset);
    #####: 8999:            if (*p == '^')
    #####: 9000:              p++;
        -: 9001:
        -: 9002:            /* Remember the first position in the bracket expression.  */
    #####: 9003:            p1 = p;
        -: 9004:
        -: 9005:            /* Push the number of bytes in the bitmap.  */
    #####: 9006:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
        -: 9007:
        -: 9008:            /* Clear the whole map.  */
    #####: 9009:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
        -: 9010:
        -: 9011:            /* charset_not matches newline according to a syntax bit.  */
    #####: 9012:            if ((re_opcode_t) b[-2] == charset_not
    #####: 9013:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
    #####: 9014:              SET_LIST_BIT ('\n');
        -: 9015:
        -: 9016:            /* Read in characters and ranges, setting map bits.  */
        -: 9017:            for (;;)
        -: 9018:              {
    #####: 9019:                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
        -: 9020:
    #####: 9021:                PATFETCH (c);
        -: 9022:
        -: 9023:                /* \ might escape characters inside [...] and [^...].  */
    #####: 9024:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
        -: 9025:                  {
    #####: 9026:                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
        -: 9027:
    #####: 9028:                    PATFETCH (c1);
    #####: 9029:                    SET_LIST_BIT (c1);
    #####: 9030:                    continue;
        -: 9031:                  }
        -: 9032:
        -: 9033:                /* Could be the end of the bracket expression.  If it's
        -: 9034:                   not (i.e., when the bracket expression is `[]' so
        -: 9035:                   far), the ']' character bit gets set way below.  */
    #####: 9036:                if (c == ']' && p != p1 + 1)
    #####: 9037:                  break;
        -: 9038:
        -: 9039:                /* Look ahead to see if it's a range when the last thing
        -: 9040:                   was a character class.  */
    #####: 9041:                if (had_char_class && c == '-' && *p != ']')
    #####: 9042:                  FREE_STACK_RETURN (REG_ERANGE);
        -: 9043:
        -: 9044:                /* Look ahead to see if it's a range when the last thing
        -: 9045:                   was a character: if this is a hyphen not at the
        -: 9046:                   beginning or the end of a list, then it's the range
        -: 9047:                   operator.  */
    #####: 9048:                if (c == '-'
    #####: 9049:                    && !(p - 2 >= pattern && p[-2] == '[')
    #####: 9050:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
    #####: 9051:                    && *p != ']')
    #####: 9052:                  {
        -: 9053:                    reg_errcode_t ret
    #####: 9054:                      = compile_range (&p, pend, translate, syntax, b);
    #####: 9055:                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
        -: 9056:                  }
        -: 9057:
    #####: 9058:                else if (p[0] == '-' && p[1] != ']')
    #####: 9059:                  { /* This handles ranges made up of characters only.  */
        -: 9060:                    reg_errcode_t ret;
        -: 9061:
        -: 9062:		    /* Move past the `-'.  */
    #####: 9063:                    PATFETCH (c1);
        -: 9064:
    #####: 9065:                    ret = compile_range (&p, pend, translate, syntax, b);
    #####: 9066:                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
        -: 9067:                  }
        -: 9068:
        -: 9069:                /* See if we're at the beginning of a possible character
        -: 9070:                   class.  */
        -: 9071:
    #####: 9072:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
    #####: 9073:                  { /* Leave room for the null.  */
        -: 9074:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
        -: 9075:
    #####: 9076:                    PATFETCH (c);
    #####: 9077:                    c1 = 0;
        -: 9078:
        -: 9079:                    /* If pattern is `[[:'.  */
    #####: 9080:                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
        -: 9081:
        -: 9082:                    for (;;)
        -: 9083:                      {
    #####: 9084:                        PATFETCH (c);
        -: 9085:			#ifndef FAULTY_F_DG_10
    #####: 9086:                        if ((c == ':' && *p == ']') || p == pend
    #####: 9087:                            || c1 == CHAR_CLASS_MAX_LENGTH)
        -: 9088:			#else
        -: 9089:                        if (c == ':' || *p == ']' || p == pend
        -: 9090:                            || c1 == CHAR_CLASS_MAX_LENGTH)
        -: 9091:			#endif
        -: 9092:                          break;
    #####: 9093:                        str[c1++] = c;
        -: 9094:                      }
    #####: 9095:                    str[c1] = '\0';
        -: 9096:
        -: 9097:                    /* If isn't a word bracketed by `[:' and:`]':
        -: 9098:                       undo the ending character, the letters, and leave
        -: 9099:                       the leading `:' and `[' (but set bits for them).  */
    #####: 9100:                    if (c == ':' && *p == ']')
    #####: 9101:                      {
        -: 9102:#if defined _LIBC || (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H)
    #####: 9103:                        boolean is_lower = STREQ (str, "lower");
    #####: 9104:                        boolean is_upper = STREQ (str, "upper");
        -: 9105:			wctype_t wt;
        -: 9106:                        int ch;
        -: 9107:
    #####: 9108:			wt = wctype (str);
    #####: 9109:			if (wt == 0)
    #####: 9110:			  FREE_STACK_RETURN (REG_ECTYPE);
        -: 9111:
        -: 9112:                        /* Throw away the ] at the end of the character
        -: 9113:                           class.  */
    #####: 9114:                        PATFETCH (c);
        -: 9115:
    #####: 9116:                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
        -: 9117:
    #####: 9118:                        for (ch = 0; ch < 1 << BYTEWIDTH; ++ch)
        -: 9119:			  {
    #####: 9120:			    if (iswctype (btowc (ch), wt))
    #####: 9121:			      SET_LIST_BIT (ch);
        -: 9122:
    #####: 9123:			    if (translate && (is_upper || is_lower)
    #####: 9124:				&& (ISUPPER (ch) || ISLOWER (ch)))
    #####: 9125:			      SET_LIST_BIT (ch);
        -: 9126:			  }
        -: 9127:
    #####: 9128:                        had_char_class = true;
        -: 9129:#else
        -: 9130:                        int ch;
        -: 9131:                        boolean is_alnum = STREQ (str, "alnum");
        -: 9132:                        boolean is_alpha = STREQ (str, "alpha");
        -: 9133:                        boolean is_blank = STREQ (str, "blank");
        -: 9134:                        boolean is_cntrl = STREQ (str, "cntrl");
        -: 9135:                        boolean is_digit = STREQ (str, "digit");
        -: 9136:                        boolean is_graph = STREQ (str, "graph");
        -: 9137:                        boolean is_lower = STREQ (str, "lower");
        -: 9138:                        boolean is_print = STREQ (str, "print");
        -: 9139:                        boolean is_punct = STREQ (str, "punct");
        -: 9140:                        boolean is_space = STREQ (str, "space");
        -: 9141:                        boolean is_upper = STREQ (str, "upper");
        -: 9142:                        boolean is_xdigit = STREQ (str, "xdigit");
        -: 9143:
        -: 9144:                        if (!IS_CHAR_CLASS (str))
        -: 9145:			  FREE_STACK_RETURN (REG_ECTYPE);
        -: 9146:
        -: 9147:                        /* Throw away the ] at the end of the character
        -: 9148:                           class.  */
        -: 9149:                        PATFETCH (c);
        -: 9150:
        -: 9151:                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
        -: 9152:
        -: 9153:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
        -: 9154:                          {
        -: 9155:			    /* This was split into 3 if's to
        -: 9156:			       avoid an arbitrary limit in some compiler.  */
        -: 9157:                            if (   (is_alnum  && ISALNUM (ch))
        -: 9158:                                || (is_alpha  && ISALPHA (ch))
        -: 9159:                                || (is_blank  && ISBLANK (ch))
        -: 9160:                                || (is_cntrl  && ISCNTRL (ch)))
        -: 9161:			      SET_LIST_BIT (ch);
        -: 9162:			    if (   (is_digit  && ISDIGIT (ch))
        -: 9163:                                || (is_graph  && ISGRAPH (ch))
        -: 9164:                                || (is_lower  && ISLOWER (ch))
        -: 9165:                                || (is_print  && ISPRINT (ch)))
        -: 9166:			      SET_LIST_BIT (ch);
        -: 9167:			    if (   (is_punct  && ISPUNCT (ch))
        -: 9168:                                || (is_space  && ISSPACE (ch))
        -: 9169:                                || (is_upper  && ISUPPER (ch))
        -: 9170:                                || (is_xdigit && ISXDIGIT (ch)))
        -: 9171:			      SET_LIST_BIT (ch);
        -: 9172:			    if (   translate && (is_upper || is_lower)
        -: 9173:				&& (ISUPPER (ch) || ISLOWER (ch)))
        -: 9174:			      SET_LIST_BIT (ch);
        -: 9175:                          }
        -: 9176:                        had_char_class = true;
        -: 9177:#endif	/* libc || wctype.h */
        -: 9178:                      }
        -: 9179:                    else
        -: 9180:                      {
    #####: 9181:                        c1++;
    #####: 9182:                        while (c1--)
    #####: 9183:                          PATUNFETCH;
    #####: 9184:                        SET_LIST_BIT ('[');
    #####: 9185:                        SET_LIST_BIT (':');
    #####: 9186:                        had_char_class = false;
        -: 9187:                      }
        -: 9188:                  }
        -: 9189:                else
        -: 9190:                  {
    #####: 9191:                    had_char_class = false;
    #####: 9192:                    SET_LIST_BIT (c);
        -: 9193:                  }
        -: 9194:              }
        -: 9195:
        -: 9196:            /* Discard any (non)matching list bytes that are all 0 at the
        -: 9197:               end of the map.  Decrease the map-length byte too.  */
    #####: 9198:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
    #####: 9199:              b[-1]--;
    #####: 9200:            b += b[-1];
        -: 9201:          }
    #####: 9202:          break;
        -: 9203:
        -: 9204:
    #####: 9205:	case '(':
    #####: 9206:          if (syntax & RE_NO_BK_PARENS)
    #####: 9207:            goto handle_open;
        -: 9208:          else
    #####: 9209:            goto normal_char;
        -: 9210:
        -: 9211:
    #####: 9212:        case ')':
    #####: 9213:          if (syntax & RE_NO_BK_PARENS)
    #####: 9214:            goto handle_close;
        -: 9215:          else
    #####: 9216:            goto normal_char;
        -: 9217:
        -: 9218:
    #####: 9219:        case '\n':
    #####: 9220:          if (syntax & RE_NEWLINE_ALT)
    #####: 9221:            goto handle_alt;
        -: 9222:          else
    #####: 9223:            goto normal_char;
        -: 9224:
        -: 9225:
    #####: 9226:	case '|':
    #####: 9227:          if (syntax & RE_NO_BK_VBAR)
    #####: 9228:            goto handle_alt;
        -: 9229:          else
    #####: 9230:            goto normal_char;
        -: 9231:
        -: 9232:
    #####: 9233:        case '{':
    #####: 9234:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
    #####: 9235:             goto handle_interval;
        -: 9236:           else
    #####: 9237:             goto normal_char;
        -: 9238:
        -: 9239:
        1: 9240:        case '\\':
       1*: 9241:          if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
        -: 9242:
        -: 9243:          /* Do not translate the character after the \, so that we can
        -: 9244:             distinguish, e.g., \B from \b, even if we normally would
        -: 9245:             translate, e.g., B to b.  */
       1*: 9246:          PATFETCH_RAW (c);
        -: 9247:
        1: 9248:          switch (c)
        -: 9249:            {
    #####: 9250:            case '(':
    #####: 9251:              if (syntax & RE_NO_BK_PARENS)
    #####: 9252:                goto normal_backslash;
        -: 9253:
    #####: 9254:            handle_open:
    #####: 9255:              bufp->re_nsub++;
    #####: 9256:              regnum++;
        -: 9257:
    #####: 9258:              if (COMPILE_STACK_FULL)
        -: 9259:                {
    #####: 9260:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
        -: 9261:                            compile_stack_elt_t);
    #####: 9262:                  if (compile_stack.stack == NULL) return REG_ESPACE;
        -: 9263:
    #####: 9264:                  compile_stack.size <<= 1;
        -: 9265:                }
        -: 9266:
        -: 9267:              /* These are the values to restore when we hit end of this
        -: 9268:                 group.  They are all relative offsets, so that if the
        -: 9269:                 whole pattern moves because of realloc, they will still
        -: 9270:                 be valid.  */
    #####: 9271:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
    #####: 9272:              COMPILE_STACK_TOP.fixup_alt_jump
    #####: 9273:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
    #####: 9274:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
    #####: 9275:              COMPILE_STACK_TOP.regnum = regnum;
        -: 9276:
        -: 9277:              /* We will eventually replace the 0 with the number of
        -: 9278:                 groups inner to this one.  But do not push a
        -: 9279:                 start_memory for groups beyond the last one we can
        -: 9280:                 represent in the compiled pattern.  */
    #####: 9281:              if (regnum <= MAX_REGNUM)
        -: 9282:                {
    #####: 9283:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
    #####: 9284:                  BUF_PUSH_3 (start_memory, regnum, 0);
        -: 9285:                }
        -: 9286:
    #####: 9287:              compile_stack.avail++;
        -: 9288:
    #####: 9289:              fixup_alt_jump = 0;
    #####: 9290:              laststart = 0;
    #####: 9291:              begalt = b;
        -: 9292:	      /* If we've reached MAX_REGNUM groups, then this open
        -: 9293:		 won't actually generate any code, so we'll have to
        -: 9294:		 clear pending_exact explicitly.  */
    #####: 9295:	      pending_exact = 0;
    #####: 9296:              break;
        -: 9297:
        -: 9298:
    #####: 9299:            case ')':
    #####: 9300:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
        -: 9301:
    #####: 9302:              if (COMPILE_STACK_EMPTY)
    #####: 9303:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
    #####: 9304:                  goto normal_backslash;
        -: 9305:                else
    #####: 9306:                  FREE_STACK_RETURN (REG_ERPAREN);
        -: 9307:
    #####: 9308:            handle_close:
    #####: 9309:              if (fixup_alt_jump)
        -: 9310:                { /* Push a dummy failure point at the end of the
        -: 9311:                     alternative for a possible future
        -: 9312:                     `pop_failure_jump' to pop.  See comments at
        -: 9313:                     `push_dummy_failure' in `re_match_2'.  */
    #####: 9314:                  BUF_PUSH (push_dummy_failure);
        -: 9315:
        -: 9316:                  /* We allocated space for this jump when we assigned
        -: 9317:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
    #####: 9318:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
        -: 9319:                }
        -: 9320:
        -: 9321:              /* See similar code for backslashed left paren above.  */
    #####: 9322:              if (COMPILE_STACK_EMPTY)
    #####: 9323:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
    #####: 9324:                  goto normal_char;
        -: 9325:                else
    #####: 9326:                  FREE_STACK_RETURN (REG_ERPAREN);
        -: 9327:
        -: 9328:              /* Since we just checked for an empty stack above, this
        -: 9329:                 ``can't happen''.  */
        -: 9330:              assert (compile_stack.avail != 0);
        -: 9331:              {
        -: 9332:                /* We don't just want to restore into `regnum', because
        -: 9333:                   later groups should continue to be numbered higher,
        -: 9334:                   as in `(ab)c(de)' -- the second group is #2.  */
        -: 9335:                regnum_t this_group_regnum;
        -: 9336:
    #####: 9337:                compile_stack.avail--;
    #####: 9338:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
        -: 9339:                fixup_alt_jump
    #####: 9340:                  = COMPILE_STACK_TOP.fixup_alt_jump
    #####: 9341:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
    #####: 9342:                    : 0;
    #####: 9343:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
    #####: 9344:                this_group_regnum = COMPILE_STACK_TOP.regnum;
        -: 9345:		/* If we've reached MAX_REGNUM groups, then this open
        -: 9346:		   won't actually generate any code, so we'll have to
        -: 9347:		   clear pending_exact explicitly.  */
    #####: 9348:		pending_exact = 0;
        -: 9349:
        -: 9350:                /* We're at the end of the group, so now we know how many
        -: 9351:                   groups were inside this one.  */
    #####: 9352:                if (this_group_regnum <= MAX_REGNUM)
        -: 9353:                  {
    #####: 9354:                    unsigned char *inner_group_loc
    #####: 9355:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
        -: 9356:
    #####: 9357:                    *inner_group_loc = regnum - this_group_regnum;
    #####: 9358:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
        -: 9359:                                regnum - this_group_regnum);
        -: 9360:                  }
        -: 9361:              }
    #####: 9362:              break;
        -: 9363:
        -: 9364:
    #####: 9365:            case '|':					/* `\|'.  */
    #####: 9366:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
    #####: 9367:                goto normal_backslash;
    #####: 9368:            handle_alt:
    #####: 9369:              if (syntax & RE_LIMITED_OPS)
    #####: 9370:                goto normal_char;
        -: 9371:
        -: 9372:              /* Insert before the previous alternative a jump which
        -: 9373:                 jumps to this alternative if the former fails.  */
    #####: 9374:              GET_BUFFER_SPACE (3);
    #####: 9375:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
    #####: 9376:              pending_exact = 0;
    #####: 9377:              b += 3;
        -: 9378:
        -: 9379:              /* The alternative before this one has a jump after it
        -: 9380:                 which gets executed if it gets matched.  Adjust that
        -: 9381:                 jump so it will jump to this alternative's analogous
        -: 9382:                 jump (put in below, which in turn will jump to the next
        -: 9383:                 (if any) alternative's such jump, etc.).  The last such
        -: 9384:                 jump jumps to the correct final destination.  A picture:
        -: 9385:                          _____ _____
        -: 9386:                          |   | |   |
        -: 9387:                          |   v |   v
        -: 9388:                         a | b   | c
        -: 9389:
        -: 9390:                 If we are at `b', then fixup_alt_jump right now points to a
        -: 9391:                 three-byte space after `a'.  We'll put in the jump, set
        -: 9392:                 fixup_alt_jump to right after `b', and leave behind three
        -: 9393:                 bytes which we'll fill in when we get to after `c'.  */
        -: 9394:
    #####: 9395:              if (fixup_alt_jump)
    #####: 9396:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
        -: 9397:
        -: 9398:              /* Mark and leave space for a jump after this alternative,
        -: 9399:                 to be filled in later either by next alternative or
        -: 9400:                 when know we're at the end of a series of alternatives.  */
    #####: 9401:              fixup_alt_jump = b;
    #####: 9402:              GET_BUFFER_SPACE (3);
    #####: 9403:              b += 3;
        -: 9404:
    #####: 9405:              laststart = 0;
    #####: 9406:              begalt = b;
    #####: 9407:              break;
        -: 9408:
        -: 9409:
    #####: 9410:            case '{':
        -: 9411:              /* If \{ is a literal.  */
    #####: 9412:              if (!(syntax & RE_INTERVALS)
        -: 9413:                     /* If we're at `\{' and it's not the open-interval
        -: 9414:                        operator.  */
    #####: 9415:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
    #####: 9416:                  || (p - 2 == pattern  &&  p == pend))
    #####: 9417:                goto normal_backslash;
        -: 9418:
    #####: 9419:            handle_interval:
        -: 9420:              {
        -: 9421:                /* If got here, then the syntax allows intervals.  */
        -: 9422:
        -: 9423:                /* At least (most) this many matches must be made.  */
    #####: 9424:                int lower_bound = -1, upper_bound = -1;
        -: 9425:
    #####: 9426:                beg_interval = p - 1;
        -: 9427:
    #####: 9428:                if (p == pend)
        -: 9429:                  {
    #####: 9430:                    if (syntax & RE_NO_BK_BRACES)
    #####: 9431:                      goto unfetch_interval;
        -: 9432:                    else
    #####: 9433:                      FREE_STACK_RETURN (REG_EBRACE);
        -: 9434:                  }
        -: 9435:
    #####: 9436:                GET_UNSIGNED_NUMBER (lower_bound);
        -: 9437:
    #####: 9438:                if (c == ',')
        -: 9439:                  {
    #####: 9440:                    GET_UNSIGNED_NUMBER (upper_bound);
    #####: 9441:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
        -: 9442:                  }
        -: 9443:                else
        -: 9444:                  /* Interval such as `{1}' => match exactly once. */
    #####: 9445:                  upper_bound = lower_bound;
        -: 9446:
    #####: 9447:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
    #####: 9448:                    || lower_bound > upper_bound)
        -: 9449:                  {
    #####: 9450:                    if (syntax & RE_NO_BK_BRACES)
    #####: 9451:                      goto unfetch_interval;
        -: 9452:                    else
    #####: 9453:                      FREE_STACK_RETURN (REG_BADBR);
        -: 9454:                  }
        -: 9455:
    #####: 9456:                if (!(syntax & RE_NO_BK_BRACES))
        -: 9457:                  {
    #####: 9458:                    if (c != '\\') FREE_STACK_RETURN (REG_EBRACE);
        -: 9459:
    #####: 9460:                    PATFETCH (c);
        -: 9461:                  }
        -: 9462:
    #####: 9463:                if (c != '}')
        -: 9464:                  {
    #####: 9465:                    if (syntax & RE_NO_BK_BRACES)
    #####: 9466:                      goto unfetch_interval;
        -: 9467:                    else
    #####: 9468:                      FREE_STACK_RETURN (REG_BADBR);
        -: 9469:                  }
        -: 9470:
        -: 9471:                /* We just parsed a valid interval.  */
        -: 9472:
        -: 9473:                /* If it's invalid to have no preceding re.  */
    #####: 9474:                if (!laststart)
        -: 9475:                  {
    #####: 9476:                    if (syntax & RE_CONTEXT_INVALID_OPS)
    #####: 9477:                      FREE_STACK_RETURN (REG_BADRPT);
    #####: 9478:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
    #####: 9479:                      laststart = b;
        -: 9480:                    else
    #####: 9481:                      goto unfetch_interval;
        -: 9482:                  }
        -: 9483:
        -: 9484:                /* If the upper bound is zero, don't want to succeed at
        -: 9485:                   all; jump from `laststart' to `b + 3', which will be
        -: 9486:                   the end of the buffer after we insert the jump.  */
    #####: 9487:                 if (upper_bound == 0)
        -: 9488:                   {
    #####: 9489:                     GET_BUFFER_SPACE (3);
    #####: 9490:                     INSERT_JUMP (jump, laststart, b + 3);
    #####: 9491:                     b += 3;
        -: 9492:                   }
        -: 9493:
        -: 9494:                 /* Otherwise, we have a nontrivial interval.  When
        -: 9495:                    we're all done, the pattern will look like:
        -: 9496:                      set_number_at <jump count> <upper bound>
        -: 9497:                      set_number_at <succeed_n count> <lower bound>
        -: 9498:                      succeed_n <after jump addr> <succeed_n count>
        -: 9499:                      <body of loop>
        -: 9500:                      jump_n <succeed_n addr> <jump count>
        -: 9501:                    (The upper bound and `jump_n' are omitted if
        -: 9502:                    `upper_bound' is 1, though.)  */
        -: 9503:                 else
        -: 9504:                   { /* If the upper bound is > 1, we need to insert
        -: 9505:                        more at the end of the loop.  */
    #####: 9506:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
        -: 9507:
    #####: 9508:                     GET_BUFFER_SPACE (nbytes);
        -: 9509:
        -: 9510:                     /* Initialize lower bound of the `succeed_n', even
        -: 9511:                        though it will be set during matching by its
        -: 9512:                        attendant `set_number_at' (inserted next),
        -: 9513:                        because `re_compile_fastmap' needs to know.
        -: 9514:                        Jump to the `jump_n' we might insert below.  */
    #####: 9515:                     INSERT_JUMP2 (succeed_n, laststart,
        -: 9516:                                   b + 5 + (upper_bound > 1) * 5,
        -: 9517:                                   lower_bound);
    #####: 9518:                     b += 5;
        -: 9519:
        -: 9520:                     /* Code to initialize the lower bound.  Insert
        -: 9521:                        before the `succeed_n'.  The `5' is the last two
        -: 9522:                        bytes of this `set_number_at', plus 3 bytes of
        -: 9523:                        the following `succeed_n'.  */
    #####: 9524:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
    #####: 9525:                     b += 5;
        -: 9526:
    #####: 9527:                     if (upper_bound > 1)
        -: 9528:                       { /* More than one repetition is allowed, so
        -: 9529:                            append a backward jump to the `succeed_n'
        -: 9530:                            that starts this interval.
        -: 9531:
        -: 9532:                            When we've reached this during matching,
        -: 9533:                            we'll have matched the interval once, so
        -: 9534:                            jump back only `upper_bound - 1' times.  */
    #####: 9535:                         STORE_JUMP2 (jump_n, b, laststart + 5,
        -: 9536:                                      upper_bound - 1);
    #####: 9537:                         b += 5;
        -: 9538:
        -: 9539:                         /* The location we want to set is the second
        -: 9540:                            parameter of the `jump_n'; that is `b-2' as
        -: 9541:                            an absolute address.  `laststart' will be
        -: 9542:                            the `set_number_at' we're about to insert;
        -: 9543:                            `laststart+3' the number to set, the source
        -: 9544:                            for the relative address.  But we are
        -: 9545:                            inserting into the middle of the pattern --
        -: 9546:                            so everything is getting moved up by 5.
        -: 9547:                            Conclusion: (b - 2) - (laststart + 3) + 5,
        -: 9548:                            i.e., b - laststart.
        -: 9549:
        -: 9550:                            We insert this at the beginning of the loop
        -: 9551:                            so that if we fail during matching, we'll
        -: 9552:                            reinitialize the bounds.  */
    #####: 9553:                         insert_op2 (set_number_at, laststart, b - laststart,
        -: 9554:                                     upper_bound - 1, b);
    #####: 9555:                         b += 5;
        -: 9556:                       }
        -: 9557:                   }
    #####: 9558:                pending_exact = 0;
    #####: 9559:                beg_interval = NULL;
        -: 9560:              }
    #####: 9561:              break;
        -: 9562:
    #####: 9563:            unfetch_interval:
        -: 9564:              /* If an invalid interval, match the characters as literals.  */
        -: 9565:               assert (beg_interval);
    #####: 9566:               p = beg_interval;
    #####: 9567:               beg_interval = NULL;
        -: 9568:
        -: 9569:               /* normal_char and normal_backslash need `c'.  */
    #####: 9570:               PATFETCH (c);
        -: 9571:
    #####: 9572:               if (!(syntax & RE_NO_BK_BRACES))
        -: 9573:                 {
    #####: 9574:                   if (p > pattern  &&  p[-1] == '\\')
    #####: 9575:                     goto normal_backslash;
        -: 9576:                 }
    #####: 9577:               goto normal_char;
        -: 9578:
        -: 9579:#ifdef emacs
        -: 9580:            /* There is no way to specify the before_dot and after_dot
        -: 9581:               operators.  rms says this is ok.  --karl  */
        -: 9582:            case '=':
        -: 9583:              BUF_PUSH (at_dot);
        -: 9584:              break;
        -: 9585:
        -: 9586:            case 's':
        -: 9587:              laststart = b;
        -: 9588:              PATFETCH (c);
        -: 9589:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
        -: 9590:              break;
        -: 9591:
        -: 9592:            case 'S':
        -: 9593:              laststart = b;
        -: 9594:              PATFETCH (c);
        -: 9595:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
        -: 9596:              break;
        -: 9597:#endif /* emacs */
        -: 9598:
        -: 9599:
    #####: 9600:            case 'w':
    #####: 9601:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9602:		goto normal_char;
    #####: 9603:              laststart = b;
    #####: 9604:              BUF_PUSH (wordchar);
    #####: 9605:              break;
        -: 9606:
        -: 9607:
    #####: 9608:            case 'W':
    #####: 9609:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9610:		goto normal_char;
    #####: 9611:              laststart = b;
    #####: 9612:              BUF_PUSH (notwordchar);
    #####: 9613:              break;
        -: 9614:
        -: 9615:
    #####: 9616:            case '<':
    #####: 9617:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9618:		goto normal_char;
    #####: 9619:              BUF_PUSH (wordbeg);
    #####: 9620:              break;
        -: 9621:
    #####: 9622:            case '>':
    #####: 9623:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9624:		goto normal_char;
    #####: 9625:              BUF_PUSH (wordend);
    #####: 9626:              break;
        -: 9627:
    #####: 9628:            case 'b':
    #####: 9629:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9630:		goto normal_char;
    #####: 9631:              BUF_PUSH (wordbound);
    #####: 9632:              break;
        -: 9633:
    #####: 9634:            case 'B':
    #####: 9635:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9636:		goto normal_char;
    #####: 9637:              BUF_PUSH (notwordbound);
    #####: 9638:              break;
        -: 9639:
    #####: 9640:            case '`':
    #####: 9641:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9642:		goto normal_char;
    #####: 9643:              BUF_PUSH (begbuf);
    #####: 9644:              break;
        -: 9645:
    #####: 9646:            case '\'':
    #####: 9647:	      if (re_syntax_options & RE_NO_GNU_OPS)
    #####: 9648:		goto normal_char;
    #####: 9649:              BUF_PUSH (endbuf);
    #####: 9650:              break;
        -: 9651:
    #####: 9652:            case '1': case '2': case '3': case '4': case '5':
        -: 9653:            case '6': case '7': case '8': case '9':
    #####: 9654:              if (syntax & RE_NO_BK_REFS)
    #####: 9655:                goto normal_char;
        -: 9656:
    #####: 9657:              c1 = c - '0';
        -: 9658:
    #####: 9659:              if (c1 > regnum)
    #####: 9660:                FREE_STACK_RETURN (REG_ESUBREG);
        -: 9661:
        -: 9662:              /* Can't back reference to a subexpression if inside of it.  */
    #####: 9663:              if (group_in_compile_stack (compile_stack, (regnum_t) c1))
    #####: 9664:                goto normal_char;
        -: 9665:
    #####: 9666:              laststart = b;
    #####: 9667:              BUF_PUSH_2 (duplicate, c1);
    #####: 9668:              break;
        -: 9669:
        -: 9670:
        1: 9671:            case '+':
        -: 9672:            case '?':
        1: 9673:              if (syntax & RE_BK_PLUS_QM)
        1: 9674:                goto handle_plus;
        -: 9675:              else
    #####: 9676:                goto normal_backslash;
        -: 9677:
        -: 9678:            default:
    #####: 9679:            normal_backslash:
        -: 9680:              /* You might think it would be useful for \ to mean
        -: 9681:                 not to translate; but if we don't translate it
        -: 9682:                 it will never match anything.  */
    #####: 9683:              c = TRANSLATE (c);
    #####: 9684:              goto normal_char;
        -: 9685:            }
    #####: 9686:          break;
        -: 9687:
        -: 9688:
        -: 9689:	default:
        -: 9690:        /* Expects the character in `c'.  */
        1: 9691:	normal_char:
        -: 9692:	      /* If no exactn currently being built.  */
       1*: 9693:          if (!pending_exact
        -: 9694:
        -: 9695:              /* If last exactn not at current position.  */
    #####: 9696:              || pending_exact + *pending_exact + 1 != b
        -: 9697:
        -: 9698:              /* We have only one byte following the exactn for the count.  */
    #####: 9699:	      || *pending_exact == (1 << BYTEWIDTH) - 1
        -: 9700:
        -: 9701:              /* If followed by a repetition operator.  */
    #####: 9702:              || *p == '*' || *p == '^'
    #####: 9703:	      || ((syntax & RE_BK_PLUS_QM)
    #####: 9704:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
    #####: 9705:		  : (*p == '+' || *p == '?'))
    #####: 9706:	      || ((syntax & RE_INTERVALS)
    #####: 9707:                  && ((syntax & RE_NO_BK_BRACES)
    #####: 9708:		      ? *p == '{'
    #####: 9709:                      : (p[0] == '\\' && p[1] == '{'))))
        -: 9710:	    {
        -: 9711:	      /* Start building a new exactn.  */
        -: 9712:
        1: 9713:              laststart = b;
        -: 9714:
       1*: 9715:	      BUF_PUSH_2 (exactn, 0);
        1: 9716:	      pending_exact = b - 1;
        -: 9717:            }
        -: 9718:
       1*: 9719:	  BUF_PUSH (c);
        1: 9720:          (*pending_exact)++;
        1: 9721:	  break;
        -: 9722:        } /* switch (c) */
        -: 9723:    } /* while p != pend */
        -: 9724:
        -: 9725:
        -: 9726:  /* Through the pattern now.  */
        -: 9727:
        1: 9728:  if (fixup_alt_jump)
    #####: 9729:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
        -: 9730:
        1: 9731:  if (!COMPILE_STACK_EMPTY)
    #####: 9732:    FREE_STACK_RETURN (REG_EPAREN);
        -: 9733:
        -: 9734:  /* If we don't want backtracking, force success
        -: 9735:     the first time we reach the end of the compiled pattern.  */
        1: 9736:  if (syntax & RE_NO_POSIX_BACKTRACKING)
    #####: 9737:    BUF_PUSH (succeed);
        -: 9738:
        1: 9739:  free (compile_stack.stack);
        -: 9740:
        -: 9741:  /* We have succeeded; set the length of the buffer.  */
        1: 9742:  bufp->used = b - bufp->buffer;
        -: 9743:
        -: 9744:#ifdef DEBUG
        -: 9745:  if (debug)
        -: 9746:    {
        -: 9747:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
        -: 9748:      print_compiled_pattern (bufp);
        -: 9749:    }
        -: 9750:#endif /* DEBUG */
        -: 9751:
        -: 9752:#ifndef MATCH_MAY_ALLOCATE
        -: 9753:  /* Initialize the failure stack to the largest possible stack.  This
        -: 9754:     isn't necessary unless we're trying to avoid calling alloca in
        -: 9755:     the search and match routines.  */
        -: 9756:  {
        -: 9757:    int num_regs = bufp->re_nsub + 1;
        -: 9758:
        -: 9759:    /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
        -: 9760:       is strictly greater than re_max_failures, the largest possible stack
        -: 9761:       is 2 * re_max_failures failure points.  */
        -: 9762:    if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS))
        -: 9763:      {
        -: 9764:	fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);
        -: 9765:
        -: 9766:#ifdef emacs
        -: 9767:	if (! fail_stack.stack)
        -: 9768:	  fail_stack.stack
        -: 9769:	    = (fail_stack_elt_t *) xmalloc (fail_stack.size
        -: 9770:					    * sizeof (fail_stack_elt_t));
        -: 9771:	else
        -: 9772:	  fail_stack.stack
        -: 9773:	    = (fail_stack_elt_t *) xrealloc (fail_stack.stack,
        -: 9774:					     (fail_stack.size
        -: 9775:					      * sizeof (fail_stack_elt_t)));
        -: 9776:#else /* not emacs */
        -: 9777:	if (! fail_stack.stack)
        -: 9778:	  fail_stack.stack
        -: 9779:	    = (fail_stack_elt_t *) malloc (fail_stack.size
        -: 9780:					   * sizeof (fail_stack_elt_t));
        -: 9781:	else
        -: 9782:	  fail_stack.stack
        -: 9783:	    = (fail_stack_elt_t *) realloc (fail_stack.stack,
        -: 9784:					    (fail_stack.size
        -: 9785:					     * sizeof (fail_stack_elt_t)));
        -: 9786:#endif /* not emacs */
        -: 9787:      }
        -: 9788:
        -: 9789:    regex_grow_registers (num_regs);
        -: 9790:  }
        -: 9791:#endif /* not MATCH_MAY_ALLOCATE */
        -: 9792:
        1: 9793:  return REG_NOERROR;
        -: 9794:} /* regex_compile */
        -: 9795:
        -: 9796:/* Subroutines for `regex_compile'.  */
        -: 9797:
        -: 9798:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
        -: 9799:
        -: 9800:static void
        3: 9801:store_op1 (op, loc, arg)
        -: 9802:    re_opcode_t op;
        -: 9803:    unsigned char *loc;
        -: 9804:    int arg;
        -: 9805:{
        3: 9806:  *loc = (unsigned char) op;
        3: 9807:  STORE_NUMBER (loc + 1, arg);
        3: 9808:}
        -: 9809:
        -: 9810:
        -: 9811:/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -: 9812:
        -: 9813:static void
    #####: 9814:store_op2 (op, loc, arg1, arg2)
        -: 9815:    re_opcode_t op;
        -: 9816:    unsigned char *loc;
        -: 9817:    int arg1, arg2;
        -: 9818:{
    #####: 9819:  *loc = (unsigned char) op;
    #####: 9820:  STORE_NUMBER (loc + 1, arg1);
    #####: 9821:  STORE_NUMBER (loc + 3, arg2);
    #####: 9822:}
        -: 9823:
        -: 9824:
        -: 9825:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
        -: 9826:   for OP followed by two-byte integer parameter ARG.  */
        -: 9827:
        -: 9828:static void
        2: 9829:insert_op1 (op, loc, arg, end)
        -: 9830:    re_opcode_t op;
        -: 9831:    unsigned char *loc;
        -: 9832:    int arg;
        -: 9833:    unsigned char *end;
        -: 9834:{
        2: 9835:  register unsigned char *pfrom = end;
        2: 9836:  register unsigned char *pto = end + 3;
        -: 9837:
       17: 9838:  while (pfrom != loc)
       15: 9839:    *--pto = *--pfrom;
        -: 9840:
        2: 9841:  store_op1 (op, loc, arg);
        2: 9842:}
        -: 9843:
        -: 9844:
        -: 9845:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -: 9846:
        -: 9847:static void
    #####: 9848:insert_op2 (op, loc, arg1, arg2, end)
        -: 9849:    re_opcode_t op;
        -: 9850:    unsigned char *loc;
        -: 9851:    int arg1, arg2;
        -: 9852:    unsigned char *end;
        -: 9853:{
    #####: 9854:  register unsigned char *pfrom = end;
    #####: 9855:  register unsigned char *pto = end + 5;
        -: 9856:
    #####: 9857:  while (pfrom != loc)
    #####: 9858:    *--pto = *--pfrom;
        -: 9859:
    #####: 9860:  store_op2 (op, loc, arg1, arg2);
    #####: 9861:}
        -: 9862:
        -: 9863:
        -: 9864:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
        -: 9865:   after an alternative or a begin-subexpression.  We assume there is at
        -: 9866:   least one character before the ^.  */
        -: 9867:
        -: 9868:static boolean
    #####: 9869:at_begline_loc_p (pattern, p, syntax)
        -: 9870:    const char *pattern, *p;
        -: 9871:    reg_syntax_t syntax;
        -: 9872:{
    #####: 9873:  const char *prev = p - 2;
    #####: 9874:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
        -: 9875:
        -: 9876:  return
        -: 9877:       /* After a subexpression?  */
    #####: 9878:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
        -: 9879:       /* After an alternative?  */
    #####: 9880:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
        -: 9881:}
        -: 9882:
        -: 9883:
        -: 9884:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
        -: 9885:   at least one character after the $, i.e., `P < PEND'.  */
        -: 9886:
        -: 9887:static boolean
    #####: 9888:at_endline_loc_p (p, pend, syntax)
        -: 9889:    const char *p, *pend;
        -: 9890:    reg_syntax_t syntax;
        -: 9891:{
    #####: 9892:  const char *next = p;
    #####: 9893:  boolean next_backslash = *next == '\\';
        -: 9894:#ifndef FAULTY_F_KP_9
    #####: 9895:  const char *next_next = p + 1 < pend ? p + 1 : 0;
        -: 9896:#else
        -: 9897:  const char *next_next = p + 1 < pend ? 0 : p + 1;
        -: 9898:#endif
        -: 9899:
        -: 9900:  return
        -: 9901:       /* Before a subexpression?  */
    #####: 9902:       (syntax & RE_NO_BK_PARENS ? *next == ')'
    #####: 9903:        : next_backslash && next_next && *next_next == ')')
        -: 9904:       /* Before an alternative?  */
    #####: 9905:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
    #####: 9906:        : next_backslash && next_next && *next_next == '|');
        -: 9907:}
        -: 9908:
        -: 9909:
        -: 9910:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and
        -: 9911:   false if it's not.  */
        -: 9912:
        -: 9913:static boolean
    #####: 9914:group_in_compile_stack (compile_stack, regnum)
        -: 9915:    compile_stack_type compile_stack;
        -: 9916:    regnum_t regnum;
        -: 9917:{
        -: 9918:  int this_element;
        -: 9919:
    #####: 9920:  for (this_element = compile_stack.avail - 1;
    #####: 9921:       this_element >= 0;
    #####: 9922:       this_element--)
    #####: 9923:    if (compile_stack.stack[this_element].regnum == regnum)
    #####: 9924:      return true;
        -: 9925:
    #####: 9926:  return false;
        -: 9927:}
        -: 9928:
        -: 9929:
        -: 9930:/* Read the ending character of a range (in a bracket expression) from the
        -: 9931:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
        -: 9932:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
        -: 9933:   Then we set the translation of all bits between the starting and
        -: 9934:   ending characters (inclusive) in the compiled pattern B.
        -: 9935:
        -: 9936:   Return an error code.
        -: 9937:
        -: 9938:   We use these short variable names so we can use the same macros as
        -: 9939:   `regex_compile' itself.  */
        -: 9940:
        -: 9941:static reg_errcode_t
    #####: 9942:compile_range (p_ptr, pend, translate, syntax, b)
        -: 9943:    const char **p_ptr, *pend;
        -: 9944:    RE_TRANSLATE_TYPE translate;
        -: 9945:    reg_syntax_t syntax;
        -: 9946:    unsigned char *b;
        -: 9947:{
        -: 9948:  unsigned this_char;
        -: 9949:
    #####: 9950:  const char *p = *p_ptr;
        -: 9951:  unsigned int range_start, range_end;
        -: 9952:
    #####: 9953:  if (p == pend)
    #####: 9954:    return REG_ERANGE;
        -: 9955:
        -: 9956:  /* Even though the pattern is a signed `char *', we need to fetch
        -: 9957:     with unsigned char *'s; if the high bit of the pattern character
        -: 9958:     is set, the range endpoints will be negative if we fetch using a
        -: 9959:     signed char *.
        -: 9960:
        -: 9961:     We also want to fetch the endpoints without translating them; the
        -: 9962:     appropriate translation is done in the bit-setting loop below.  */
        -: 9963:  /* The SVR4 compiler on the 3B2 had trouble with unsigned const char *.  */
    #####: 9964:  range_start = ((const unsigned char *) p)[-2];
    #####: 9965:  range_end   = ((const unsigned char *) p)[0];
        -: 9966:
        -: 9967:  /* Have to increment the pointer into the pattern string, so the
        -: 9968:     caller isn't still at the ending character.  */
    #####: 9969:  (*p_ptr)++;
        -: 9970:
        -: 9971:  /* If the start is after the end, the range is empty.  */
    #####: 9972:  if (range_start > range_end)
    #####: 9973:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
        -: 9974:
        -: 9975:  /* Here we see why `this_char' has to be larger than an `unsigned
        -: 9976:     char' -- the range is inclusive, so if `range_end' == 0xff
        -: 9977:     (assuming 8-bit characters), we would otherwise go into an infinite
        -: 9978:     loop, since all characters <= 0xff.  */
    #####: 9979:  for (this_char = range_start; this_char <= range_end; this_char++)
        -: 9980:    {
    #####: 9981:      SET_LIST_BIT (TRANSLATE (this_char));
        -: 9982:    }
        -: 9983:
    #####: 9984:  return REG_NOERROR;
        -: 9985:}
        -: 9986:
        -: 9987:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
        -: 9988:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
        -: 9989:   characters can start a string that matches the pattern.  This fastmap
        -: 9990:   is used by re_search to skip quickly over impossible starting points.
        -: 9991:
        -: 9992:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
        -: 9993:   area as BUFP->fastmap.
        -: 9994:
        -: 9995:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
        -: 9996:   the pattern buffer.
        -: 9997:
        -: 9998:   Returns 0 if we succeed, -2 if an internal error.   */
        -: 9999:
        -:10000:int
    #####:10001:re_compile_fastmap (bufp)
        -:10002:     struct re_pattern_buffer *bufp;
        -:10003:{
        -:10004:  int j, k;
        -:10005:#ifdef MATCH_MAY_ALLOCATE
        -:10006:  fail_stack_type fail_stack;
        -:10007:#endif
        -:10008:#ifndef REGEX_MALLOC
        -:10009:  char *destination;
        -:10010:#endif
        -:10011:  /* We don't push any register information onto the failure stack.  */
    #####:10012:  unsigned num_regs = 0;
        -:10013:
    #####:10014:  register char *fastmap = bufp->fastmap;
    #####:10015:  unsigned char *pattern = bufp->buffer;
    #####:10016:  unsigned char *p = pattern;
    #####:10017:  register unsigned char *pend = pattern + bufp->used;
        -:10018:
        -:10019:#ifdef REL_ALLOC
        -:10020:  /* This holds the pointer to the failure stack, when
        -:10021:     it is allocated relocatably.  */
        -:10022:  fail_stack_elt_t *failure_stack_ptr;
        -:10023:#endif
        -:10024:
        -:10025:  /* Assume that each path through the pattern can be null until
        -:10026:     proven otherwise.  We set this false at the bottom of switch
        -:10027:     statement, to which we get only if a particular path doesn't
        -:10028:     match the empty string.  */
    #####:10029:  boolean path_can_be_null = true;
        -:10030:
        -:10031:  /* We aren't doing a `succeed_n' to begin with.  */
    #####:10032:  boolean succeed_n_p = false;
        -:10033:
        -:10034:  assert (fastmap != NULL && p != NULL);
        -:10035:
    #####:10036:  INIT_FAIL_STACK ();
    #####:10037:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
    #####:10038:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
    #####:10039:  bufp->can_be_null = 0;
        -:10040:
        -:10041:  while (1)
        -:10042:    {
    #####:10043:      if (p == pend || *p == succeed)
        -:10044:	{
        -:10045:	  /* We have reached the (effective) end of pattern.  */
    #####:10046:	  if (!FAIL_STACK_EMPTY ())
        -:10047:	    {
    #####:10048:	      bufp->can_be_null |= path_can_be_null;
        -:10049:
        -:10050:	      /* Reset for next path.  */
    #####:10051:	      path_can_be_null = true;
        -:10052:
    #####:10053:	      p = fail_stack.stack[--fail_stack.avail].pointer;
        -:10054:
    #####:10055:	      continue;
        -:10056:	    }
        -:10057:	  else
    #####:10058:	    break;
        -:10059:	}
        -:10060:
        -:10061:      /* We should never be about to go beyond the end of the pattern.  */
        -:10062:      assert (p < pend);
        -:10063:
    #####:10064:      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
        -:10065:	{
        -:10066:
        -:10067:        /* I guess the idea here is to simply not bother with a fastmap
        -:10068:           if a backreference is used, since it's too hard to figure out
        -:10069:           the fastmap for the corresponding group.  Setting
        -:10070:           `can_be_null' stops `re_search_2' from using the fastmap, so
        -:10071:           that is all we do.  */
    #####:10072:	case duplicate:
    #####:10073:	  bufp->can_be_null = 1;
    #####:10074:          goto done;
        -:10075:
        -:10076:
        -:10077:      /* Following are the cases which match a character.  These end
        -:10078:         with `break'.  */
        -:10079:
    #####:10080:	case exactn:
    #####:10081:          fastmap[p[1]] = 1;
    #####:10082:	  break;
        -:10083:
        -:10084:
    #####:10085:        case charset:
    #####:10086:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
    #####:10087:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
    #####:10088:              fastmap[j] = 1;
    #####:10089:	  break;
        -:10090:
        -:10091:
    #####:10092:	case charset_not:
        -:10093:	  /* Chars beyond end of map must be allowed.  */
    #####:10094:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
    #####:10095:            fastmap[j] = 1;
        -:10096:
    #####:10097:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
    #####:10098:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
    #####:10099:              fastmap[j] = 1;
    #####:10100:          break;
        -:10101:
        -:10102:
    #####:10103:	case wordchar:
    #####:10104:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
    #####:10105:	    if (SYNTAX (j) == Sword)
    #####:10106:	      fastmap[j] = 1;
    #####:10107:	  break;
        -:10108:
        -:10109:
    #####:10110:	case notwordchar:
    #####:10111:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
    #####:10112:	    if (SYNTAX (j) != Sword)
    #####:10113:	      fastmap[j] = 1;
    #####:10114:	  break;
        -:10115:
        -:10116:
    #####:10117:        case anychar:
        -:10118:	  {
    #####:10119:	    int fastmap_newline = fastmap['\n'];
        -:10120:
        -:10121:	    /* `.' matches anything ...  */
    #####:10122:	    for (j = 0; j < (1 << BYTEWIDTH); j++)
    #####:10123:	      fastmap[j] = 1;
        -:10124:
        -:10125:	    /* ... except perhaps newline.  */
    #####:10126:	    if (!(bufp->syntax & RE_DOT_NEWLINE))
    #####:10127:	      fastmap['\n'] = fastmap_newline;
        -:10128:
        -:10129:	    /* Return if we have already set `can_be_null'; if we have,
        -:10130:	       then the fastmap is irrelevant.  Something's wrong here.  */
    #####:10131:	    else if (bufp->can_be_null)
    #####:10132:	      goto done;
        -:10133:
        -:10134:	    /* Otherwise, have to check alternative paths.  */
    #####:10135:	    break;
        -:10136:	  }
        -:10137:
        -:10138:#ifdef emacs
        -:10139:        case syntaxspec:
        -:10140:	  k = *p++;
        -:10141:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -:10142:	    if (SYNTAX (j) == (enum syntaxcode) k)
        -:10143:	      fastmap[j] = 1;
        -:10144:	  break;
        -:10145:
        -:10146:
        -:10147:	case notsyntaxspec:
        -:10148:	  k = *p++;
        -:10149:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -:10150:	    if (SYNTAX (j) != (enum syntaxcode) k)
        -:10151:	      fastmap[j] = 1;
        -:10152:	  break;
        -:10153:
        -:10154:
        -:10155:      /* All cases after this match the empty string.  These end with
        -:10156:         `continue'.  */
        -:10157:
        -:10158:
        -:10159:	case before_dot:
        -:10160:	case at_dot:
        -:10161:	case after_dot:
        -:10162:          continue;
        -:10163:#endif /* emacs */
        -:10164:
        -:10165:
    #####:10166:        case no_op:
        -:10167:        case begline:
        -:10168:        case endline:
        -:10169:	case begbuf:
        -:10170:	case endbuf:
        -:10171:	case wordbound:
        -:10172:	case notwordbound:
        -:10173:	case wordbeg:
        -:10174:	case wordend:
        -:10175:        case push_dummy_failure:
    #####:10176:          continue;
        -:10177:
        -:10178:
    #####:10179:	case jump_n:
        -:10180:        case pop_failure_jump:
        -:10181:	case maybe_pop_jump:
        -:10182:	case jump:
        -:10183:        case jump_past_alt:
        -:10184:	case dummy_failure_jump:
    #####:10185:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####:10186:	  p += j;
    #####:10187:	  if (j > 0)
    #####:10188:	    continue;
        -:10189:
        -:10190:          /* Jump backward implies we just went through the body of a
        -:10191:             loop and matched nothing.  Opcode jumped to should be
        -:10192:             `on_failure_jump' or `succeed_n'.  Just treat it like an
        -:10193:             ordinary jump.  For a * loop, it has pushed its failure
        -:10194:             point already; if so, discard that as redundant.  */
    #####:10195:          if ((re_opcode_t) *p != on_failure_jump
    #####:10196:	      && (re_opcode_t) *p != succeed_n)
    #####:10197:	    continue;
        -:10198:
    #####:10199:          p++;
    #####:10200:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####:10201:          p += j;
        -:10202:
        -:10203:          /* If what's on the stack is where we are now, pop it.  */
    #####:10204:          if (!FAIL_STACK_EMPTY ()
    #####:10205:	      && fail_stack.stack[fail_stack.avail - 1].pointer == p)
    #####:10206:            fail_stack.avail--;
        -:10207:
    #####:10208:          continue;
        -:10209:
        -:10210:
        -:10211:        case on_failure_jump:
        -:10212:        case on_failure_keep_string_jump:
    #####:10213:	handle_on_failure_jump:
    #####:10214:          EXTRACT_NUMBER_AND_INCR (j, p);
        -:10215:
        -:10216:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
        -:10217:             end of the pattern.  We don't want to push such a point,
        -:10218:             since when we restore it above, entering the switch will
        -:10219:             increment `p' past the end of the pattern.  We don't need
        -:10220:             to push such a point since we obviously won't find any more
        -:10221:             fastmap entries beyond `pend'.  Such a pattern can match
        -:10222:             the null string, though.  */
    #####:10223:          if (p + j < pend)
        -:10224:            {
    #####:10225:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
        -:10226:		{
        -:10227:		  RESET_FAIL_STACK ();
    #####:10228:		  return -2;
        -:10229:		}
        -:10230:            }
        -:10231:          else
    #####:10232:            bufp->can_be_null = 1;
        -:10233:
    #####:10234:          if (succeed_n_p)
        -:10235:            {
    #####:10236:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
    #####:10237:              succeed_n_p = false;
        -:10238:	    }
        -:10239:
    #####:10240:          continue;
        -:10241:
        -:10242:
    #####:10243:	case succeed_n:
        -:10244:          /* Get to the number of times to succeed.  */
    #####:10245:          p += 2;
        -:10246:
        -:10247:          /* Increment p past the n for when k != 0.  */
    #####:10248:          EXTRACT_NUMBER_AND_INCR (k, p);
    #####:10249:          if (k == 0)
        -:10250:	    {
    #####:10251:              p -= 4;
    #####:10252:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
    #####:10253:              goto handle_on_failure_jump;
        -:10254:            }
    #####:10255:          continue;
        -:10256:
        -:10257:
    #####:10258:	case set_number_at:
    #####:10259:          p += 4;
    #####:10260:          continue;
        -:10261:
        -:10262:
    #####:10263:	case start_memory:
        -:10264:        case stop_memory:
    #####:10265:	  p += 2;
    #####:10266:	  continue;
        -:10267:
        -:10268:
    #####:10269:	default:
    #####:10270:          abort (); /* We have listed all the cases.  */
        -:10271:        } /* switch *p++ */
        -:10272:
        -:10273:      /* Getting here means we have found the possible starting
        -:10274:         characters for one path of the pattern -- and that the empty
        -:10275:         string does not match.  We need not follow this path further.
        -:10276:         Instead, look at the next alternative (remembered on the
        -:10277:         stack), or quit if no more.  The test at the top of the loop
        -:10278:         does these things.  */
    #####:10279:      path_can_be_null = false;
    #####:10280:      p = pend;
        -:10281:    } /* while p */
        -:10282:
        -:10283:  /* Set `can_be_null' for the last path (also the first path, if the
        -:10284:     pattern is empty).  */
    #####:10285:  bufp->can_be_null |= path_can_be_null;
        -:10286:
    #####:10287: done:
        -:10288:  RESET_FAIL_STACK ();
    #####:10289:  return 0;
        -:10290:} /* re_compile_fastmap */
        -:10291:
        -:10292:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -:10293:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -:10294:   this memory for recording register information.  STARTS and ENDS
        -:10295:   must be allocated using the malloc library routine, and must each
        -:10296:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -:10297:
        -:10298:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -:10299:   register data.
        -:10300:
        -:10301:   Unless this function is called, the first search or match using
        -:10302:   PATTERN_BUFFER will allocate its own register data, without
        -:10303:   freeing the old data.  */
        -:10304:
        -:10305:void
    #####:10306:re_set_registers (bufp, regs, num_regs, starts, ends)
        -:10307:    struct re_pattern_buffer *bufp;
        -:10308:    struct re_registers *regs;
        -:10309:    unsigned num_regs;
        -:10310:    regoff_t *starts, *ends;
        -:10311:{
    #####:10312:  if (num_regs)
        -:10313:    {
    #####:10314:      bufp->regs_allocated = REGS_REALLOCATE;
    #####:10315:      regs->num_regs = num_regs;
    #####:10316:      regs->start = starts;
    #####:10317:      regs->end = ends;
        -:10318:    }
        -:10319:  else
        -:10320:    {
    #####:10321:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####:10322:      regs->num_regs = 0;
    #####:10323:      regs->start = regs->end = (regoff_t *) 0;
        -:10324:    }
    #####:10325:}
        -:10326:
        -:10327:/* Searching routines.  */
        -:10328:
        -:10329:/* Like re_search_2, below, but only one string is specified, and
        -:10330:   doesn't let you say where to stop matching. */
        -:10331:
        -:10332:int
    #####:10333:re_search (bufp, string, size, startpos, range, regs)
        -:10334:     struct re_pattern_buffer *bufp;
        -:10335:     const char *string;
        -:10336:     int size, startpos, range;
        -:10337:     struct re_registers *regs;
        -:10338:{
    #####:10339:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range,
        -:10340:		      regs, size);
        -:10341:}
        -:10342:
        -:10343:
        -:10344:/* Using the compiled pattern in BUFP->buffer, first tries to match the
        -:10345:   virtual concatenation of STRING1 and STRING2, starting first at index
        -:10346:   STARTPOS, then at STARTPOS + 1, and so on.
        -:10347:
        -:10348:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
        -:10349:
        -:10350:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
        -:10351:   only at STARTPOS; in general, the last start tried is STARTPOS +
        -:10352:   RANGE.
        -:10353:
        -:10354:   In REGS, return the indices of the virtual concatenation of STRING1
        -:10355:   and STRING2 that matched the entire BUFP->buffer and its contained
        -:10356:   subexpressions.
        -:10357:
        -:10358:   Do not consider matching one past the index STOP in the virtual
        -:10359:   concatenation of STRING1 and STRING2.
        -:10360:
        -:10361:   We return either the position in the strings at which the match was
        -:10362:   found, -1 if no match, or -2 if error (such as failure
        -:10363:   stack overflow).  */
        -:10364:
        -:10365:int
    #####:10366:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
        -:10367:     struct re_pattern_buffer *bufp;
        -:10368:     const char *string1, *string2;
        -:10369:     int size1, size2;
        -:10370:     int startpos;
        -:10371:     int range;
        -:10372:     struct re_registers *regs;
        -:10373:     int stop;
        -:10374:{
        -:10375:  int val;
    #####:10376:  register char *fastmap = bufp->fastmap;
    #####:10377:  register RE_TRANSLATE_TYPE translate = bufp->translate;
    #####:10378:  int total_size = size1 + size2;
    #####:10379:  int endpos = startpos + range;
        -:10380:
        -:10381:  /* Check for out-of-range STARTPOS.  */
    #####:10382:  if (startpos < 0 || startpos > total_size)
    #####:10383:    return -1;
        -:10384:
        -:10385:  /* Fix up RANGE if it might eventually take us outside
        -:10386:     the virtual concatenation of STRING1 and STRING2.
        -:10387:     Make sure we won't move STARTPOS below 0 or above TOTAL_SIZE.  */
    #####:10388:  if (endpos < 0)
    #####:10389:    range = 0 - startpos;
    #####:10390:  else if (endpos > total_size)
    #####:10391:    range = total_size - startpos;
        -:10392:
        -:10393:  /* If the search isn't to be a backwards one, don't waste time in a
        -:10394:     search for a pattern that must be anchored.  */
    #####:10395:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
        -:10396:    {
    #####:10397:      if (startpos > 0)
    #####:10398:	return -1;
        -:10399:      else
    #####:10400:	range = 1;
        -:10401:    }
        -:10402:
        -:10403:#ifdef emacs
        -:10404:  /* In a forward search for something that starts with \=.
        -:10405:     don't keep searching past point.  */
        -:10406:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == at_dot && range > 0)
        -:10407:    {
        -:10408:      range = PT - startpos;
        -:10409:      if (range <= 0)
        -:10410:	return -1;
        -:10411:    }
        -:10412:#endif /* emacs */
        -:10413:
        -:10414:  /* Update the fastmap now if not correct already.  */
    #####:10415:  if (fastmap && !bufp->fastmap_accurate)
    #####:10416:    if (re_compile_fastmap (bufp) == -2)
    #####:10417:      return -2;
        -:10418:
        -:10419:  /* Loop through the string, looking for a place to start matching.  */
        -:10420:  for (;;)
        -:10421:    {
        -:10422:      /* If a fastmap is supplied, skip quickly over characters that
        -:10423:         cannot be the start of a match.  If the pattern can match the
        -:10424:         null string, however, we don't need to skip characters; we want
        -:10425:         the first null string.  */
    #####:10426:      if (fastmap && startpos < total_size && !bufp->can_be_null)
        -:10427:	{
    #####:10428:	  if (range > 0)	/* Searching forwards.  */
        -:10429:	    {
        -:10430:	      register const char *d;
    #####:10431:	      register int lim = 0;
    #####:10432:	      int irange = range;
        -:10433:
    #####:10434:              if (startpos < size1 && startpos + range >= size1)
    #####:10435:                lim = range - (size1 - startpos);
        -:10436:
    #####:10437:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
        -:10438:
        -:10439:              /* Written out as an if-else to avoid testing `translate'
        -:10440:                 inside the loop.  */
    #####:10441:	      if (translate)
    #####:10442:                while (range > lim
    #####:10443:                       && !fastmap[(unsigned char)
    #####:10444:				   translate[(unsigned char) *d++]])
    #####:10445:                  range--;
        -:10446:	      else
    #####:10447:                while (range > lim && !fastmap[(unsigned char) *d++])
    #####:10448:                  range--;
        -:10449:
    #####:10450:	      startpos += irange - range;
        -:10451:	    }
        -:10452:	  else				/* Searching backwards.  */
        -:10453:	    {
    #####:10454:	      register char c = (size1 == 0 || startpos >= size1
    #####:10455:                                 ? string2[startpos - size1]
    #####:10456:                                 : string1[startpos]);
        -:10457:
    #####:10458:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
    #####:10459:		goto advance;
        -:10460:	    }
        -:10461:	}
        -:10462:
        -:10463:      /* If can't match the null string, and that's all we have left, fail.  */
    #####:10464:      if (range >= 0 && startpos == total_size && fastmap
    #####:10465:          && !bufp->can_be_null)
    #####:10466:	return -1;
        -:10467:
    #####:10468:      val = re_match_2_internal (bufp, string1, size1, string2, size2,
        -:10469:				 startpos, regs, stop);
        -:10470:#ifndef REGEX_MALLOC
        -:10471:#ifdef C_ALLOCA
        -:10472:      alloca (0);
        -:10473:#endif
        -:10474:#endif
        -:10475:
    #####:10476:      if (val >= 0)
    #####:10477:	return startpos;
        -:10478:
    #####:10479:      if (val == -2)
    #####:10480:	return -2;
        -:10481:
    #####:10482:    advance:
    #####:10483:      if (!range)
    #####:10484:        break;
    #####:10485:      else if (range > 0)
        -:10486:        {
    #####:10487:          range--;
    #####:10488:          startpos++;
        -:10489:        }
        -:10490:      else
        -:10491:        {
    #####:10492:          range++;
    #####:10493:          startpos--;
        -:10494:        }
        -:10495:    }
    #####:10496:  return -1;
        -:10497:} /* re_search_2 */
        -:10498:
        -:10499:/* This converts PTR, a pointer into one of the search strings `string1'
        -:10500:   and `string2' into an offset from the beginning of that string.  */
        -:10501:#define POINTER_TO_OFFSET(ptr)			\
        -:10502:  (FIRST_STRING_P (ptr)				\
        -:10503:   ? ((regoff_t) ((ptr) - string1))		\
        -:10504:   : ((regoff_t) ((ptr) - string2 + size1)))
        -:10505:
        -:10506:/* Macros for dealing with the split strings in re_match_2.  */
        -:10507:
        -:10508:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
        -:10509:
        -:10510:/* Call before fetching a character with *d.  This switches over to
        -:10511:   string2 if necessary.  */
        -:10512:#define PREFETCH()							\
        -:10513:  while (d == dend)						    	\
        -:10514:    {									\
        -:10515:      /* End of string2 => fail.  */					\
        -:10516:      if (dend == end_match_2) 						\
        -:10517:        goto fail;							\
        -:10518:      /* End of string1 => advance to string2.  */ 			\
        -:10519:      d = string2;						        \
        -:10520:      dend = end_match_2;						\
        -:10521:    }
        -:10522:
        -:10523:
        -:10524:/* Test if at very beginning or at very end of the virtual concatenation
        -:10525:   of `string1' and `string2'.  If only one string, it's `string2'.  */
        -:10526:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
        -:10527:#define AT_STRINGS_END(d) ((d) == end2)
        -:10528:
        -:10529:
        -:10530:/* Test if D points to a character which is word-constituent.  We have
        -:10531:   two special cases to check for: if past the end of string1, look at
        -:10532:   the first character in string2; and if before the beginning of
        -:10533:   string2, look at the last character in string1.  */
        -:10534:#define WORDCHAR_P(d)							\
        -:10535:  (SYNTAX ((d) == end1 ? *string2					\
        -:10536:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
        -:10537:   == Sword)
        -:10538:
        -:10539:/* Disabled due to a compiler bug -- see comment at case wordbound */
        -:10540:#if 0
        -:10541:/* Test if the character before D and the one at D differ with respect
        -:10542:   to being word-constituent.  */
        -:10543:#define AT_WORD_BOUNDARY(d)						\
        -:10544:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
        -:10545:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
        -:10546:#endif
        -:10547:
        -:10548:/* Free everything we malloc.  */
        -:10549:#ifdef MATCH_MAY_ALLOCATE
        -:10550:#define FREE_VAR(var) if (var) REGEX_FREE (var); var = NULL
        -:10551:#define FREE_VARIABLES()						\
        -:10552:  do {									\
        -:10553:    REGEX_FREE_STACK (fail_stack.stack);				\
        -:10554:    FREE_VAR (regstart);						\
        -:10555:    FREE_VAR (regend);							\
        -:10556:    FREE_VAR (old_regstart);						\
        -:10557:    FREE_VAR (old_regend);						\
        -:10558:    FREE_VAR (best_regstart);						\
        -:10559:    FREE_VAR (best_regend);						\
        -:10560:    FREE_VAR (reg_info);						\
        -:10561:    FREE_VAR (reg_dummy);						\
        -:10562:    FREE_VAR (reg_info_dummy);						\
        -:10563:  } while (0)
        -:10564:#else
        -:10565:#define FREE_VARIABLES() ((void)0) /* Do nothing!  But inhibit gcc warning.  */
        -:10566:#endif /* not MATCH_MAY_ALLOCATE */
        -:10567:
        -:10568:/* These values must meet several constraints.  They must not be valid
        -:10569:   register values; since we have a limit of 255 registers (because
        -:10570:   we use only one byte in the pattern for the register number), we can
        -:10571:   use numbers larger than 255.  They must differ by 1, because of
        -:10572:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
        -:10573:   be larger than the value for the highest register, so we do not try
        -:10574:   to actually save any registers when none are active.  */
        -:10575:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
        -:10576:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
        -:10577:
        -:10578:/* Matching routines.  */
        -:10579:
        -:10580:#ifndef emacs   /* Emacs never uses this.  */
        -:10581:/* re_match is like re_match_2 except it takes only a single string.  */
        -:10582:
        -:10583:int
    #####:10584:re_match (bufp, string, size, pos, regs)
        -:10585:     struct re_pattern_buffer *bufp;
        -:10586:     const char *string;
        -:10587:     int size, pos;
        -:10588:     struct re_registers *regs;
        -:10589:{
    #####:10590:  int result = re_match_2_internal (bufp, NULL, 0, string, size,
        -:10591:				    pos, regs, size);
        -:10592:#ifndef REGEX_MALLOC
        -:10593:#ifdef C_ALLOCA
        -:10594:  alloca (0);
        -:10595:#endif
        -:10596:#endif
    #####:10597:  return result;
        -:10598:}
        -:10599:#endif /* not emacs */
        -:10600:
        -:10601:static boolean group_match_null_string_p _RE_ARGS ((unsigned char **p,
        -:10602:						    unsigned char *end,
        -:10603:						register_info_type *reg_info));
        -:10604:static boolean alt_match_null_string_p _RE_ARGS ((unsigned char *p,
        -:10605:						  unsigned char *end,
        -:10606:						register_info_type *reg_info));
        -:10607:static boolean common_op_match_null_string_p _RE_ARGS ((unsigned char **p,
        -:10608:							unsigned char *end,
        -:10609:						register_info_type *reg_info));
        -:10610:static int bcmp_translate _RE_ARGS ((const char *s1, const char *s2,
        -:10611:				     int len, char *translate));
        -:10612:
        -:10613:/* re_match_2 matches the compiled pattern in BUFP against the
        -:10614:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
        -:10615:   and SIZE2, respectively).  We start matching at POS, and stop
        -:10616:   matching at STOP.
        -:10617:
        -:10618:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
        -:10619:   store offsets for the substring each group matched in REGS.  See the
        -:10620:   documentation for exactly how many groups we fill.
        -:10621:
        -:10622:   We return -1 if no match, -2 if an internal error (such as the
        -:10623:   failure stack overflowing).  Otherwise, we return the length of the
        -:10624:   matched substring.  */
        -:10625:
        -:10626:int
    #####:10627:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -:10628:     struct re_pattern_buffer *bufp;
        -:10629:     const char *string1, *string2;
        -:10630:     int size1, size2;
        -:10631:     int pos;
        -:10632:     struct re_registers *regs;
        -:10633:     int stop;
        -:10634:{
    #####:10635:  int result = re_match_2_internal (bufp, string1, size1, string2, size2,
        -:10636:				    pos, regs, stop);
        -:10637:#ifndef REGEX_MALLOC
        -:10638:#ifdef C_ALLOCA
        -:10639:  alloca (0);
        -:10640:#endif
        -:10641:#endif
    #####:10642:  return result;
        -:10643:}
        -:10644:
        -:10645:/* This is a separate function so that we can force an alloca cleanup
        -:10646:   afterwards.  */
        -:10647:static int
    #####:10648:re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)
        -:10649:     struct re_pattern_buffer *bufp;
        -:10650:     const char *string1, *string2;
        -:10651:     int size1, size2;
        -:10652:     int pos;
        -:10653:     struct re_registers *regs;
        -:10654:     int stop;
    #####:10655:{
        -:10656:  /* General temporaries.  */
        -:10657:  int mcnt;
        -:10658:  unsigned char *p1;
        -:10659:
        -:10660:  /* Just past the end of the corresponding string.  */
        -:10661:  const char *end1, *end2;
        -:10662:
        -:10663:  /* Pointers into string1 and string2, just past the last characters in
        -:10664:     each to consider matching.  */
        -:10665:  const char *end_match_1, *end_match_2;
        -:10666:
        -:10667:  /* Where we are in the data, and the end of the current string.  */
        -:10668:  const char *d, *dend;
        -:10669:
        -:10670:  /* Where we are in the pattern, and the end of the pattern.  */
    #####:10671:  unsigned char *p = bufp->buffer;
    #####:10672:  register unsigned char *pend = p + bufp->used;
        -:10673:
        -:10674:  /* Mark the opcode just after a start_memory, so we can test for an
        -:10675:     empty subpattern when we get to the stop_memory.  */
    #####:10676:  unsigned char *just_past_start_mem = 0;
        -:10677:
        -:10678:  /* We use this to map every character in the string.  */
    #####:10679:  RE_TRANSLATE_TYPE translate = bufp->translate;
        -:10680:
        -:10681:  /* Failure point stack.  Each place that can handle a failure further
        -:10682:     down the line pushes a failure point on this stack.  It consists of
        -:10683:     restart, regend, and reg_info for all registers corresponding to
        -:10684:     the subexpressions we're currently inside, plus the number of such
        -:10685:     registers, and, finally, two char *'s.  The first char * is where
        -:10686:     to resume scanning the pattern; the second one is where to resume
        -:10687:     scanning the strings.  If the latter is zero, the failure point is
        -:10688:     a ``dummy''; if a failure happens and the failure point is a dummy,
        -:10689:     it gets discarded and the next next one is tried.  */
        -:10690:#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
        -:10691:  fail_stack_type fail_stack;
        -:10692:#endif
        -:10693:#ifdef DEBUG
        -:10694:  static unsigned failure_id = 0;
        -:10695:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
        -:10696:#endif
        -:10697:
        -:10698:#ifdef REL_ALLOC
        -:10699:  /* This holds the pointer to the failure stack, when
        -:10700:     it is allocated relocatably.  */
        -:10701:  fail_stack_elt_t *failure_stack_ptr;
        -:10702:#endif
        -:10703:
        -:10704:  /* We fill all the registers internally, independent of what we
        -:10705:     return, for use in backreferences.  The number here includes
        -:10706:     an element for register zero.  */
    #####:10707:  size_t num_regs = bufp->re_nsub + 1;
        -:10708:
        -:10709:  /* The currently active registers.  */
    #####:10710:  active_reg_t lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####:10711:  active_reg_t highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -:10712:
        -:10713:  /* Information on the contents of registers. These are pointers into
        -:10714:     the input strings; they record just what was matched (on this
        -:10715:     attempt) by a subexpression part of the pattern, that is, the
        -:10716:     regnum-th regstart pointer points to where in the pattern we began
        -:10717:     matching and the regnum-th regend points to right after where we
        -:10718:     stopped matching the regnum-th subexpression.  (The zeroth register
        -:10719:     keeps track of what the whole pattern matches.)  */
        -:10720:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:10721:  const char **regstart, **regend;
        -:10722:#endif
        -:10723:
        -:10724:  /* If a group that's operated upon by a repetition operator fails to
        -:10725:     match anything, then the register for its start will need to be
        -:10726:     restored because it will have been set to wherever in the string we
        -:10727:     are when we last see its open-group operator.  Similarly for a
        -:10728:     register's end.  */
        -:10729:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:10730:  const char **old_regstart, **old_regend;
        -:10731:#endif
        -:10732:
        -:10733:  /* The is_active field of reg_info helps us keep track of which (possibly
        -:10734:     nested) subexpressions we are currently in. The matched_something
        -:10735:     field of reg_info[reg_num] helps us tell whether or not we have
        -:10736:     matched any of the pattern so far this time through the reg_num-th
        -:10737:     subexpression.  These two fields get reset each time through any
        -:10738:     loop their register is in.  */
        -:10739:#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
        -:10740:  register_info_type *reg_info;
        -:10741:#endif
        -:10742:
        -:10743:  /* The following record the register info as found in the above
        -:10744:     variables when we find a match better than any we've seen before.
        -:10745:     This happens as we backtrack through the failure points, which in
        -:10746:     turn happens only if we have not yet matched the entire string. */
    #####:10747:  unsigned best_regs_set = false;
        -:10748:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:10749:  const char **best_regstart, **best_regend;
        -:10750:#endif
        -:10751:
        -:10752:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
        -:10753:     allocate space for that if we're not allocating space for anything
        -:10754:     else (see below).  Also, we never need info about register 0 for
        -:10755:     any of the other register vectors, and it seems rather a kludge to
        -:10756:     treat `best_regend' differently than the rest.  So we keep track of
        -:10757:     the end of the best match so far in a separate variable.  We
        -:10758:     initialize this to NULL so that when we backtrack the first time
        -:10759:     and need to test it, it's not garbage.  */
    #####:10760:  const char *match_end = NULL;
        -:10761:
        -:10762:  /* This helps SET_REGS_MATCHED avoid doing redundant work.  */
    #####:10763:  int set_regs_matched_done = 0;
        -:10764:
        -:10765:  /* Used when we pop values we don't care about.  */
        -:10766:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:10767:  const char **reg_dummy;
        -:10768:  register_info_type *reg_info_dummy;
        -:10769:#endif
        -:10770:
        -:10771:#ifdef DEBUG
        -:10772:  /* Counts the total number of registers pushed.  */
        -:10773:  unsigned num_regs_pushed = 0;
        -:10774:#endif
        -:10775:
        -:10776:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
        -:10777:
    #####:10778:  INIT_FAIL_STACK ();
        -:10779:
        -:10780:#ifdef MATCH_MAY_ALLOCATE
        -:10781:  /* Do not bother to initialize all the register variables if there are
        -:10782:     no groups in the pattern, as it takes a fair amount of time.  If
        -:10783:     there are groups, we include space for register 0 (the whole
        -:10784:     pattern), even though we never use it, since it simplifies the
        -:10785:     array indexing.  We should fix this.  */
    #####:10786:  if (bufp->re_nsub)
        -:10787:    {
    #####:10788:      regstart = REGEX_TALLOC (num_regs, const char *);
    #####:10789:      regend = REGEX_TALLOC (num_regs, const char *);
    #####:10790:      old_regstart = REGEX_TALLOC (num_regs, const char *);
    #####:10791:      old_regend = REGEX_TALLOC (num_regs, const char *);
    #####:10792:      best_regstart = REGEX_TALLOC (num_regs, const char *);
    #####:10793:      best_regend = REGEX_TALLOC (num_regs, const char *);
    #####:10794:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
    #####:10795:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
    #####:10796:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
        -:10797:
    #####:10798:      if (!(regstart && regend && old_regstart && old_regend && reg_info
    #####:10799:            && best_regstart && best_regend && reg_dummy && reg_info_dummy))
        -:10800:        {
    #####:10801:          FREE_VARIABLES ();
    #####:10802:          return -2;
        -:10803:        }
        -:10804:    }
        -:10805:  else
        -:10806:    {
        -:10807:      /* We must initialize all our variables to NULL, so that
        -:10808:         `FREE_VARIABLES' doesn't try to free them.  */
    #####:10809:      regstart = regend = old_regstart = old_regend = best_regstart
    #####:10810:        = best_regend = reg_dummy = NULL;
    #####:10811:      reg_info = reg_info_dummy = (register_info_type *) NULL;
        -:10812:    }
        -:10813:#endif /* MATCH_MAY_ALLOCATE */
        -:10814:
        -:10815:  /* The starting position is bogus.  */
    #####:10816:  if (pos < 0 || pos > size1 + size2)
        -:10817:    {
    #####:10818:      FREE_VARIABLES ();
    #####:10819:      return -1;
        -:10820:    }
        -:10821:
        -:10822:  /* Initialize subexpression text positions to -1 to mark ones that no
        -:10823:     start_memory/stop_memory has been seen for. Also initialize the
        -:10824:     register information struct.  */
    #####:10825:  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
        -:10826:    {
    #####:10827:      regstart[mcnt] = regend[mcnt]
    #####:10828:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
        -:10829:
    #####:10830:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
    #####:10831:      IS_ACTIVE (reg_info[mcnt]) = 0;
    #####:10832:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
    #####:10833:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
        -:10834:    }
        -:10835:
        -:10836:  /* We move `string1' into `string2' if the latter's empty -- but not if
        -:10837:     `string1' is null.  */
    #####:10838:  if (size2 == 0 && string1 != NULL)
        -:10839:    {
    #####:10840:      string2 = string1;
    #####:10841:      size2 = size1;
    #####:10842:      string1 = 0;
    #####:10843:      size1 = 0;
        -:10844:    }
    #####:10845:  end1 = string1 + size1;
    #####:10846:  end2 = string2 + size2;
        -:10847:
        -:10848:  /* Compute where to stop matching, within the two strings.  */
    #####:10849:  if (stop <= size1)
        -:10850:    {
    #####:10851:      end_match_1 = string1 + stop;
    #####:10852:      end_match_2 = string2;
        -:10853:    }
        -:10854:  else
        -:10855:    {
    #####:10856:      end_match_1 = end1;
    #####:10857:      end_match_2 = string2 + stop - size1;
        -:10858:    }
        -:10859:
        -:10860:  /* `p' scans through the pattern as `d' scans through the data.
        -:10861:     `dend' is the end of the input string that `d' points within.  `d'
        -:10862:     is advanced into the following input string whenever necessary, but
        -:10863:     this happens before fetching; therefore, at the beginning of the
        -:10864:     loop, `d' can be pointing at the end of a string, but it cannot
        -:10865:     equal `string2'.  */
    #####:10866:  if (size1 > 0 && pos <= size1)
        -:10867:    {
    #####:10868:      d = string1 + pos;
    #####:10869:      dend = end_match_1;
        -:10870:    }
        -:10871:  else
        -:10872:    {
    #####:10873:      d = string2 + pos - size1;
    #####:10874:      dend = end_match_2;
        -:10875:    }
        -:10876:
        -:10877:  DEBUG_PRINT1 ("The compiled pattern is:\n");
        -:10878:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
        -:10879:  DEBUG_PRINT1 ("The string to match is: `");
        -:10880:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
        -:10881:  DEBUG_PRINT1 ("'\n");
        -:10882:
        -:10883:  /* This loops over pattern commands.  It exits by returning from the
        -:10884:     function if the match is complete, or it drops through if the match
        -:10885:     fails at this starting point in the input data.  */
        -:10886:  for (;;)
        -:10887:    {
        -:10888:#ifdef _LIBC
        -:10889:      DEBUG_PRINT2 ("\n%p: ", p);
        -:10890:#else
        -:10891:      DEBUG_PRINT2 ("\n0x%x: ", p);
        -:10892:#endif
        -:10893:
    #####:10894:      if (p == pend)
        -:10895:	{ /* End of pattern means we might have succeeded.  */
        -:10896:          DEBUG_PRINT1 ("end of pattern ... ");
        -:10897:
        -:10898:	  /* If we haven't matched the entire string, and we want the
        -:10899:             longest match, try backtracking.  */
    #####:10900:          if (d != end_match_2)
        -:10901:	    {
        -:10902:	      /* 1 if this match ends in the same string (string1 or string2)
        -:10903:		 as the best previous match.  */
    #####:10904:	      boolean same_str_p = (FIRST_STRING_P (match_end)
    #####:10905:				    == MATCHING_IN_FIRST_STRING);
        -:10906:	      /* 1 if this match is the best seen so far.  */
        -:10907:	      boolean best_match_p;
        -:10908:
        -:10909:	      /* AIX compiler got confused when this was combined
        -:10910:		 with the previous declaration.  */
    #####:10911:	      if (same_str_p)
    #####:10912:		best_match_p = d > match_end;
        -:10913:	      else
    #####:10914:		best_match_p = !MATCHING_IN_FIRST_STRING;
        -:10915:
        -:10916:              DEBUG_PRINT1 ("backtracking.\n");
        -:10917:
    #####:10918:              if (!FAIL_STACK_EMPTY ())
        -:10919:                { /* More failure points to try.  */
        -:10920:
        -:10921:                  /* If exceeds best match so far, save it.  */
    #####:10922:                  if (!best_regs_set || best_match_p)
        -:10923:                    {
    #####:10924:                      best_regs_set = true;
    #####:10925:                      match_end = d;
        -:10926:
        -:10927:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
        -:10928:
    #####:10929:                      for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
        -:10930:                        {
    #####:10931:                          best_regstart[mcnt] = regstart[mcnt];
    #####:10932:                          best_regend[mcnt] = regend[mcnt];
        -:10933:                        }
        -:10934:                    }
    #####:10935:                  goto fail;
        -:10936:                }
        -:10937:
        -:10938:              /* If no failure points, don't restore garbage.  And if
        -:10939:                 last match is real best match, don't restore second
        -:10940:                 best one. */
    #####:10941:              else if (best_regs_set && !best_match_p)
        -:10942:                {
    #####:10943:  	        restore_best_regs:
        -:10944:                  /* Restore best match.  It may happen that `dend ==
        -:10945:                     end_match_1' while the restored d is in string2.
        -:10946:                     For example, the pattern `x.*y.*z' against the
        -:10947:                     strings `x-' and `y-z-', if the two strings are
        -:10948:                     not consecutive in memory.  */
        -:10949:                  DEBUG_PRINT1 ("Restoring best registers.\n");
        -:10950:
    #####:10951:                  d = match_end;
    #####:10952:                  dend = ((d >= string1 && d <= end1)
    #####:10953:		           ? end_match_1 : end_match_2);
        -:10954:
    #####:10955:		  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
        -:10956:		    {
    #####:10957:		      regstart[mcnt] = best_regstart[mcnt];
    #####:10958:		      regend[mcnt] = best_regend[mcnt];
        -:10959:		    }
        -:10960:                }
        -:10961:            } /* d != end_match_2 */
        -:10962:
    #####:10963:	succeed_label:
        -:10964:          DEBUG_PRINT1 ("Accepting match.\n");
        -:10965:
        -:10966:          /* If caller wants register contents data back, do it.  */
    #####:10967:          if (regs && !bufp->no_sub)
        -:10968:	    {
        -:10969:              /* Have the register data arrays been allocated?  */
    #####:10970:              if (bufp->regs_allocated == REGS_UNALLOCATED)
        -:10971:                { /* No.  So allocate them with malloc.  We need one
        -:10972:                     extra element beyond `num_regs' for the `-1' marker
        -:10973:                     GNU code uses.  */
    #####:10974:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
    #####:10975:                  regs->start = TALLOC (regs->num_regs, regoff_t);
    #####:10976:                  regs->end = TALLOC (regs->num_regs, regoff_t);
    #####:10977:                  if (regs->start == NULL || regs->end == NULL)
        -:10978:		    {
    #####:10979:		      FREE_VARIABLES ();
    #####:10980:		      return -2;
        -:10981:		    }
    #####:10982:                  bufp->regs_allocated = REGS_REALLOCATE;
        -:10983:                }
    #####:10984:              else if (bufp->regs_allocated == REGS_REALLOCATE)
        -:10985:                { /* Yes.  If we need more elements than were already
        -:10986:                     allocated, reallocate them.  If we need fewer, just
        -:10987:                     leave it alone.  */
    #####:10988:                  if (regs->num_regs < num_regs + 1)
        -:10989:                    {
    #####:10990:                      regs->num_regs = num_regs + 1;
    #####:10991:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
    #####:10992:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
    #####:10993:                      if (regs->start == NULL || regs->end == NULL)
        -:10994:			{
    #####:10995:			  FREE_VARIABLES ();
    #####:10996:			  return -2;
        -:10997:			}
        -:10998:                    }
        -:10999:                }
        -:11000:              else
        -:11001:		{
        -:11002:		  /* These braces fend off a "empty body in an else-statement"
        -:11003:		     warning under GCC when assert expands to nothing.  */
        -:11004:		  assert (bufp->regs_allocated == REGS_FIXED);
        -:11005:		}
        -:11006:
        -:11007:              /* Convert the pointer data in `regstart' and `regend' to
        -:11008:                 indices.  Register zero has to be set differently,
        -:11009:                 since we haven't kept track of any info for it.  */
    #####:11010:              if (regs->num_regs > 0)
        -:11011:                {
    #####:11012:                  regs->start[0] = pos;
    #####:11013:                  regs->end[0] = (MATCHING_IN_FIRST_STRING
    #####:11014:				  ? ((regoff_t) (d - string1))
    #####:11015:			          : ((regoff_t) (d - string2 + size1)));
        -:11016:                }
        -:11017:
        -:11018:              /* Go through the first `min (num_regs, regs->num_regs)'
        -:11019:                 registers, since that is all we initialized.  */
    #####:11020:	      for (mcnt = 1; (unsigned) mcnt < MIN (num_regs, regs->num_regs);
    #####:11021:		   mcnt++)
        -:11022:		{
    #####:11023:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
    #####:11024:                    regs->start[mcnt] = regs->end[mcnt] = -1;
        -:11025:                  else
        -:11026:                    {
    #####:11027:		      regs->start[mcnt]
    #####:11028:			= (regoff_t) POINTER_TO_OFFSET (regstart[mcnt]);
    #####:11029:                      regs->end[mcnt]
    #####:11030:			= (regoff_t) POINTER_TO_OFFSET (regend[mcnt]);
        -:11031:                    }
        -:11032:		}
        -:11033:
        -:11034:              /* If the regs structure we return has more elements than
        -:11035:                 were in the pattern, set the extra elements to -1.  If
        -:11036:                 we (re)allocated the registers, this is the case,
        -:11037:                 because we always allocate enough to have at least one
        -:11038:                 -1 at the end.  */
    #####:11039:              for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++)
    #####:11040:                regs->start[mcnt] = regs->end[mcnt] = -1;
        -:11041:	    } /* regs && !bufp->no_sub */
        -:11042:
        -:11043:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
        -:11044:                        nfailure_points_pushed, nfailure_points_popped,
        -:11045:                        nfailure_points_pushed - nfailure_points_popped);
        -:11046:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
        -:11047:
    #####:11048:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING
        -:11049:			    ? string1
    #####:11050:			    : string2 - size1);
        -:11051:
        -:11052:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
        -:11053:
    #####:11054:          FREE_VARIABLES ();
    #####:11055:          return mcnt;
        -:11056:        }
        -:11057:
        -:11058:      /* Otherwise match next pattern command.  */
    #####:11059:      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
        -:11060:	{
        -:11061:        /* Ignore these.  Used to ignore the n of succeed_n's which
        -:11062:           currently have n == 0.  */
    #####:11063:        case no_op:
        -:11064:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
    #####:11065:          break;
        -:11066:
    #####:11067:	case succeed:
        -:11068:          DEBUG_PRINT1 ("EXECUTING succeed.\n");
    #####:11069:	  goto succeed_label;
        -:11070:
        -:11071:        /* Match the next n pattern characters exactly.  The following
        -:11072:           byte in the pattern defines n, and the n bytes after that
        -:11073:           are the characters to match.  */
    #####:11074:	case exactn:
    #####:11075:	  mcnt = *p++;
        -:11076:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
        -:11077:
        -:11078:          /* This is written out as an if-else so we don't waste time
        -:11079:             testing `translate' inside the loop.  */
    #####:11080:          if (translate)
        -:11081:	    {
        -:11082:	      do
        -:11083:		{
    #####:11084:		  PREFETCH ();
    #####:11085:		  if ((unsigned char) translate[(unsigned char) *d++]
    #####:11086:		      != (unsigned char) *p++)
    #####:11087:                    goto fail;
        -:11088:		}
    #####:11089:	      while (--mcnt);
        -:11090:	    }
        -:11091:	  else
        -:11092:	    {
        -:11093:	      do
        -:11094:		{
    #####:11095:		  PREFETCH ();
    #####:11096:		  if (*d++ != (char) *p++) goto fail;
        -:11097:		}
    #####:11098:	      while (--mcnt);
        -:11099:	    }
    #####:11100:	  SET_REGS_MATCHED ();
    #####:11101:          break;
        -:11102:
        -:11103:
        -:11104:        /* Match any character except possibly a newline or a null.  */
    #####:11105:	case anychar:
        -:11106:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
        -:11107:
    #####:11108:          PREFETCH ();
        -:11109:
    #####:11110:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
    #####:11111:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
    #####:11112:	    goto fail;
        -:11113:
    #####:11114:          SET_REGS_MATCHED ();
        -:11115:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
    #####:11116:          d++;
    #####:11117:	  break;
        -:11118:
        -:11119:
    #####:11120:	case charset:
        -:11121:	case charset_not:
        -:11122:	  {
        -:11123:	    register unsigned char c;
    #####:11124:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
        -:11125:
        -:11126:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
        -:11127:
    #####:11128:	    PREFETCH ();
    #####:11129:	    c = TRANSLATE (*d); /* The character to match.  */
        -:11130:
        -:11131:            /* Cast to `unsigned' instead of `unsigned char' in case the
        -:11132:               bit list is a full 32 bytes long.  */
    #####:11133:	    if (c < (unsigned) (*p * BYTEWIDTH)
    #####:11134:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
    #####:11135:	      not = !not;
        -:11136:
    #####:11137:	    p += 1 + *p;
        -:11138:
    #####:11139:	    if (!not) goto fail;
        -:11140:
    #####:11141:	    SET_REGS_MATCHED ();
    #####:11142:            d++;
    #####:11143:	    break;
        -:11144:	  }
        -:11145:
        -:11146:
        -:11147:        /* The beginning of a group is represented by start_memory.
        -:11148:           The arguments are the register number in the next byte, and the
        -:11149:           number of groups inner to this one in the next.  The text
        -:11150:           matched within the group is recorded (in the internal
        -:11151:           registers data structure) under the register number.  */
    #####:11152:        case start_memory:
        -:11153:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
        -:11154:
        -:11155:          /* Find out if this group can match the empty string.  */
    #####:11156:	  p1 = p;		/* To send to group_match_null_string_p.  */
        -:11157:
    #####:11158:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
    #####:11159:            REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####:11160:              = group_match_null_string_p (&p1, pend, reg_info);
        -:11161:
        -:11162:          /* Save the position in the string where we were the last time
        -:11163:             we were at this open-group operator in case the group is
        -:11164:             operated upon by a repetition operator, e.g., with `(a*)*b'
        -:11165:             against `ab'; then we want to ignore where we are now in
        -:11166:             the string in case this attempt to match fails.  */
    #####:11167:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####:11168:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
    #####:11169:                             : regstart[*p];
        -:11170:	  DEBUG_PRINT2 ("  old_regstart: %d\n",
        -:11171:			 POINTER_TO_OFFSET (old_regstart[*p]));
        -:11172:
    #####:11173:          regstart[*p] = d;
        -:11174:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
        -:11175:
    #####:11176:          IS_ACTIVE (reg_info[*p]) = 1;
    #####:11177:          MATCHED_SOMETHING (reg_info[*p]) = 0;
        -:11178:
        -:11179:	  /* Clear this whenever we change the register activity status.  */
    #####:11180:	  set_regs_matched_done = 0;
        -:11181:
        -:11182:          /* This is the new highest active register.  */
    #####:11183:          highest_active_reg = *p;
        -:11184:
        -:11185:          /* If nothing was active before, this is the new lowest active
        -:11186:             register.  */
    #####:11187:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
    #####:11188:            lowest_active_reg = *p;
        -:11189:
        -:11190:          /* Move past the register number and inner group count.  */
    #####:11191:          p += 2;
    #####:11192:	  just_past_start_mem = p;
        -:11193:
    #####:11194:          break;
        -:11195:
        -:11196:
        -:11197:        /* The stop_memory opcode represents the end of a group.  Its
        -:11198:           arguments are the same as start_memory's: the register
        -:11199:           number, and the number of inner groups.  */
    #####:11200:	case stop_memory:
        -:11201:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
        -:11202:
        -:11203:          /* We need to save the string position the last time we were at
        -:11204:             this close-group operator in case the group is operated
        -:11205:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
        -:11206:             against `aba'; then we want to ignore where we are now in
        -:11207:             the string in case this attempt to match fails.  */
    #####:11208:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####:11209:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
    #####:11210:			   : regend[*p];
        -:11211:	  DEBUG_PRINT2 ("      old_regend: %d\n",
        -:11212:			 POINTER_TO_OFFSET (old_regend[*p]));
        -:11213:
    #####:11214:          regend[*p] = d;
        -:11215:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
        -:11216:
        -:11217:          /* This register isn't active anymore.  */
    #####:11218:          IS_ACTIVE (reg_info[*p]) = 0;
        -:11219:
        -:11220:	  /* Clear this whenever we change the register activity status.  */
    #####:11221:	  set_regs_matched_done = 0;
        -:11222:
        -:11223:          /* If this was the only register active, nothing is active
        -:11224:             anymore.  */
    #####:11225:          if (lowest_active_reg == highest_active_reg)
        -:11226:            {
    #####:11227:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####:11228:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -:11229:            }
        -:11230:          else
        -:11231:            { /* We must scan for the new highest active register, since
        -:11232:                 it isn't necessarily one less than now: consider
        -:11233:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
        -:11234:                 new highest active register is 1.  */
    #####:11235:              unsigned char r = *p - 1;
    #####:11236:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
    #####:11237:                r--;
        -:11238:
        -:11239:              /* If we end up at register zero, that means that we saved
        -:11240:                 the registers as the result of an `on_failure_jump', not
        -:11241:                 a `start_memory', and we jumped to past the innermost
        -:11242:                 `stop_memory'.  For example, in ((.)*) we save
        -:11243:                 registers 1 and 2 as a result of the *, but when we pop
        -:11244:                 back to the second ), we are at the stop_memory 1.
        -:11245:                 Thus, nothing is active.  */
    #####:11246:	      if (r == 0)
        -:11247:                {
    #####:11248:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####:11249:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -:11250:                }
        -:11251:              else
    #####:11252:                highest_active_reg = r;
        -:11253:            }
        -:11254:
        -:11255:          /* If just failed to match something this time around with a
        -:11256:             group that's operated on by a repetition operator, try to
        -:11257:             force exit from the ``loop'', and restore the register
        -:11258:             information for this group that we had before trying this
        -:11259:             last match.  */
    #####:11260:          if ((!MATCHED_SOMETHING (reg_info[*p])
    #####:11261:               || just_past_start_mem == p - 1)
    #####:11262:	      && (p + 2) < pend)
        -:11263:            {
    #####:11264:              boolean is_a_jump_n = false;
        -:11265:
    #####:11266:              p1 = p + 2;
    #####:11267:              mcnt = 0;
    #####:11268:              switch ((re_opcode_t) *p1++)
        -:11269:                {
    #####:11270:                  case jump_n:
    #####:11271:		    is_a_jump_n = true;
    #####:11272:                  case pop_failure_jump:
        -:11273:		  case maybe_pop_jump:
        -:11274:		  case jump:
        -:11275:		  case dummy_failure_jump:
    #####:11276:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:11277:		    if (is_a_jump_n)
    #####:11278:		      p1 += 2;
    #####:11279:                    break;
        -:11280:
    #####:11281:                  default:
        -:11282:                    /* do nothing */ ;
        -:11283:                }
    #####:11284:	      p1 += mcnt;
        -:11285:
        -:11286:              /* If the next operation is a jump backwards in the pattern
        -:11287:	         to an on_failure_jump right before the start_memory
        -:11288:                 corresponding to this stop_memory, exit from the loop
        -:11289:                 by forcing a failure after pushing on the stack the
        -:11290:                 on_failure_jump's jump in the pattern, and d.  */
    #####:11291:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
    #####:11292:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
        -:11293:		{
        -:11294:                  /* If this group ever matched anything, then restore
        -:11295:                     what its registers were before trying this last
        -:11296:                     failed match, e.g., with `(a*)*b' against `ab' for
        -:11297:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
        -:11298:                     against `aba' for regend[3].
        -:11299:
        -:11300:                     Also restore the registers for inner groups for,
        -:11301:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
        -:11302:                     otherwise get trashed).  */
        -:11303:
    #####:11304:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
        -:11305:		    {
        -:11306:		      unsigned r;
        -:11307:
    #####:11308:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
        -:11309:
        -:11310:		      /* Restore this and inner groups' (if any) registers.  */
    #####:11311:                      for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);
    #####:11312:			   r++)
        -:11313:                        {
    #####:11314:                          regstart[r] = old_regstart[r];
        -:11315:
        -:11316:                          /* xx why this test?  */
    #####:11317:                          if (old_regend[r] >= regstart[r])
    #####:11318:                            regend[r] = old_regend[r];
        -:11319:                        }
        -:11320:                    }
    #####:11321:		  p1++;
    #####:11322:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:11323:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
        -:11324:
    #####:11325:                  goto fail;
        -:11326:                }
        -:11327:            }
        -:11328:
        -:11329:          /* Move past the register number and the inner group count.  */
    #####:11330:          p += 2;
    #####:11331:          break;
        -:11332:
        -:11333:
        -:11334:	/* \<digit> has been turned into a `duplicate' command which is
        -:11335:           followed by the numeric value of <digit> as the register number.  */
    #####:11336:        case duplicate:
        -:11337:	  {
        -:11338:	    register const char *d2, *dend2;
    #####:11339:	    int regno = *p++;   /* Get which register to match against.  */
        -:11340:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
        -:11341:
        -:11342:	    /* Can't back reference a group which we've never matched.  */
    #####:11343:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
    #####:11344:              goto fail;
        -:11345:
        -:11346:            /* Where in input to try to start matching.  */
    #####:11347:            d2 = regstart[regno];
        -:11348:
        -:11349:            /* Where to stop matching; if both the place to start and
        -:11350:               the place to stop matching are in the same string, then
        -:11351:               set to the place to stop, otherwise, for now have to use
        -:11352:               the end of the first string.  */
        -:11353:
    #####:11354:            dend2 = ((FIRST_STRING_P (regstart[regno])
    #####:11355:		      == FIRST_STRING_P (regend[regno]))
    #####:11356:		     ? regend[regno] : end_match_1);
        -:11357:	    for (;;)
        -:11358:	      {
        -:11359:		/* If necessary, advance to next segment in register
        -:11360:                   contents.  */
    #####:11361:		while (d2 == dend2)
        -:11362:		  {
    #####:11363:		    if (dend2 == end_match_2) break;
    #####:11364:		    if (dend2 == regend[regno]) break;
        -:11365:
        -:11366:                    /* End of string1 => advance to string2. */
    #####:11367:                    d2 = string2;
    #####:11368:                    dend2 = regend[regno];
        -:11369:		  }
        -:11370:		/* At end of register contents => success */
    #####:11371:		if (d2 == dend2) break;
        -:11372:
        -:11373:		/* If necessary, advance to next segment in data.  */
    #####:11374:		PREFETCH ();
        -:11375:
        -:11376:		/* How many characters left in this segment to match.  */
    #####:11377:		mcnt = dend - d;
        -:11378:
        -:11379:		/* Want how many consecutive characters we can match in
        -:11380:                   one shot, so, if necessary, adjust the count.  */
    #####:11381:                if (mcnt > dend2 - d2)
    #####:11382:		  mcnt = dend2 - d2;
        -:11383:
        -:11384:		/* Compare that many; failure if mismatch, else move
        -:11385:                   past them.  */
    #####:11386:		if (translate
    #####:11387:                    ? bcmp_translate (d, d2, mcnt, translate)
    #####:11388:                    : bcmp (d, d2, mcnt))
    #####:11389:		  goto fail;
    #####:11390:		d += mcnt, d2 += mcnt;
        -:11391:
        -:11392:		/* Do this because we've match some characters.  */
    #####:11393:		SET_REGS_MATCHED ();
        -:11394:	      }
        -:11395:	  }
    #####:11396:	  break;
        -:11397:
        -:11398:
        -:11399:        /* begline matches the empty string at the beginning of the string
        -:11400:           (unless `not_bol' is set in `bufp'), and, if
        -:11401:           `newline_anchor' is set, after newlines.  */
    #####:11402:	case begline:
        -:11403:          DEBUG_PRINT1 ("EXECUTING begline.\n");
        -:11404:
    #####:11405:          if (AT_STRINGS_BEG (d))
        -:11406:            {
    #####:11407:              if (!bufp->not_bol) break;
        -:11408:            }
    #####:11409:          else if (d[-1] == '\n' && bufp->newline_anchor)
        -:11410:            {
    #####:11411:              break;
        -:11412:            }
        -:11413:          /* In all other cases, we fail.  */
    #####:11414:          goto fail;
        -:11415:
        -:11416:
        -:11417:        /* endline is the dual of begline.  */
    #####:11418:	case endline:
        -:11419:          DEBUG_PRINT1 ("EXECUTING endline.\n");
        -:11420:
    #####:11421:          if (AT_STRINGS_END (d))
        -:11422:            {
    #####:11423:              if (!bufp->not_eol) break;
        -:11424:            }
        -:11425:
        -:11426:          /* We have to ``prefetch'' the next character.  */
    #####:11427:          else if ((d == end1 ? *string2 : *d) == '\n'
    #####:11428:                   && bufp->newline_anchor)
        -:11429:            {
    #####:11430:              break;
        -:11431:            }
    #####:11432:          goto fail;
        -:11433:
        -:11434:
        -:11435:	/* Match at the very beginning of the data.  */
    #####:11436:        case begbuf:
        -:11437:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
    #####:11438:          if (AT_STRINGS_BEG (d))
        -:11439:            break;
    #####:11440:          goto fail;
        -:11441:
        -:11442:
        -:11443:	/* Match at the very end of the data.  */
    #####:11444:        case endbuf:
        -:11445:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
    #####:11446:	  if (AT_STRINGS_END (d))
    #####:11447:	    break;
    #####:11448:          goto fail;
        -:11449:
        -:11450:
        -:11451:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
        -:11452:           pushes NULL as the value for the string on the stack.  Then
        -:11453:           `pop_failure_point' will keep the current value for the
        -:11454:           string, instead of restoring it.  To see why, consider
        -:11455:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
        -:11456:           then the . fails against the \n.  But the next thing we want
        -:11457:           to do is match the \n against the \n; if we restored the
        -:11458:           string value, we would be back at the foo.
        -:11459:
        -:11460:           Because this is used only in specific cases, we don't need to
        -:11461:           check all the things that `on_failure_jump' does, to make
        -:11462:           sure the right things get saved on the stack.  Hence we don't
        -:11463:           share its code.  The only reason to push anything on the
        -:11464:           stack at all is that otherwise we would have to change
        -:11465:           `anychar's code to do something besides goto fail in this
        -:11466:           case; that seems worse than this.  */
    #####:11467:        case on_failure_keep_string_jump:
        -:11468:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
        -:11469:
    #####:11470:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:11471:#ifdef _LIBC
        -:11472:          DEBUG_PRINT3 (" %d (to %p):\n", mcnt, p + mcnt);
        -:11473:#else
        -:11474:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
        -:11475:#endif
        -:11476:
    #####:11477:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
    #####:11478:          break;
        -:11479:
        -:11480:
        -:11481:	/* Uses of on_failure_jump:
        -:11482:
        -:11483:           Each alternative starts with an on_failure_jump that points
        -:11484:           to the beginning of the next alternative.  Each alternative
        -:11485:           except the last ends with a jump that in effect jumps past
        -:11486:           the rest of the alternatives.  (They really jump to the
        -:11487:           ending jump of the following alternative, because tensioning
        -:11488:           these jumps is a hassle.)
        -:11489:
        -:11490:           Repeats start with an on_failure_jump that points past both
        -:11491:           the repetition text and either the following jump or
        -:11492:           pop_failure_jump back to this on_failure_jump.  */
        -:11493:	case on_failure_jump:
    #####:11494:        on_failure:
        -:11495:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
        -:11496:
    #####:11497:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:11498:#ifdef _LIBC
        -:11499:          DEBUG_PRINT3 (" %d (to %p)", mcnt, p + mcnt);
        -:11500:#else
        -:11501:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
        -:11502:#endif
        -:11503:
        -:11504:          /* If this on_failure_jump comes right before a group (i.e.,
        -:11505:             the original * applied to a group), save the information
        -:11506:             for that group and all inner ones, so that if we fail back
        -:11507:             to this point, the group's information will be correct.
        -:11508:             For example, in \(a*\)*\1, we need the preceding group,
        -:11509:             and in \(zz\(a*\)b*\)\2, we need the inner group.  */
        -:11510:
        -:11511:          /* We can't use `p' to check ahead because we push
        -:11512:             a failure point to `p + mcnt' after we do this.  */
    #####:11513:          p1 = p;
        -:11514:
        -:11515:          /* We need to skip no_op's before we look for the
        -:11516:             start_memory in case this on_failure_jump is happening as
        -:11517:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
        -:11518:             against aba.  */
    #####:11519:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
    #####:11520:            p1++;
        -:11521:
    #####:11522:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
        -:11523:            {
        -:11524:              /* We have a new highest active register now.  This will
        -:11525:                 get reset at the start_memory we are about to get to,
        -:11526:                 but we will have saved all the registers relevant to
        -:11527:                 this repetition op, as described above.  */
    #####:11528:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
    #####:11529:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
    #####:11530:                lowest_active_reg = *(p1 + 1);
        -:11531:            }
        -:11532:
        -:11533:          DEBUG_PRINT1 (":\n");
    #####:11534:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
    #####:11535:          break;
        -:11536:
        -:11537:
        -:11538:        /* A smart repeat ends with `maybe_pop_jump'.
        -:11539:	   We change it to either `pop_failure_jump' or `jump'.  */
    #####:11540:        case maybe_pop_jump:
    #####:11541:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:11542:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
        -:11543:          {
    #####:11544:	    register unsigned char *p2 = p;
        -:11545:
        -:11546:            /* Compare the beginning of the repeat with what in the
        -:11547:               pattern follows its end. If we can establish that there
        -:11548:               is nothing that they would both match, i.e., that we
        -:11549:               would have to backtrack because of (as in, e.g., `a*a')
        -:11550:               then we can change to pop_failure_jump, because we'll
        -:11551:               never have to backtrack.
        -:11552:
        -:11553:               This is not true in the case of alternatives: in
        -:11554:               `(a|ab)*' we do need to backtrack to the `ab' alternative
        -:11555:               (e.g., if the string was `ab').  But instead of trying to
        -:11556:               detect that here, the alternative has put on a dummy
        -:11557:               failure point which is what we will end up popping.  */
        -:11558:
        -:11559:	    /* Skip over open/close-group commands.
        -:11560:	       If what follows this loop is a ...+ construct,
        -:11561:	       look at what begins its body, since we will have to
        -:11562:	       match at least one of that.  */
        -:11563:	    while (1)
        -:11564:	      {
    #####:11565:		if (p2 + 2 < pend
    #####:11566:		    && ((re_opcode_t) *p2 == stop_memory
    #####:11567:			|| (re_opcode_t) *p2 == start_memory))
    #####:11568:		  p2 += 3;
    #####:11569:		else if (p2 + 6 < pend
    #####:11570:			 && (re_opcode_t) *p2 == dummy_failure_jump)
    #####:11571:		  p2 += 6;
        -:11572:		else
        -:11573:		  break;
        -:11574:	      }
        -:11575:
    #####:11576:	    p1 = p + mcnt;
        -:11577:	    /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
        -:11578:	       to the `maybe_finalize_jump' of this case.  Examine what
        -:11579:	       follows.  */
        -:11580:
        -:11581:            /* If we're at the end of the pattern, we can change.  */
    #####:11582:            if (p2 == pend)
        -:11583:	      {
        -:11584:		/* Consider what happens when matching ":\(.*\)"
        -:11585:		   against ":/".  I don't really understand this code
        -:11586:		   yet.  */
    #####:11587:  	        p[-3] = (unsigned char) pop_failure_jump;
        -:11588:                DEBUG_PRINT1
        -:11589:                  ("  End of pattern: change to `pop_failure_jump'.\n");
        -:11590:              }
        -:11591:
    #####:11592:            else if ((re_opcode_t) *p2 == exactn
    #####:11593:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
    #####:11594:	      {
    #####:11595:		register unsigned char c
    #####:11596:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
        -:11597:
    #####:11598:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
        -:11599:                  {
    #####:11600:  		    p[-3] = (unsigned char) pop_failure_jump;
        -:11601:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
        -:11602:                                  c, p1[5]);
        -:11603:                  }
        -:11604:
    #####:11605:		else if ((re_opcode_t) p1[3] == charset
    #####:11606:			 || (re_opcode_t) p1[3] == charset_not)
        -:11607:		  {
    #####:11608:		    int not = (re_opcode_t) p1[3] == charset_not;
        -:11609:
    #####:11610:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
    #####:11611:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
    #####:11612:		      not = !not;
        -:11613:
        -:11614:                    /* `not' is equal to 1 if c would match, which means
        -:11615:                        that we can't change to pop_failure_jump.  */
    #####:11616:		    if (!not)
        -:11617:                      {
    #####:11618:  		        p[-3] = (unsigned char) pop_failure_jump;
        -:11619:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -:11620:                      }
        -:11621:		  }
        -:11622:	      }
    #####:11623:            else if ((re_opcode_t) *p2 == charset)
        -:11624:	      {
        -:11625:#ifdef DEBUG
        -:11626:		register unsigned char c
        -:11627:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
        -:11628:#endif
        -:11629:
        -:11630:#if 0
        -:11631:                if ((re_opcode_t) p1[3] == exactn
        -:11632:		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[5]
        -:11633:			  && (p2[2 + p1[5] / BYTEWIDTH]
        -:11634:			      & (1 << (p1[5] % BYTEWIDTH)))))
        -:11635:#else
    #####:11636:                if ((re_opcode_t) p1[3] == exactn
    #####:11637:		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[4]
    #####:11638:			  && (p2[2 + p1[4] / BYTEWIDTH]
    #####:11639:			      & (1 << (p1[4] % BYTEWIDTH)))))
        -:11640:#endif
        -:11641:                  {
    #####:11642:  		    p[-3] = (unsigned char) pop_failure_jump;
        -:11643:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
        -:11644:                                  c, p1[5]);
        -:11645:                  }
        -:11646:
    #####:11647:		else if ((re_opcode_t) p1[3] == charset_not)
        -:11648:		  {
        -:11649:		    int idx;
        -:11650:		    /* We win if the charset_not inside the loop
        -:11651:		       lists every character listed in the charset after.  */
    #####:11652:		    for (idx = 0; idx < (int) p2[1]; idx++)
    #####:11653:		      if (! (p2[2 + idx] == 0
    #####:11654:			     || (idx < (int) p1[4]
    #####:11655:				 && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))
        -:11656:			break;
        -:11657:
    #####:11658:		    if (idx == p2[1])
        -:11659:                      {
    #####:11660:  		        p[-3] = (unsigned char) pop_failure_jump;
        -:11661:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -:11662:                      }
        -:11663:		  }
    #####:11664:		else if ((re_opcode_t) p1[3] == charset)
        -:11665:		  {
        -:11666:		    int idx;
        -:11667:		    /* We win if the charset inside the loop
        -:11668:		       has no overlap with the one after the loop.  */
    #####:11669:		    for (idx = 0;
    #####:11670:			 idx < (int) p2[1] && idx < (int) p1[4];
    #####:11671:			 idx++)
    #####:11672:		      if ((p2[2 + idx] & p1[5 + idx]) != 0)
    #####:11673:			break;
        -:11674:
    #####:11675:		    if (idx == p2[1] || idx == p1[4])
        -:11676:                      {
    #####:11677:  		        p[-3] = (unsigned char) pop_failure_jump;
        -:11678:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -:11679:                      }
        -:11680:		  }
        -:11681:	      }
        -:11682:	  }
    #####:11683:	  p -= 2;		/* Point at relative address again.  */
    #####:11684:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
        -:11685:	    {
    #####:11686:	      p[-1] = (unsigned char) jump;
        -:11687:              DEBUG_PRINT1 ("  Match => jump.\n");
    #####:11688:	      goto unconditional_jump;
        -:11689:	    }
        -:11690:        /* Note fall through.  */
        -:11691:
        -:11692:
        -:11693:	/* The end of a simple repeat has a pop_failure_jump back to
        -:11694:           its matching on_failure_jump, where the latter will push a
        -:11695:           failure point.  The pop_failure_jump takes off failure
        -:11696:           points put on by this pop_failure_jump's matching
        -:11697:           on_failure_jump; we got through the pattern to here from the
        -:11698:           matching on_failure_jump, so didn't fail.  */
        -:11699:        case pop_failure_jump:
        -:11700:          {
        -:11701:            /* We need to pass separate storage for the lowest and
        -:11702:               highest registers, even though we don't care about the
        -:11703:               actual values.  Otherwise, we will restore only one
        -:11704:               register from the stack, since lowest will == highest in
        -:11705:               `pop_failure_point'.  */
        -:11706:            active_reg_t dummy_low_reg, dummy_high_reg;
        -:11707:            unsigned char *pdummy;
        -:11708:            const char *sdummy;
        -:11709:
        -:11710:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
    #####:11711:            POP_FAILURE_POINT (sdummy, pdummy,
        -:11712:                               dummy_low_reg, dummy_high_reg,
        -:11713:                               reg_dummy, reg_dummy, reg_info_dummy);
        -:11714:          }
        -:11715:	  /* Note fall through.  */
        -:11716:
    #####:11717:	unconditional_jump:
        -:11718:#ifdef _LIBC
        -:11719:	  DEBUG_PRINT2 ("\n%p: ", p);
        -:11720:#else
        -:11721:	  DEBUG_PRINT2 ("\n0x%x: ", p);
        -:11722:#endif
        -:11723:          /* Note fall through.  */
        -:11724:
        -:11725:        /* Unconditionally jump (without popping any failure points).  */
    #####:11726:        case jump:
    #####:11727:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
        -:11728:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
    #####:11729:	  p += mcnt;				/* Do the jump.  */
        -:11730:#ifdef _LIBC
        -:11731:          DEBUG_PRINT2 ("(to %p).\n", p);
        -:11732:#else
        -:11733:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
        -:11734:#endif
    #####:11735:	  break;
        -:11736:
        -:11737:
        -:11738:        /* We need this opcode so we can detect where alternatives end
        -:11739:           in `group_match_null_string_p' et al.  */
    #####:11740:        case jump_past_alt:
        -:11741:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
    #####:11742:          goto unconditional_jump;
        -:11743:
        -:11744:
        -:11745:        /* Normally, the on_failure_jump pushes a failure point, which
        -:11746:           then gets popped at pop_failure_jump.  We will end up at
        -:11747:           pop_failure_jump, also, and with a pattern of, say, `a+', we
        -:11748:           are skipping over the on_failure_jump, so we have to push
        -:11749:           something meaningless for pop_failure_jump to pop.  */
    #####:11750:        case dummy_failure_jump:
        -:11751:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
        -:11752:          /* It doesn't matter what we push for the string here.  What
        -:11753:             the code at `fail' tests is the value for the pattern.  */
    #####:11754:          PUSH_FAILURE_POINT (0, 0, -2);
    #####:11755:          goto unconditional_jump;
        -:11756:
        -:11757:
        -:11758:        /* At the end of an alternative, we need to push a dummy failure
        -:11759:           point in case we are followed by a `pop_failure_jump', because
        -:11760:           we don't want the failure point for the alternative to be
        -:11761:           popped.  For example, matching `(a|ab)*' against `aab'
        -:11762:           requires that we match the `ab' alternative.  */
    #####:11763:        case push_dummy_failure:
        -:11764:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
        -:11765:          /* See comments just above at `dummy_failure_jump' about the
        -:11766:             two zeroes.  */
    #####:11767:          PUSH_FAILURE_POINT (0, 0, -2);
    #####:11768:          break;
        -:11769:
        -:11770:        /* Have to succeed matching what follows at least n times.
        -:11771:           After that, handle like `on_failure_jump'.  */
    #####:11772:        case succeed_n:
    #####:11773:          EXTRACT_NUMBER (mcnt, p + 2);
        -:11774:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
        -:11775:
        -:11776:          assert (mcnt >= 0);
        -:11777:          /* Originally, this is how many times we HAVE to succeed.  */
    #####:11778:          if (mcnt > 0)
        -:11779:            {
    #####:11780:               mcnt--;
    #####:11781:	       p += 2;
    #####:11782:               STORE_NUMBER_AND_INCR (p, mcnt);
        -:11783:#ifdef _LIBC
        -:11784:               DEBUG_PRINT3 ("  Setting %p to %d.\n", p - 2, mcnt);
        -:11785:#else
        -:11786:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p - 2, mcnt);
        -:11787:#endif
        -:11788:            }
    #####:11789:	  else if (mcnt == 0)
        -:11790:            {
        -:11791:#ifdef _LIBC
        -:11792:              DEBUG_PRINT2 ("  Setting two bytes from %p to no_op.\n", p+2);
        -:11793:#else
        -:11794:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
        -:11795:#endif
    #####:11796:	      p[2] = (unsigned char) no_op;
    #####:11797:              p[3] = (unsigned char) no_op;
    #####:11798:              goto on_failure;
        -:11799:            }
    #####:11800:          break;
        -:11801:
    #####:11802:        case jump_n:
    #####:11803:          EXTRACT_NUMBER (mcnt, p + 2);
        -:11804:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
        -:11805:
        -:11806:          /* Originally, this is how many times we CAN jump.  */
    #####:11807:          if (mcnt)
        -:11808:            {
    #####:11809:               mcnt--;
    #####:11810:               STORE_NUMBER (p + 2, mcnt);
        -:11811:#ifdef _LIBC
        -:11812:               DEBUG_PRINT3 ("  Setting %p to %d.\n", p + 2, mcnt);
        -:11813:#else
        -:11814:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p + 2, mcnt);
        -:11815:#endif
    #####:11816:	       goto unconditional_jump;
        -:11817:            }
        -:11818:          /* If don't have to jump any more, skip over the rest of command.  */
        -:11819:	  else
    #####:11820:	    p += 4;
    #####:11821:          break;
        -:11822:
    #####:11823:	case set_number_at:
        -:11824:	  {
        -:11825:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
        -:11826:
    #####:11827:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
    #####:11828:            p1 = p + mcnt;
    #####:11829:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:11830:#ifdef _LIBC
        -:11831:            DEBUG_PRINT3 ("  Setting %p to %d.\n", p1, mcnt);
        -:11832:#else
        -:11833:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
        -:11834:#endif
    #####:11835:	    STORE_NUMBER (p1, mcnt);
    #####:11836:            break;
        -:11837:          }
        -:11838:
        -:11839:#if 0
        -:11840:	/* The DEC Alpha C compiler 3.x generates incorrect code for the
        -:11841:	   test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of
        -:11842:	   AT_WORD_BOUNDARY, so this code is disabled.  Expanding the
        -:11843:	   macro and introducing temporary variables works around the bug.  */
        -:11844:
        -:11845:	case wordbound:
        -:11846:	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
        -:11847:	  if (AT_WORD_BOUNDARY (d))
        -:11848:	    break;
        -:11849:	  goto fail;
        -:11850:
        -:11851:	case notwordbound:
        -:11852:	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
        -:11853:	  if (AT_WORD_BOUNDARY (d))
        -:11854:	    goto fail;
        -:11855:	  break;
        -:11856:#else
    #####:11857:	case wordbound:
        -:11858:	{
        -:11859:	  boolean prevchar, thischar;
        -:11860:
        -:11861:	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
    #####:11862:	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
        -:11863:	    break;
        -:11864:
    #####:11865:	  prevchar = WORDCHAR_P (d - 1);
    #####:11866:	  thischar = WORDCHAR_P (d);
    #####:11867:	  if (prevchar != thischar)
    #####:11868:	    break;
    #####:11869:	  goto fail;
        -:11870:	}
        -:11871:
    #####:11872:      case notwordbound:
        -:11873:	{
        -:11874:	  boolean prevchar, thischar;
        -:11875:
        -:11876:	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
    #####:11877:	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
    #####:11878:	    goto fail;
        -:11879:
    #####:11880:	  prevchar = WORDCHAR_P (d - 1);
    #####:11881:	  thischar = WORDCHAR_P (d);
    #####:11882:	  if (prevchar != thischar)
    #####:11883:	    goto fail;
    #####:11884:	  break;
        -:11885:	}
        -:11886:#endif
        -:11887:
    #####:11888:	case wordbeg:
        -:11889:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
    #####:11890:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
        -:11891:	    break;
    #####:11892:          goto fail;
        -:11893:
    #####:11894:	case wordend:
        -:11895:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
    #####:11896:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
    #####:11897:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
        -:11898:	    break;
    #####:11899:          goto fail;
        -:11900:
        -:11901:#ifdef emacs
        -:11902:  	case before_dot:
        -:11903:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
        -:11904: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
        -:11905:  	    goto fail;
        -:11906:  	  break;
        -:11907:
        -:11908:  	case at_dot:
        -:11909:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
        -:11910: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
        -:11911:  	    goto fail;
        -:11912:  	  break;
        -:11913:
        -:11914:  	case after_dot:
        -:11915:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
        -:11916:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
        -:11917:  	    goto fail;
        -:11918:  	  break;
        -:11919:
        -:11920:	case syntaxspec:
        -:11921:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
        -:11922:	  mcnt = *p++;
        -:11923:	  goto matchsyntax;
        -:11924:
        -:11925:        case wordchar:
        -:11926:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
        -:11927:	  mcnt = (int) Sword;
        -:11928:        matchsyntax:
        -:11929:	  PREFETCH ();
        -:11930:	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
        -:11931:	  d++;
        -:11932:	  if (SYNTAX (d[-1]) != (enum syntaxcode) mcnt)
        -:11933:	    goto fail;
        -:11934:          SET_REGS_MATCHED ();
        -:11935:	  break;
        -:11936:
        -:11937:	case notsyntaxspec:
        -:11938:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
        -:11939:	  mcnt = *p++;
        -:11940:	  goto matchnotsyntax;
        -:11941:
        -:11942:        case notwordchar:
        -:11943:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
        -:11944:	  mcnt = (int) Sword;
        -:11945:        matchnotsyntax:
        -:11946:	  PREFETCH ();
        -:11947:	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
        -:11948:	  d++;
        -:11949:	  if (SYNTAX (d[-1]) == (enum syntaxcode) mcnt)
        -:11950:	    goto fail;
        -:11951:	  SET_REGS_MATCHED ();
        -:11952:          break;
        -:11953:
        -:11954:#else /* not emacs */
    #####:11955:	case wordchar:
        -:11956:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
    #####:11957:	  PREFETCH ();
    #####:11958:          if (!WORDCHAR_P (d))
    #####:11959:            goto fail;
    #####:11960:	  SET_REGS_MATCHED ();
    #####:11961:          d++;
    #####:11962:	  break;
        -:11963:
    #####:11964:	case notwordchar:
        -:11965:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
    #####:11966:	  PREFETCH ();
    #####:11967:	  if (WORDCHAR_P (d))
    #####:11968:            goto fail;
    #####:11969:          SET_REGS_MATCHED ();
    #####:11970:          d++;
    #####:11971:	  break;
        -:11972:#endif /* not emacs */
        -:11973:
    #####:11974:        default:
    #####:11975:          abort ();
        -:11976:	}
    #####:11977:      continue;  /* Successfully executed one pattern command; keep going.  */
        -:11978:
        -:11979:
        -:11980:    /* We goto here if a matching operation fails. */
    #####:11981:    fail:
    #####:11982:      if (!FAIL_STACK_EMPTY ())
        -:11983:	{ /* A restart point is known.  Restore to that state.  */
        -:11984:          DEBUG_PRINT1 ("\nFAIL:\n");
    #####:11985:          POP_FAILURE_POINT (d, p,
        -:11986:                             lowest_active_reg, highest_active_reg,
        -:11987:                             regstart, regend, reg_info);
        -:11988:
        -:11989:          /* If this failure point is a dummy, try the next one.  */
    #####:11990:          if (!p)
    #####:11991:	    goto fail;
        -:11992:
        -:11993:          /* If we failed to the end of the pattern, don't examine *p.  */
        -:11994:	  assert (p <= pend);
    #####:11995:          if (p < pend)
        -:11996:            {
    #####:11997:              boolean is_a_jump_n = false;
        -:11998:
        -:11999:              /* If failed to a backwards jump that's part of a repetition
        -:12000:                 loop, need to pop this failure point and use the next one.  */
    #####:12001:              switch ((re_opcode_t) *p)
        -:12002:                {
    #####:12003:                case jump_n:
    #####:12004:                  is_a_jump_n = true;
    #####:12005:                case maybe_pop_jump:
        -:12006:                case pop_failure_jump:
        -:12007:                case jump:
    #####:12008:                  p1 = p + 1;
    #####:12009:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12010:                  p1 += mcnt;
        -:12011:
    #####:12012:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
    #####:12013:                      || (!is_a_jump_n
    #####:12014:                          && (re_opcode_t) *p1 == on_failure_jump))
    #####:12015:                    goto fail;
    #####:12016:                  break;
    #####:12017:                default:
        -:12018:                  /* do nothing */ ;
        -:12019:                }
        -:12020:            }
        -:12021:
    #####:12022:          if (d >= string1 && d <= end1)
    #####:12023:	    dend = end_match_1;
        -:12024:        }
        -:12025:      else
    #####:12026:        break;   /* Matching at this starting point really fails.  */
        -:12027:    } /* for (;;) */
        -:12028:
    #####:12029:  if (best_regs_set)
    #####:12030:    goto restore_best_regs;
        -:12031:
    #####:12032:  FREE_VARIABLES ();
        -:12033:
    #####:12034:  return -1;         			/* Failure to match.  */
        -:12035:} /* re_match_2 */
        -:12036:
        -:12037:/* Subroutine definitions for re_match_2.  */
        -:12038:
        -:12039:
        -:12040:/* We are passed P pointing to a register number after a start_memory.
        -:12041:
        -:12042:   Return true if the pattern up to the corresponding stop_memory can
        -:12043:   match the empty string, and false otherwise.
        -:12044:
        -:12045:   If we find the matching stop_memory, sets P to point to one past its number.
        -:12046:   Otherwise, sets P to an undefined byte less than or equal to END.
        -:12047:
        -:12048:   We don't handle duplicates properly (yet).  */
        -:12049:
        -:12050:static boolean
    #####:12051:group_match_null_string_p (p, end, reg_info)
        -:12052:    unsigned char **p, *end;
        -:12053:    register_info_type *reg_info;
        -:12054:{
        -:12055:  int mcnt;
        -:12056:  /* Point to after the args to the start_memory.  */
    #####:12057:  unsigned char *p1 = *p + 2;
        -:12058:
    #####:12059:  while (p1 < end)
        -:12060:    {
        -:12061:      /* Skip over opcodes that can match nothing, and return true or
        -:12062:	 false, as appropriate, when we get to one that can't, or to the
        -:12063:         matching stop_memory.  */
        -:12064:
    #####:12065:      switch ((re_opcode_t) *p1)
        -:12066:        {
        -:12067:        /* Could be either a loop or a series of alternatives.  */
    #####:12068:        case on_failure_jump:
    #####:12069:          p1++;
    #####:12070:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -:12071:
        -:12072:          /* If the next operation is not a jump backwards in the
        -:12073:	     pattern.  */
        -:12074:
    #####:12075:	  if (mcnt >= 0)
        -:12076:	    {
        -:12077:              /* Go through the on_failure_jumps of the alternatives,
        -:12078:                 seeing if any of the alternatives cannot match nothing.
        -:12079:                 The last alternative starts with only a jump,
        -:12080:                 whereas the rest start with on_failure_jump and end
        -:12081:                 with a jump, e.g., here is the pattern for `a|b|c':
        -:12082:
        -:12083:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
        -:12084:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
        -:12085:                 /exactn/1/c
        -:12086:
        -:12087:                 So, we have to first go through the first (n-1)
        -:12088:                 alternatives and then deal with the last one separately.  */
        -:12089:
        -:12090:
        -:12091:              /* Deal with the first (n-1) alternatives, which start
        -:12092:                 with an on_failure_jump (see above) that jumps to right
        -:12093:                 past a jump_past_alt.  */
        -:12094:
    #####:12095:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
        -:12096:                {
        -:12097:                  /* `mcnt' holds how many bytes long the alternative
        -:12098:                     is, including the ending `jump_past_alt' and
        -:12099:                     its number.  */
        -:12100:
    #####:12101:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3,
        -:12102:				                      reg_info))
    #####:12103:                    return false;
        -:12104:
        -:12105:                  /* Move to right after this alternative, including the
        -:12106:		     jump_past_alt.  */
    #####:12107:                  p1 += mcnt;
        -:12108:
        -:12109:                  /* Break if it's the beginning of an n-th alternative
        -:12110:                     that doesn't begin with an on_failure_jump.  */
    #####:12111:                  if ((re_opcode_t) *p1 != on_failure_jump)
    #####:12112:                    break;
        -:12113:
        -:12114:		  /* Still have to check that it's not an n-th
        -:12115:		     alternative that starts with an on_failure_jump.  */
    #####:12116:		  p1++;
    #####:12117:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12118:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
        -:12119:                    {
        -:12120:		      /* Get to the beginning of the n-th alternative.  */
    #####:12121:                      p1 -= 3;
    #####:12122:                      break;
        -:12123:                    }
        -:12124:                }
        -:12125:
        -:12126:              /* Deal with the last alternative: go back and get number
        -:12127:                 of the `jump_past_alt' just before it.  `mcnt' contains
        -:12128:                 the length of the alternative.  */
    #####:12129:              EXTRACT_NUMBER (mcnt, p1 - 2);
        -:12130:
    #####:12131:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
    #####:12132:                return false;
        -:12133:
    #####:12134:              p1 += mcnt;	/* Get past the n-th alternative.  */
        -:12135:            } /* if mcnt > 0 */
    #####:12136:          break;
        -:12137:
        -:12138:
    #####:12139:        case stop_memory:
        -:12140:	  assert (p1[1] == **p);
    #####:12141:          *p = p1 + 2;
    #####:12142:          return true;
        -:12143:
        -:12144:
    #####:12145:        default:
    #####:12146:          if (!common_op_match_null_string_p (&p1, end, reg_info))
    #####:12147:            return false;
        -:12148:        }
        -:12149:    } /* while p1 < end */
        -:12150:
    #####:12151:  return false;
        -:12152:} /* group_match_null_string_p */
        -:12153:
        -:12154:
        -:12155:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
        -:12156:   It expects P to be the first byte of a single alternative and END one
        -:12157:   byte past the last. The alternative can contain groups.  */
        -:12158:
        -:12159:static boolean
    #####:12160:alt_match_null_string_p (p, end, reg_info)
        -:12161:    unsigned char *p, *end;
        -:12162:    register_info_type *reg_info;
        -:12163:{
        -:12164:  int mcnt;
    #####:12165:  unsigned char *p1 = p;
        -:12166:
    #####:12167:  while (p1 < end)
        -:12168:    {
        -:12169:      /* Skip over opcodes that can match nothing, and break when we get
        -:12170:         to one that can't.  */
        -:12171:
    #####:12172:      switch ((re_opcode_t) *p1)
        -:12173:        {
        -:12174:	/* It's a loop.  */
    #####:12175:        case on_failure_jump:
    #####:12176:          p1++;
    #####:12177:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12178:          p1 += mcnt;
    #####:12179:          break;
        -:12180:
    #####:12181:	default:
    #####:12182:          if (!common_op_match_null_string_p (&p1, end, reg_info))
    #####:12183:            return false;
        -:12184:        }
        -:12185:    }  /* while p1 < end */
        -:12186:
    #####:12187:  return true;
        -:12188:} /* alt_match_null_string_p */
        -:12189:
        -:12190:
        -:12191:/* Deals with the ops common to group_match_null_string_p and
        -:12192:   alt_match_null_string_p.
        -:12193:
        -:12194:   Sets P to one after the op and its arguments, if any.  */
        -:12195:
        -:12196:static boolean
    #####:12197:common_op_match_null_string_p (p, end, reg_info)
        -:12198:    unsigned char **p, *end;
        -:12199:    register_info_type *reg_info;
        -:12200:{
        -:12201:  int mcnt;
        -:12202:  boolean ret;
        -:12203:  int reg_no;
    #####:12204:  unsigned char *p1 = *p;
        -:12205:
    #####:12206:  switch ((re_opcode_t) *p1++)
        -:12207:    {
    #####:12208:    case no_op:
        -:12209:    case begline:
        -:12210:    case endline:
        -:12211:    case begbuf:
        -:12212:    case endbuf:
        -:12213:    case wordbeg:
        -:12214:    case wordend:
        -:12215:    case wordbound:
        -:12216:    case notwordbound:
        -:12217:#ifdef emacs
        -:12218:    case before_dot:
        -:12219:    case at_dot:
        -:12220:    case after_dot:
        -:12221:#endif
    #####:12222:      break;
        -:12223:
    #####:12224:    case start_memory:
    #####:12225:      reg_no = *p1;
        -:12226:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
    #####:12227:      ret = group_match_null_string_p (&p1, end, reg_info);
        -:12228:
        -:12229:      /* Have to set this here in case we're checking a group which
        -:12230:         contains a group and a back reference to it.  */
        -:12231:
    #####:12232:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
    #####:12233:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
        -:12234:
    #####:12235:      if (!ret)
    #####:12236:        return false;
    #####:12237:      break;
        -:12238:
        -:12239:    /* If this is an optimized succeed_n for zero times, make the jump.  */
    #####:12240:    case jump:
    #####:12241:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12242:      if (mcnt >= 0)
    #####:12243:        p1 += mcnt;
        -:12244:      else
    #####:12245:        return false;
    #####:12246:      break;
        -:12247:
    #####:12248:    case succeed_n:
        -:12249:      /* Get to the number of times to succeed.  */
    #####:12250:      p1 += 2;
    #####:12251:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -:12252:
    #####:12253:      if (mcnt == 0)
        -:12254:        {
    #####:12255:          p1 -= 4;
    #####:12256:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12257:          p1 += mcnt;
        -:12258:        }
        -:12259:      else
    #####:12260:        return false;
    #####:12261:      break;
        -:12262:
    #####:12263:    case duplicate:
    #####:12264:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
    #####:12265:        return false;
    #####:12266:      break;
        -:12267:
    #####:12268:    case set_number_at:
    #####:12269:      p1 += 4;
        -:12270:
    #####:12271:    default:
        -:12272:      /* All other opcodes mean we cannot match the empty string.  */
    #####:12273:      return false;
        -:12274:  }
        -:12275:
    #####:12276:  *p = p1;
    #####:12277:  return true;
        -:12278:} /* common_op_match_null_string_p */
        -:12279:
        -:12280:
        -:12281:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
        -:12282:   bytes; nonzero otherwise.  */
        -:12283:
        -:12284:static int
    #####:12285:bcmp_translate (s1, s2, len, translate)
        -:12286:     const char *s1, *s2;
        -:12287:     register int len;
        -:12288:     RE_TRANSLATE_TYPE translate;
        -:12289:{
    #####:12290:  register const unsigned char *p1 = (const unsigned char *) s1;
    #####:12291:  register const unsigned char *p2 = (const unsigned char *) s2;
    #####:12292:  while (len)
        -:12293:    {
    #####:12294:      if (translate[*p1++] != translate[*p2++]) return 1;
    #####:12295:      len--;
        -:12296:    }
    #####:12297:  return 0;
        -:12298:}
        -:12299:
        -:12300:/* Entry points for GNU code.  */
        -:12301:
        -:12302:/* re_compile_pattern is the GNU regular expression compiler: it
        -:12303:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
        -:12304:   Returns 0 if the pattern was valid, otherwise an error string.
        -:12305:
        -:12306:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
        -:12307:   are set in BUFP on entry.
        -:12308:
        -:12309:   We call regex_compile to do the actual compilation.  */
        -:12310:
        -:12311:const char *
        1:12312:re_compile_pattern (pattern, length, bufp)
        -:12313:     const char *pattern;
        -:12314:     size_t length;
        -:12315:     struct re_pattern_buffer *bufp;
        -:12316:{
        -:12317:  reg_errcode_t ret;
        -:12318:
        -:12319:  /* GNU code is written to assume at least RE_NREGS registers will be set
        -:12320:     (and at least one extra will be -1).  */
        1:12321:  bufp->regs_allocated = REGS_UNALLOCATED;
        -:12322:
        -:12323:  /* And GNU code determines whether or not to get register information
        -:12324:     by passing null for the REGS argument to re_match, etc., not by
        -:12325:     setting no_sub.  */
        1:12326:  bufp->no_sub = 0;
        -:12327:
        -:12328:  /* Match anchors at newline.  */
        1:12329:  bufp->newline_anchor = 1;
        -:12330:
        1:12331:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
        -:12332:
        -:12333:#ifndef FAULTY_F_KP_2
        1:12334:  if (!ret)
        -:12335:#else
        -:12336:  if (ret)
        -:12337:#endif
        1:12338:    return NULL;
    #####:12339:  return gettext (re_error_msgid[(int) ret]);
        -:12340:}
        -:12341:
        -:12342:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -:12343:   them unless specifically requested.  */
        -:12344:
        -:12345:#if defined (_REGEX_RE_COMP) || defined (_LIBC)
        -:12346:
        -:12347:/* BSD has one and only one pattern buffer.  */
        -:12348:static struct re_pattern_buffer re_comp_buf;
        -:12349:
        -:12350:char *
        -:12351:#ifdef _LIBC
        -:12352:/* Make these definitions weak in libc, so POSIX programs can redefine
        -:12353:   these names if they don't use our functions, and still use
        -:12354:   regcomp/regexec below without link errors.  */
        -:12355:weak_function
        -:12356:#endif
        -:12357:re_comp (s)
        -:12358:    const char *s;
        -:12359:{
        -:12360:  reg_errcode_t ret;
        -:12361:
        -:12362:  if (!s)
        -:12363:    {
        -:12364:      if (!re_comp_buf.buffer)
        -:12365:	return gettext ("No previous regular expression");
        -:12366:      return 0;
        -:12367:    }
        -:12368:
        -:12369:  if (!re_comp_buf.buffer)
        -:12370:    {
        -:12371:      re_comp_buf.buffer = (unsigned char *) malloc (200);
        -:12372:      if (re_comp_buf.buffer == NULL)
        -:12373:        return gettext (re_error_msgid[(int) REG_ESPACE]);
        -:12374:      re_comp_buf.allocated = 200;
        -:12375:
        -:12376:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
        -:12377:      if (re_comp_buf.fastmap == NULL)
        -:12378:	return gettext (re_error_msgid[(int) REG_ESPACE]);
        -:12379:    }
        -:12380:
        -:12381:  /* Since `re_exec' always passes NULL for the `regs' argument, we
        -:12382:     don't need to initialize the pattern buffer fields which affect it.  */
        -:12383:
        -:12384:  /* Match anchors at newlines.  */
        -:12385:  re_comp_buf.newline_anchor = 1;
        -:12386:
        -:12387:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
        -:12388:
        -:12389:  if (!ret)
        -:12390:    return NULL;
        -:12391:
        -:12392:  /* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
        -:12393:  return (char *) gettext (re_error_msgid[(int) ret]);
        -:12394:}
        -:12395:
        -:12396:
        -:12397:int
        -:12398:#ifdef _LIBC
        -:12399:weak_function
        -:12400:#endif
        -:12401:re_exec (s)
        -:12402:    const char *s;
        -:12403:{
        -:12404:  const int len = strlen (s);
        -:12405:  return
        -:12406:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
        -:12407:}
        -:12408:
        -:12409:#endif /* _REGEX_RE_COMP */
        -:12410:
        -:12411:/* POSIX.2 functions.  Don't define these for Emacs.  */
        -:12412:
        -:12413:#ifndef emacs
        -:12414:
        -:12415:/* regcomp takes a regular expression as a string and compiles it.
        -:12416:
        -:12417:   PREG is a regex_t *.  We do not expect any fields to be initialized,
        -:12418:   since POSIX says we shouldn't.  Thus, we set
        -:12419:
        -:12420:     `buffer' to the compiled pattern;
        -:12421:     `used' to the length of the compiled pattern;
        -:12422:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
        -:12423:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
        -:12424:       RE_SYNTAX_POSIX_BASIC;
        -:12425:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
        -:12426:     `fastmap' and `fastmap_accurate' to zero;
        -:12427:     `re_nsub' to the number of subexpressions in PATTERN.
        -:12428:
        -:12429:   PATTERN is the address of the pattern string.
        -:12430:
        -:12431:   CFLAGS is a series of bits which affect compilation.
        -:12432:
        -:12433:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
        -:12434:     use POSIX basic syntax.
        -:12435:
        -:12436:     If REG_NEWLINE is set, then . and [^...] don't match newline.
        -:12437:     Also, regexec will try a match beginning after every newline.
        -:12438:
        -:12439:     If REG_ICASE is set, then we considers upper- and lowercase
        -:12440:     versions of letters to be equivalent when matching.
        -:12441:
        -:12442:     If REG_NOSUB is set, then when PREG is passed to regexec, that
        -:12443:     routine will report only success or failure, and nothing about the
        -:12444:     registers.
        -:12445:
        -:12446:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
        -:12447:   the return codes and their meanings.)  */
        -:12448:
        -:12449:int
    #####:12450:regcomp (preg, pattern, cflags)
        -:12451:    regex_t *preg;
        -:12452:    const char *pattern;
        -:12453:    int cflags;
        -:12454:{
        -:12455:  reg_errcode_t ret;
    #####:12456:  reg_syntax_t syntax
    #####:12457:    = (cflags & REG_EXTENDED) ?
    #####:12458:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
        -:12459:
        -:12460:  /* regex_compile will allocate the space for the compiled pattern.  */
    #####:12461:  preg->buffer = 0;
    #####:12462:  preg->allocated = 0;
    #####:12463:  preg->used = 0;
        -:12464:
        -:12465:  /* Don't bother to use a fastmap when searching.  This simplifies the
        -:12466:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
        -:12467:     characters after newlines into the fastmap.  This way, we just try
        -:12468:     every character.  */
    #####:12469:  preg->fastmap = 0;
        -:12470:
    #####:12471:  if (cflags & REG_ICASE)
        -:12472:    {
        -:12473:      unsigned i;
        -:12474:
        -:12475:      preg->translate
    #####:12476:	= (RE_TRANSLATE_TYPE) malloc (CHAR_SET_SIZE
        -:12477:				      * sizeof (*(RE_TRANSLATE_TYPE)0));
    #####:12478:      if (preg->translate == NULL)
    #####:12479:        return (int) REG_ESPACE;
        -:12480:
        -:12481:      /* Map uppercase characters to corresponding lowercase ones.  */
    #####:12482:      for (i = 0; i < CHAR_SET_SIZE; i++)
    #####:12483:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
        -:12484:    }
        -:12485:  else
    #####:12486:    preg->translate = NULL;
        -:12487:
        -:12488:  /* If REG_NEWLINE is set, newlines are treated differently.  */
    #####:12489:  if (cflags & REG_NEWLINE)
        -:12490:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####:12491:      syntax &= ~RE_DOT_NEWLINE;
    #####:12492:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -:12493:      /* It also changes the matching behavior.  */
    #####:12494:      preg->newline_anchor = 1;
        -:12495:    }
        -:12496:  else
    #####:12497:    preg->newline_anchor = 0;
        -:12498:
    #####:12499:  preg->no_sub = !!(cflags & REG_NOSUB);
        -:12500:
        -:12501:  /* POSIX says a null character in the pattern terminates it, so we
        -:12502:     can use strlen here in compiling the pattern.  */
    #####:12503:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
        -:12504:
        -:12505:  /* POSIX doesn't distinguish between an unmatched open-group and an
        -:12506:     unmatched close-group: both are REG_EPAREN.  */
    #####:12507:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
        -:12508:
    #####:12509:  return (int) ret;
        -:12510:}
        -:12511:
        -:12512:
        -:12513:/* regexec searches for a given pattern, specified by PREG, in the
        -:12514:   string STRING.
        -:12515:
        -:12516:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -:12517:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -:12518:   least NMATCH elements, and we set them to the offsets of the
        -:12519:   corresponding matched substrings.
        -:12520:
        -:12521:   EFLAGS specifies `execution flags' which affect matching: if
        -:12522:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -:12523:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -:12524:
        -:12525:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -:12526:
        -:12527:int
    #####:12528:regexec (preg, string, nmatch, pmatch, eflags)
        -:12529:    const regex_t *preg;
        -:12530:    const char *string;
        -:12531:    size_t nmatch;
        -:12532:    regmatch_t pmatch[];
        -:12533:    int eflags;
        -:12534:{
        -:12535:  int ret;
        -:12536:  struct re_registers regs;
        -:12537:  regex_t private_preg;
    #####:12538:  int len = strlen (string);
    #####:12539:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
        -:12540:
    #####:12541:  private_preg = *preg;
        -:12542:
    #####:12543:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
    #####:12544:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
        -:12545:
        -:12546:  /* The user has told us exactly how many registers to return
        -:12547:     information about, via `nmatch'.  We have to pass that on to the
        -:12548:     matching routines.  */
    #####:12549:  private_preg.regs_allocated = REGS_FIXED;
        -:12550:
    #####:12551:  if (want_reg_info)
        -:12552:    {
    #####:12553:      regs.num_regs = nmatch;
    #####:12554:      regs.start = TALLOC (nmatch, regoff_t);
    #####:12555:      regs.end = TALLOC (nmatch, regoff_t);
    #####:12556:      if (regs.start == NULL || regs.end == NULL)
    #####:12557:        return (int) REG_NOMATCH;
        -:12558:    }
        -:12559:
        -:12560:  /* Perform the searching operation.  */
    #####:12561:  ret = re_search (&private_preg, string, len,
        -:12562:                   /* start: */ 0, /* range: */ len,
        -:12563:                   want_reg_info ? &regs : (struct re_registers *) 0);
        -:12564:
        -:12565:  /* Copy the register information to the POSIX structure.  */
    #####:12566:  if (want_reg_info)
        -:12567:    {
    #####:12568:      if (ret >= 0)
        -:12569:        {
        -:12570:          unsigned r;
        -:12571:
    #####:12572:          for (r = 0; r < nmatch; r++)
        -:12573:            {
    #####:12574:              pmatch[r].rm_so = regs.start[r];
    #####:12575:              pmatch[r].rm_eo = regs.end[r];
        -:12576:            }
        -:12577:        }
        -:12578:
        -:12579:      /* If we needed the temporary register info, free the space now.  */
    #####:12580:      free (regs.start);
    #####:12581:      free (regs.end);
        -:12582:    }
        -:12583:
        -:12584:  /* We want zero return to mean success, unlike `re_search'.  */
    #####:12585:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
        -:12586:}
        -:12587:
        -:12588:
        -:12589:/* Returns a message corresponding to an error code, ERRCODE, returned
        -:12590:   from either regcomp or regexec.   We don't use PREG here.  */
        -:12591:
        -:12592:size_t
    #####:12593:regerror (errcode, preg, errbuf, errbuf_size)
        -:12594:    int errcode;
        -:12595:    const regex_t *preg;
        -:12596:    char *errbuf;
        -:12597:    size_t errbuf_size;
        -:12598:{
        -:12599:  const char *msg;
        -:12600:  size_t msg_size;
        -:12601:
    #####:12602:  if (errcode < 0
    #####:12603:      || errcode >= (int) (sizeof (re_error_msgid)
        -:12604:			   / sizeof (re_error_msgid[0])))
        -:12605:    /* Only error codes returned by the rest of the code should be passed
        -:12606:       to this routine.  If we are given anything else, or if other regex
        -:12607:       code generates an invalid error code, then the program has a bug.
        -:12608:       Dump core so we can fix it.  */
    #####:12609:    abort ();
        -:12610:
    #####:12611:  msg = gettext (re_error_msgid[errcode]);
        -:12612:
    #####:12613:  msg_size = strlen (msg) + 1; /* Includes the null.  */
        -:12614:
    #####:12615:  if (errbuf_size != 0)
        -:12616:    {
    #####:12617:      if (msg_size > errbuf_size)
        -:12618:        {
    #####:12619:          strncpy (errbuf, msg, errbuf_size - 1);
    #####:12620:          errbuf[errbuf_size - 1] = 0;
        -:12621:        }
        -:12622:      else
    #####:12623:        strcpy (errbuf, msg);
        -:12624:    }
        -:12625:
    #####:12626:  return msg_size;
        -:12627:}
        -:12628:
        -:12629:
        -:12630:/* Free dynamically allocated space used by PREG.  */
        -:12631:
        -:12632:void
    #####:12633:regfree (preg)
        -:12634:    regex_t *preg;
        -:12635:{
    #####:12636:  if (preg->buffer != NULL)
    #####:12637:    free (preg->buffer);
    #####:12638:  preg->buffer = NULL;
        -:12639:
    #####:12640:  preg->allocated = 0;
    #####:12641:  preg->used = 0;
        -:12642:
    #####:12643:  if (preg->fastmap != NULL)
    #####:12644:    free (preg->fastmap);
    #####:12645:  preg->fastmap = NULL;
    #####:12646:  preg->fastmap_accurate = 0;
        -:12647:
    #####:12648:  if (preg->translate != NULL)
    #####:12649:    free (preg->translate);
    #####:12650:  preg->translate = NULL;
    #####:12651:}
        -:12652:
        -:12653:#endif /* not emacs  */
